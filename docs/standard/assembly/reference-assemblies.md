---
title: 参照アセンブリ
description: 参照アセンブリについて説明します。これはライブラリのパブリック API サーフェイスのみを含む .NET の特殊なアセンブリです。
author: MSDN-WhiteKnight
ms.date: 09/12/2019
ms.technology: dotnet-standard
ms.openlocfilehash: f509397f5cb48a004b800014b2b071721e0d68b8
ms.sourcegitcommit: 1f12db2d852d05bed8c53845f0b5a57a762979c8
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/18/2019
ms.locfileid: "72584120"
---
# <a name="reference-assemblies"></a><span data-ttu-id="22ed2-103">参照アセンブリ</span><span class="sxs-lookup"><span data-stu-id="22ed2-103">Reference assemblies</span></span>

<span data-ttu-id="22ed2-104">"*参照アセンブリ*" は、ライブラリのパブリック API サーフェイスを表すために必要最小限のメタデータのみを含む特殊なアセンブリです。</span><span class="sxs-lookup"><span data-stu-id="22ed2-104">*Reference assemblies* are a special type of assembly that contain only the minimum amount of metadata required to represent the library's public API surface.</span></span> <span data-ttu-id="22ed2-105">これには、ビルド ツールでアセンブリ (したがってその名前) を参照するときに重要なすべてのメンバーの宣言が含まれます。ただし、すべてのメンバーの実装と、その API コントラクトに影響を与えないプライベート メンバーの宣言は除外されます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-105">They include declarations for all members that are significant when referencing an assembly in build tools (hence the name), but exclude all member implementations as well as declarations of private members that have no observable impact on their API contract.</span></span> <span data-ttu-id="22ed2-106">これに対して、通常のアセンブリは "*実装アセンブリ*" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-106">In contrast, regular assemblies are called *implementation assemblies*.</span></span> 

<span data-ttu-id="22ed2-107">参照アセンブリを実行用に読み込むことはできませんが、実装アセンブリと同じ方法でコンパイラの入力として渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-107">Reference assemblies cannot be loaded for execution, but they can be passed as compiler input in the same way as implementation assemblies.</span></span> <span data-ttu-id="22ed2-108">参照アセンブリは、通常、特定のプラットフォームまたはライブラリのソフトウェア開発キット (SDK) と共に配布されます。これは、開発者のマシンにのみインストールされる特別なソフトウェア コンポーネントです。</span><span class="sxs-lookup"><span data-stu-id="22ed2-108">Reference assemblies are usually distributed with the Software Development Kit (SDK) of a particular platform or library, a special software component installed only on developer machines.</span></span>

<span data-ttu-id="22ed2-109">開発者は、参照アセンブリを使用すると、そのバージョンの完全な実装アセンブリを持たなくても、特定のライブラリ バージョンを対象とするプログラムをビルドできます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-109">Using a reference assembly enables developers to build programs that target a specific library version without having the full implementation assembly for that version.</span></span> <span data-ttu-id="22ed2-110">たとえば、コンピューターに最新バージョンのライブラリのみがインストールされ、ライブラリの以前のバージョンのコンピューターを対象とするプログラムを構築するとします。</span><span class="sxs-lookup"><span data-stu-id="22ed2-110">Suppose, you have only the latest version of some library on your machine, but you want to build a program that targets a machine with an earlier version of that library.</span></span> <span data-ttu-id="22ed2-111">実装アセンブリに対して直接コンパイルする場合、以前のバージョンでは使用できない API メンバーを誤って使用する可能性があります。また、この誤りは、ターゲット コンピューターでプログラムをテストするときにのみ見つかります。</span><span class="sxs-lookup"><span data-stu-id="22ed2-111">If you compile directly against the implementation assembly, you might inadvertently use API members that aren't available in the earlier version, and you'll only find this mistake when testing the program on the target machine.</span></span> <span data-ttu-id="22ed2-112">以前のバージョンの参照アセンブリに対してコンパイルすると、すぐにコンパイル時エラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="22ed2-112">If you compile against the reference assembly for the earlier version, you'll immediately get a compile-time error.</span></span>

<span data-ttu-id="22ed2-113">また、参照アセンブリでは、コントラクト、つまり具象実装アセンブリに対応しない API のセットを表すことができます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-113">Additionally, a reference assembly can represent a contract, that is, a set of APIs that doesn't correspond to the concrete implementation assembly.</span></span> <span data-ttu-id="22ed2-114">"*コントラクト アセンブリ*" と呼ばれるこのような参照アセンブリを使用すると、同じ API のセットをサポートする複数のプラットフォームを対象にすることができます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-114">Such reference assembly, called the *contract assembly*, can be used to target multiple platforms that support the same set of APIs.</span></span> <span data-ttu-id="22ed2-115">たとえば、.NET Standard には、複数の .NET プラットフォーム間で共有される共通 API のセットを表すコントラクト アセンブリ *netstandard.dll* が用意されています。</span><span class="sxs-lookup"><span data-stu-id="22ed2-115">For example, .NET Standard provides the contract assembly, *netstandard.dll*, that represents the set of common APIs shared between different .NET platforms.</span></span> <span data-ttu-id="22ed2-116">このような API の実装は、.NET Framework 上の *mscorlib.dll* や .NET Core 上の *System.Private.CoreLib.dll* など、さまざまなプラットフォーム上のさまざまなアセンブリに含まれています。</span><span class="sxs-lookup"><span data-stu-id="22ed2-116">The implementations of these APIs are contained in different assemblies on different platforms, such as *mscorlib.dll* on .NET Framework or *System.Private.CoreLib.dll* on .NET Core.</span></span> <span data-ttu-id="22ed2-117">.NET Standard をターゲットとするライブラリは、.NET Standard をサポートするすべてのプラットフォームで実行できます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-117">A library that targets .NET Standard can run on all platforms that support .NET Standard.</span></span> 

## <a name="using-reference-assemblies"></a><span data-ttu-id="22ed2-118">参照アセンブリの使用</span><span class="sxs-lookup"><span data-stu-id="22ed2-118">Using reference assemblies</span></span>

<span data-ttu-id="22ed2-119">プロジェクトから特定の API を使用するには、アセンブリへの参照を追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="22ed2-119">To use certain APIs from your project, you must add references to their assemblies.</span></span> <span data-ttu-id="22ed2-120">参照は、実装アセンブリに直接追加するか、参照アセンブリに追加できます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-120">You can add references either to implementation assemblies directly or to reference assemblies.</span></span> <span data-ttu-id="22ed2-121">参照アセンブリは、使用できる場合は常に使用することを強くお勧めします。これにより、ターゲット バージョンでサポートされ、API デザイナーから使用できるように意図された (言い換えると、実装の詳細に依存しない) API メンバーのみを確実に使用できるためです。</span><span class="sxs-lookup"><span data-stu-id="22ed2-121">We strongly recommend that you use reference assemblies whenever they are available, because doing so ensures that you are using only API members that are supported in the target version and are meant to be used by API designers (in other words, not taking a dependency on implementation details).</span></span>

<span data-ttu-id="22ed2-122">.NET Framework ライブラリの参照アセンブリは、ターゲット パックと共に配布されます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-122">Reference assemblies for the .NET Framework libraries are distributed with targeting packs.</span></span> <span data-ttu-id="22ed2-123">これらを入手するには、スタンドアロン インストーラーをダウンロードするか、Visual Studio インストーラーでコンポーネントを選択します。</span><span class="sxs-lookup"><span data-stu-id="22ed2-123">You can obtain them by downloading a standalone installer or by selecting a component in Visual Studio installer.</span></span> <span data-ttu-id="22ed2-124">詳細については、「[開発者向けの .NET Framework のインストール](../../framework/install/guide-for-developers.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="22ed2-124">For more information, see [Install the .NET Framework for developers](../../framework/install/guide-for-developers.md).</span></span> <span data-ttu-id="22ed2-125">.NET Core と .NET Standard の場合、参照アセンブリは必要に応じて (NuGet 経由で) 自動的にダウンロードされ、参照されます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-125">For .NET Core and .NET Standard, reference assemblies are automatically downloaded as necessary (via NuGet) and referenced.</span></span> <span data-ttu-id="22ed2-126">.NET Core 3.0 以降では、コア フレームワーク用の参照アセンブリが [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) パッケージに含まれています (3.0 より前のバージョンでは、代わりに [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) パッケージが使用されます)。</span><span class="sxs-lookup"><span data-stu-id="22ed2-126">For .NET Core 3.0 and higher, the reference assemblies for the core framework are in the [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) package (the [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) package is used instead for versions before 3.0).</span></span> <span data-ttu-id="22ed2-127">詳細については、.NET Core ガイドの「[パッケージ、メタパッケージ、フレームワーク](../../core/packages.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="22ed2-127">For more information, see [Packages, metapackages and frameworks](../../core/packages.md) in the .NET Core Guide.</span></span>

<span data-ttu-id="22ed2-128">Visual Studio で **[参照の追加]** ダイアログを使用して .NET Framework アセンブリへの参照を追加する場合、リストからアセンブリを選択すると、Visual Studio ではプロジェクトで選択されたターゲット フレームワーク バージョンに対応する参照アセンブリが自動的に検索されます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-128">When you add references to .NET Framework assemblies in Visual Studio using the **Add reference** dialog, you select an assembly from the list, and Visual Studio automatically finds reference assemblies that correspond to the target framework version selected in your project.</span></span> <span data-ttu-id="22ed2-129">[[参照]](/visualstudio/msbuild/common-msbuild-project-items#reference) プロジェクト項目を使用して MSBuild プロジェクトに参照を直接追加する場合も同様です。完全なファイルのパスではなく、アセンブリ名のみを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="22ed2-129">The same applies to adding references directly into MSBuild project using the  [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference) project item: you only need to specify the assembly name, not the full file path.</span></span> <span data-ttu-id="22ed2-130">`-reference` コンパイラ オプション ([C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) および [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) を使用するか、Roslyn API の <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> メソッドを使用して、コマンド ラインでこれらのアセンブリに参照を追加する場合、正しいターゲット プラットフォーム バージョンの参照アセンブリ ファイルを手動で指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="22ed2-130">When you add references to these assemblies in the command line by using the `-reference` compiler option ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) and in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) or by using the <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> method in the Roslyn API, you must manually specify reference assembly files for the correct target platform version.</span></span> <span data-ttu-id="22ed2-131">.NET Framework 参照アセンブリ ファイルは、 *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* ディレクトリにあります。</span><span class="sxs-lookup"><span data-stu-id="22ed2-131">.NET Framework reference assembly files are located in the *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* directory.</span></span> <span data-ttu-id="22ed2-132">.NET Core の場合、`PreserveCompilationContext` プロジェクト プロパティを `true` に設定することにより、ターゲット プラットフォームの参照アセンブリを出力ディレクトリの *publish/refs* サブディレクトリにコピーするように発行操作を強制できます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-132">For .NET Core, you can force publish operation to copy reference assemblies for your target platform into the *publish/refs* subdirectory of your output directory by setting the `PreserveCompilationContext` project property to `true`.</span></span> <span data-ttu-id="22ed2-133">次に、これらの参照アセンブリ ファイルをコンパイラに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-133">Then you can pass these reference assembly files to the compiler.</span></span> <span data-ttu-id="22ed2-134">[Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) パッケージから `DependencyContext` を使用すると、パスを特定するために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-134">Using `DependencyContext` from [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) package can help locate their paths.</span></span>

<span data-ttu-id="22ed2-135">実装が含まれていないため、参照アセンブリを実行用に読み込むことはできません。これを行おうとすると、<xref:System.BadImageFormatException?displayProperty=nameWithType> の結果になります。</span><span class="sxs-lookup"><span data-stu-id="22ed2-135">Because they contain no implementation, reference assemblies cannot be loaded for execution; trying to do so results in a <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="22ed2-136">ただし、内容を調べる必要がある場合は、(<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> を使用して) リフレクションのみのコンテキスト メソッドに読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-136">However, they still can be loaded into the reflection-only context (using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>) method, if you need to examine their contents.</span></span>

## <a name="generating-reference-assemblies"></a><span data-ttu-id="22ed2-137">参照アセンブリの生成</span><span class="sxs-lookup"><span data-stu-id="22ed2-137">Generating reference assemblies</span></span>

<span data-ttu-id="22ed2-138">ライブラリの参照アセンブリを生成することは、ライブラリ コンシューマーが多数の異なるバージョンのライブラリに対してプログラムをビルドする必要がある場合 (つまり、独自のプロジェクトに前述の .NET Framework Targeting Pack と同様の機能を実装する必要がある場合) に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-138">Generating reference assemblies for your libraries can be useful when your library consumers often need to build their programs against many different versions of the library (that is, when you need to implement a feature similar to .NET Framework Targeting Packs mentioned above for your own project).</span></span> <span data-ttu-id="22ed2-139">これらのすべてのバージョンに対する実装アセンブリの配布は、サイズが大きいために現実的ではない場合があります。</span><span class="sxs-lookup"><span data-stu-id="22ed2-139">Distributing implementation assemblies for all these versions might be impractical due to their large size.</span></span> <span data-ttu-id="22ed2-140">参照アセンブリのサイズは小さいため、ライブラリの SDK の一部として配布すると、ダウンロード サイズが減り、ディスク領域が節約されます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-140">Reference assemblies are smaller in size, so distributing them as a part of your library's SDK reduces download size and saves disk space.</span></span>

<span data-ttu-id="22ed2-141">また、IDE とビルド ツールでは、参照アセンブリを利用すると、複数のクラス ライブラリで構成される大規模なソリューションの場合にビルド時間を短縮することもできます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-141">IDEs and build tools also can take advantage of reference assemblies to reduce build times in case of large solutions consisting of multiple class libraries.</span></span> <span data-ttu-id="22ed2-142">通常、インクリメンタル ビルドのシナリオでは、プロジェクトは、依存するアセンブリを含め、入力ファイルが変更されるとリビルドされます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-142">Usually, in incremental build scenarios a project is rebuilt when any of its input files are changed, including the assemblies it depends on.</span></span> <span data-ttu-id="22ed2-143">実装アセンブリは、プログラマーが任意のメンバーの実装を変更するたびに変わります。</span><span class="sxs-lookup"><span data-stu-id="22ed2-143">The implementation assembly changes whenever the programmer changes the implementation of any member.</span></span> <span data-ttu-id="22ed2-144">参照アセンブリは、パブリック API が影響を受ける場合にのみ変更されます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-144">The reference assembly only changes when its public API is affected.</span></span> <span data-ttu-id="22ed2-145">したがって、参照アセンブリを実装アセンブリではなく入力ファイルとして使用すると、場合によっては、依存プロジェクトのビルドがスキップされることがあります。</span><span class="sxs-lookup"><span data-stu-id="22ed2-145">Therefore, using the reference assembly as an input file instead of the implementation assembly allows to skip the build of the dependent project in some cases.</span></span> 

<span data-ttu-id="22ed2-146">参照アセンブリは次のように生成できます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-146">You can generate reference assemblies:</span></span>

- <span data-ttu-id="22ed2-147">MSBuild プロジェクトでは、[`ProduceReferenceAssembly` プロジェクト プロパティ](/visualstudio/msbuild/common-msbuild-project-properties)を使用します。</span><span class="sxs-lookup"><span data-stu-id="22ed2-147">In an MSBuild project, by using the [`ProduceReferenceAssembly` project property](/visualstudio/msbuild/common-msbuild-project-properties).</span></span>
- <span data-ttu-id="22ed2-148">コマンド ラインからプログラムをコンパイルする場合は、`-refonly` ([C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md)、[Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md)) または `-refout` ([C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md)、[Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) コンパイラ オプションを指定します。</span><span class="sxs-lookup"><span data-stu-id="22ed2-148">When compiling program from command line, by specifiying `-refonly` ([in C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md), [in Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) or `-refout` ([in C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md), [in Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) compiler options.</span></span>
- <span data-ttu-id="22ed2-149">Roslyn API を使用する場合は、<xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> メソッドに渡されるオブジェクトで <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> を `true` に、<xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> を `false` に設定します。</span><span class="sxs-lookup"><span data-stu-id="22ed2-149">When using the Roslyn API, by setting <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> to `true` and <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> to `false` in an object passed to the <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="22ed2-150">NuGet パッケージと共に参照アセンブリを配布する場合は、実装アセンブリに使用される *lib\\* サブディレクトリではなく、パッケージ ディレクトリ以下の *ref\\* サブディレクトリに含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="22ed2-150">If you want to distribute reference assemblies with NuGet packages, you must include them in the *ref\\* subdirectory under the package directory instead of in the *lib\\* subdirectory used for implementation assemblies.</span></span>

## <a name="reference-assemblies-structure"></a><span data-ttu-id="22ed2-151">参照アセンブリの構造</span><span class="sxs-lookup"><span data-stu-id="22ed2-151">Reference assemblies structure</span></span>

<span data-ttu-id="22ed2-152">参照アセンブリは、"*メタデータのみのアセンブリ*" という関連する概念を拡張したものです。</span><span class="sxs-lookup"><span data-stu-id="22ed2-152">Reference assemblies are an expansion of the related concept, *metadata-only assemblies*.</span></span> <span data-ttu-id="22ed2-153">メタデータのみアセンブリには、1 つの `throw null` 本体で置き換えられたメソッド本体がありますが、匿名型を除くすべてのメンバーが含まれます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-153">Metadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types.</span></span> <span data-ttu-id="22ed2-154">(本体なしではなく) `throw null` 本体を使用する理由は、PEVerify を実行して渡せるようにするためです (そのためにメタデータの完全性を検証します)。</span><span class="sxs-lookup"><span data-stu-id="22ed2-154">The reason for using `throw null` bodies (as opposed to no bodies) is so that PEVerify can run and pass (thus validating the completeness of the metadata).</span></span>

<span data-ttu-id="22ed2-155">参照アセンブリは、メタデータのみアセンブリからさらにメタデータ (プライベート メンバー) を削除します。</span><span class="sxs-lookup"><span data-stu-id="22ed2-155">Reference assemblies further remove metadata (private members) from metadata-only assemblies:</span></span>

- <span data-ttu-id="22ed2-156">参照アセンブリには、API サーフェスでそれが必要とする参照のみがあります。</span><span class="sxs-lookup"><span data-stu-id="22ed2-156">A reference assembly only has references for what it needs in the API surface.</span></span> <span data-ttu-id="22ed2-157">実際のアセンブリには、特定の実装に関連するその他の参照がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="22ed2-157">The real assembly may have additional references related to specific implementations.</span></span> <span data-ttu-id="22ed2-158">たとえば、`class C { private void M() { dynamic d = 1; ... } }` の参照アセンブリは、`dynamic` に必要などの型も参照しません。</span><span class="sxs-lookup"><span data-stu-id="22ed2-158">For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` does not reference any types required for `dynamic`.</span></span>
- <span data-ttu-id="22ed2-159">プライベート関数のメンバー (メソッド、プロパティ、およびイベント) は、それらの削除がコンパイルに著しい影響を与えない場合に削除されます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-159">Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation.</span></span> <span data-ttu-id="22ed2-160">[InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) 属性がない場合は、内部関数メンバーも削除されます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-160">If there are no [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) attributes, internal function members are also removed.</span></span>

<span data-ttu-id="22ed2-161">参照アセンブリ内のメタデータでは、引き続き次の情報が保持されます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-161">The metadata in reference assemblies continues to retain information about the following:</span></span>

- <span data-ttu-id="22ed2-162">プライベート型と入れ子にされた型を含むすべての型。</span><span class="sxs-lookup"><span data-stu-id="22ed2-162">All types, including private and nested types.</span></span>
- <span data-ttu-id="22ed2-163">すべての属性 (内部的なものも含む)。</span><span class="sxs-lookup"><span data-stu-id="22ed2-163">All attributes, even internal ones.</span></span>
- <span data-ttu-id="22ed2-164">すべての仮想メソッド。</span><span class="sxs-lookup"><span data-stu-id="22ed2-164">All virtual methods.</span></span>
- <span data-ttu-id="22ed2-165">明示的なインターフェイスの実装。</span><span class="sxs-lookup"><span data-stu-id="22ed2-165">Explicit interface implementations.</span></span> 
- <span data-ttu-id="22ed2-166">プロパティとイベントは、アクセサーが仮想であるため、明示的に実装されます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-166">Explicitly implemented properties and events, because their accessors are virtual.</span></span>
- <span data-ttu-id="22ed2-167">構造体のすべてのフィールド。</span><span class="sxs-lookup"><span data-stu-id="22ed2-167">All fields of structures.</span></span> 

<span data-ttu-id="22ed2-168">参照アセンブリには、アセンブリレベルの [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) 属性が含まれます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-168">Reference assemblies include an assembly-level [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) attribute.</span></span> <span data-ttu-id="22ed2-169">この属性は、ソースで指定できます。指定すると、コンパイラではこれを合成する必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="22ed2-169">This attribute may be specified in source; then the compiler won't need to synthesize it.</span></span> <span data-ttu-id="22ed2-170">この属性により、ランタイムで実行のための参照アセンブリの読み込みが拒否されます (ただし、リフレクションのみモードでは読み込むことができます)。</span><span class="sxs-lookup"><span data-stu-id="22ed2-170">Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can still be loaded in reflection-only mode).</span></span>

<span data-ttu-id="22ed2-171">正確な参照アセンブリ構造の詳細は、コンパイラのバージョンによって異なります。</span><span class="sxs-lookup"><span data-stu-id="22ed2-171">Exact reference assembly structure details depend on the compiler version.</span></span> <span data-ttu-id="22ed2-172">新しいバージョンでは、パブリック API のサーフェスに影響がないと判断された場合、より多くのメタデータを除外することを選択できます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-172">Newer versions may choose to exclude more metadata if it is determined as not affecting the public API surface.</span></span>

> [!NOTE]
> <span data-ttu-id="22ed2-173">このセクションの情報は、C# バージョン 7.1 または Visual Basic バージョン 15.3 以降の Roslyn コンパイラによって生成された参照アセンブリにのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-173">Information in this section is applicable only to reference assemblies generated by Roslyn compilers starting from C# version 7.1 or Visual Basic version 15.3.</span></span> <span data-ttu-id="22ed2-174">.NET Framework および .NET Core ライブラリの参照アセンブリの構造は、参照アセンブリを生成する独自のメカニズムを使用するため、詳細が多少異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="22ed2-174">The structure of reference assemblies for .NET Framework and .NET Core libraries can differ in some details, because they use their own mechanism of generating reference assemblies.</span></span> <span data-ttu-id="22ed2-175">たとえば、`throw null` の本体ではなく、メソッドの本体が完全に空の場合があります。</span><span class="sxs-lookup"><span data-stu-id="22ed2-175">For example, they might have totally empty method bodies instead of the `throw null` body.</span></span> <span data-ttu-id="22ed2-176">ただし、一般的な原則は引き続き適用されます。つまり、使用可能なメソッド実装は含まれず、パブリック API の観点から目に見える影響があるメンバーのメタデータのみが含まれます。</span><span class="sxs-lookup"><span data-stu-id="22ed2-176">But the general principle still applies: they don't have usable method implementations and contain metadata only for members that have an observable impact from a public API perspective.</span></span>

## <a name="see-also"></a><span data-ttu-id="22ed2-177">関連項目</span><span class="sxs-lookup"><span data-stu-id="22ed2-177">See also</span></span>

- [<span data-ttu-id="22ed2-178">.NET のアセンブリ</span><span class="sxs-lookup"><span data-stu-id="22ed2-178">Assemblies in .NET</span></span>](index.md)
- [<span data-ttu-id="22ed2-179">アセンブリを使用したプログラム</span><span class="sxs-lookup"><span data-stu-id="22ed2-179">Program with assemblies</span></span>](program.md)
- [<span data-ttu-id="22ed2-180">フレームワーク対象設定機能の概要</span><span class="sxs-lookup"><span data-stu-id="22ed2-180">Framework targeting overview</span></span>](/visualstudio/ide/visual-studio-multi-targeting-overview)
- [<span data-ttu-id="22ed2-181">方法: 参照マネージャーを使用して参照を追加または削除する</span><span class="sxs-lookup"><span data-stu-id="22ed2-181">How to: Add or remove references by using the Reference Manager</span></span>](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager)
