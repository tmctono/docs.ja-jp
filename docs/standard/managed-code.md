---
title: マネージド コードとは
description: ランタイムによって管理されるコードであるマネージド コードが共通言語ランタイム (CLR) によってどのように管理されるかを説明します。
ms.date: 06/20/2016
ms.technology: dotnet-standard
ms.assetid: 20bb7ea8-192e-4a96-8ef3-e10e1950fd3d
ms.openlocfilehash: 9133859bd9c999e076effcf0d4d631c59db02f33
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/15/2020
ms.locfileid: "61910118"
---
# <a name="what-is-managed-code"></a><span data-ttu-id="eea20-103">"マネージド コード" とは</span><span class="sxs-lookup"><span data-stu-id="eea20-103">What is "managed code"?</span></span>

<span data-ttu-id="eea20-104">.NET Framework を使用していると、よく "マネージド コード" という用語を目にすることがあります。</span><span class="sxs-lookup"><span data-stu-id="eea20-104">When working with .NET Framework, you will often encounter the term "managed code".</span></span> <span data-ttu-id="eea20-105">このドキュメントでは、この用語の意味とそれに関する追加の情報について説明します。</span><span class="sxs-lookup"><span data-stu-id="eea20-105">This document will explain what this term means and additional information around it.</span></span>

<span data-ttu-id="eea20-106">ごく簡単に言うと、マネージド コードとは、その実行がランタイムによって管理されるコードです。</span><span class="sxs-lookup"><span data-stu-id="eea20-106">To put it very simply, managed code is just that: code whose execution is managed by a runtime.</span></span> <span data-ttu-id="eea20-107">この場合、問題のランタイムは、実装 (**Mono** または .NET Framework または .NET Core) に関係なく、[共通言語ランタイム](https://www.mono-project.com/)または CLR と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="eea20-107">In this case, the runtime in question is called the **Common Language Runtime** or CLR, regardless of the implementation ([Mono](https://www.mono-project.com/) or .NET Framework or .NET Core).</span></span> <span data-ttu-id="eea20-108">CLR は、マネージド コードの取得、そのマシン コードへのコンパイルと実行を担当します。</span><span class="sxs-lookup"><span data-stu-id="eea20-108">CLR is in charge of taking the managed code, compiling it into machine code and then executing it.</span></span> <span data-ttu-id="eea20-109">それに加えて、ランタイムは、自動メモリ管理、セキュリティ境界、タイプ セーフなどのいくつかの重要なサービスも提供します。</span><span class="sxs-lookup"><span data-stu-id="eea20-109">On top of that, runtime provides several important services such as automatic memory management, security boundaries, type safety etc.</span></span>

<span data-ttu-id="eea20-110">これを、"アンマネージ コード" とも呼ばれる C/C++ プログラムを実行する方法と比較します。</span><span class="sxs-lookup"><span data-stu-id="eea20-110">Contrast this to the way you would run a C/C++ program, also called "unmanaged code".</span></span> <span data-ttu-id="eea20-111">アンマネージ環境では、プログラマがほとんどすべてのことを担当します。</span><span class="sxs-lookup"><span data-stu-id="eea20-111">In the unmanaged world, the programmer is in charge of pretty much everything.</span></span> <span data-ttu-id="eea20-112">実際のプログラムは、基本的に、オペレーティング システム (OS) がメモリに読み込み、起動するバイナリです。</span><span class="sxs-lookup"><span data-stu-id="eea20-112">The actual program is, essentially, a binary that the operating system (OS) loads into memory and starts.</span></span> <span data-ttu-id="eea20-113">メモリ管理からセキュリティの考慮事項まで、他のすべてのことをプログラマが担当します。</span><span class="sxs-lookup"><span data-stu-id="eea20-113">Everything else, from memory management to security considerations are a burden of the programmer.</span></span>

<span data-ttu-id="eea20-114">マネージド コードは C#、Visual Basic、F# など、.NET 上で実行可能な高水準言語のいずれかで記述されます。</span><span class="sxs-lookup"><span data-stu-id="eea20-114">Managed code is written in one of the high-level languages that can be run on top of .NET, such as C#, Visual Basic, F# and others.</span></span> <span data-ttu-id="eea20-115">それらの言語で書かれたコードをそれぞれのコンパイラでコンパイルした場合、マシン コードは得られません。</span><span class="sxs-lookup"><span data-stu-id="eea20-115">When you compile code written in those languages with their respective compiler, you don’t get machine code.</span></span> <span data-ttu-id="eea20-116">**中間言語**コードが得られ、それをランタイムがコンパイルして実行します。</span><span class="sxs-lookup"><span data-stu-id="eea20-116">You get **Intermediate Language** code which the runtime then compiles and executes.</span></span> <span data-ttu-id="eea20-117">C++ は、Windows で実行するネイティブなアンマネージ バイナリも生成できるため、この規則の 1 つの例外です。</span><span class="sxs-lookup"><span data-stu-id="eea20-117">C++ is the one exception to this rule, as it can also produce native, unmanaged binaries that run on Windows.</span></span>

## <a name="intermediate-language--execution"></a><span data-ttu-id="eea20-118">中間言語と実行</span><span class="sxs-lookup"><span data-stu-id="eea20-118">Intermediate Language & execution</span></span>

<span data-ttu-id="eea20-119">"中間言語" (または略して IL) とは</span><span class="sxs-lookup"><span data-stu-id="eea20-119">What is "Intermediate Language" (or IL for short)?</span></span> <span data-ttu-id="eea20-120">それは、高水準 .NET 言語で記述されたコードのコンパイルの成果物です。</span><span class="sxs-lookup"><span data-stu-id="eea20-120">It is a product of compilation of code written in high-level .NET languages.</span></span> <span data-ttu-id="eea20-121">これらの言語のいずれかで記述されたコードをコンパイルすると、IL で構成されたバイナリが得られます。</span><span class="sxs-lookup"><span data-stu-id="eea20-121">Once you compile your code written in one of these languages, you will get a binary that is made out of IL.</span></span> <span data-ttu-id="eea20-122">IL はランタイムで実行される特定の言語に依存しないことに注意してください。それについて個別の仕様もあるため、参照することができます。</span><span class="sxs-lookup"><span data-stu-id="eea20-122">It is important to note that the IL is independent from any specific language that runs on top of the runtime; there is even a separate specification for it that you can read if you’re so inclined.</span></span>

<span data-ttu-id="eea20-123">高水準コードから IL を生成したら、ほとんどの場合、それを実行したいと考えるでしょう。</span><span class="sxs-lookup"><span data-stu-id="eea20-123">Once you produce IL from your high-level code, you will most likely want to run it.</span></span> <span data-ttu-id="eea20-124">ここで、CLR が引き継ぎ、コードを IL から、CPU で実際に実行できるマシン コードに **Just-In-Time** コンパイル、つまり **JIT 処理**するプロセスを開始します。</span><span class="sxs-lookup"><span data-stu-id="eea20-124">This is where the CLR takes over and starts the process of **Just-In-Time** compiling, or **JIT-ing** your code from IL to machine code that can actually be run on a CPU.</span></span> <span data-ttu-id="eea20-125">このように、CLR ではコードが実行することを正確に把握しているため、それを効率的に_管理_できます。</span><span class="sxs-lookup"><span data-stu-id="eea20-125">In this way, the CLR knows exactly what your code is doing and can effectively _manage_ it.</span></span>

<span data-ttu-id="eea20-126">中間言語は、共通中間言語 (CIL) または Microsoft Intermediate Language (MSIL) と呼ばれることもあります。</span><span class="sxs-lookup"><span data-stu-id="eea20-126">Intermediate Language is sometimes also called Common Intermediate Language (CIL) or Microsoft Intermediate Language (MSIL).</span></span>

## <a name="unmanaged-code-interoperability"></a><span data-ttu-id="eea20-127">アンマネージ コードの相互運用性</span><span class="sxs-lookup"><span data-stu-id="eea20-127">Unmanaged code interoperability</span></span>

<span data-ttu-id="eea20-128">もちろん、CLR は、マネージド環境とアンマネージド環境間の境界を越えることができ、[基本クラス ライブラリ](framework-libraries.md)にも、それを行う多くのコードがあります。</span><span class="sxs-lookup"><span data-stu-id="eea20-128">Of course, the CLR allows passing the boundaries between managed and unmanaged world, and there is a lot of code that does that, even in the [Base Class Libraries](framework-libraries.md).</span></span> <span data-ttu-id="eea20-129">これは**相互運用性 (interoperability)** または略して **相互運用 (interop)** と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="eea20-129">This is called **interoperability** or just **interop** for short.</span></span> <span data-ttu-id="eea20-130">これらのプロビジョニングにより、たとえばアンマネージ ライブラリをラップし、それを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="eea20-130">These provisions would allow you to, for example, wrap up an unmanaged library and call into it.</span></span> <span data-ttu-id="eea20-131">ただし、これを実行すると、コードがランタイムの境界を越えたときに、実行の実際の管理が再びアンマネージ コードの担当になるため、同じ制限が課せられることになります。</span><span class="sxs-lookup"><span data-stu-id="eea20-131">However, it is important to note that once you do this, when the code passes the boundaries of the runtime, the actual management of the execution is again in the hand of unmanaged code, and thus falls under the same restrictions.</span></span>

<span data-ttu-id="eea20-132">これと同様に、C# は、実行が CLR によって管理されないコードの一部を指定する**アンセーフ コンテキスト**として知られる機能を使用して、コード内の直接のポインターなど、アンマネージド コンストラクトを使用できる 1 つの言語です。</span><span class="sxs-lookup"><span data-stu-id="eea20-132">Similar to this, C# is one language that allows you to use unmanaged constructs such as pointers directly in code by utilizing what is known as **unsafe context** which designates a piece of code for which the execution is not managed by the CLR.</span></span>

## <a name="more-resources"></a><span data-ttu-id="eea20-133">その他のリソース</span><span class="sxs-lookup"><span data-stu-id="eea20-133">More resources</span></span>

* [<span data-ttu-id="eea20-134">.NET Framework の概要</span><span class="sxs-lookup"><span data-stu-id="eea20-134">Overview of the .NET Framework</span></span>](../framework/get-started/overview.md)
* [<span data-ttu-id="eea20-135">アンセーフ コードとポインター</span><span class="sxs-lookup"><span data-stu-id="eea20-135">Unsafe Code and Pointers</span></span>](../../docs/csharp/programming-guide/unsafe-code-pointers/index.md)
* [<span data-ttu-id="eea20-136">ネイティブ相互運用性</span><span class="sxs-lookup"><span data-stu-id="eea20-136">Native interoperability</span></span>](./native-interop/index.md)
