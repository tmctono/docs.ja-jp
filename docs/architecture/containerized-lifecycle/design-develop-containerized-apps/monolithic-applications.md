---
title: モノリシック アプリケーション
description: モノリシック アプリケーションのコンテナー化の中心概念を理解します。
ms.date: 02/15/2019
ms.openlocfilehash: a67015452fb1245ef4b24a8dc50a4b33d3f9f32e
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/30/2019
ms.locfileid: "68673599"
---
# <a name="monolithic-applications"></a><span data-ttu-id="d9d5c-103">モノリシック アプリケーション</span><span class="sxs-lookup"><span data-stu-id="d9d5c-103">Monolithic applications</span></span>

<span data-ttu-id="d9d5c-104">このシナリオでは、1 つのモノリシックな Web アプリケーションまたはサービスを構築し、それをコンテナーとして展開します。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-104">In this scenario, you're building a single and monolithic web application or service and deploying it as a container.</span></span> <span data-ttu-id="d9d5c-105">アプリケーション内の構造はモノリシックではなく、複数のライブラリ、コンポーネント、さらにはレイヤー (アプリケーション レイヤー、ドメイン レイヤー、データアクセス レイヤーなど) を含む場合があります。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-105">Within the application, the structure might not be monolithic; it might comprise several libraries, components, or even layers (application layer, domain layer, data access layer, etc.).</span></span> <span data-ttu-id="d9d5c-106">これは外部的には、単一のプロセス、単一の Web アプリケーション、または単一のサービスなど、単一のコンテナーです。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-106">Externally, it's a single container, like a single process, single web application, or single service.</span></span>

<span data-ttu-id="d9d5c-107">このモデルを管理するには、アプリケーションを表す単一のコンテナーを展開します。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-107">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="d9d5c-108">これを拡大するには、ロード バランサーを前面に配置してコピーをいくつか追加します。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-108">To scale it, just add a few more copies with a load balancer in front.</span></span> <span data-ttu-id="d9d5c-109">単一のコンテナーまたは仮想マシン (VM) の単一の展開を管理すればよいので、単純です。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-109">The simplicity comes from managing a single deployment in a single container or virtual machine (VM).</span></span>

<span data-ttu-id="d9d5c-110">コンテナーは 1 つのことのみを、1 つのプロセスで実行するというコンテナーの原則に従えば、モノリシックのパターンとは矛盾します。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-110">Following the principal that a container does one thing only, and does it in one process, the monolithic pattern is in conflict.</span></span> <span data-ttu-id="d9d5c-111">図 4-1 に示すように、各コンテナーには複数のコンポーネント/ライブラリ、または内部レイヤーを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-111">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 4-1.</span></span>

![モノシリック アプリでは、その機能のすべてまたはほとんどが、1 つのプロセスまたはコンテナーにあり、内部レイヤーやライブラリにコンポーネント化されています。](./media/image1.png)

<span data-ttu-id="d9d5c-113">**図 4-1**</span><span class="sxs-lookup"><span data-stu-id="d9d5c-113">**Figure 4-1.**</span></span> <span data-ttu-id="d9d5c-114">モノシリック アプリケーションのアーキテクチャ例</span><span class="sxs-lookup"><span data-stu-id="d9d5c-114">An example of monolithic application architecture</span></span>

<span data-ttu-id="d9d5c-115">このアプローチの欠点は、アプリケーションが大きくなり、スケーリングする必要が出てきた場合に明らかになります。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-115">The downside to this approach comes if or when the application grows, requiring it to scale.</span></span> <span data-ttu-id="d9d5c-116">アプリケーション全体がスケーリングすれば、実際には問題ではありません。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-116">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="d9d5c-117">しかし、ほとんどの場合、スケーリングの必要性があるネックの部分はアプリケーションの一部であり、他のコンポーネントはそれほど使用されていません。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-117">However, in most cases, a few parts of the application are the choke points that require scaling, whereas other components are used less.</span></span>

<span data-ttu-id="d9d5c-118">一般的な eコマースを例にとると、スケーリングする必要が生じるのは多くの場合、製品情報のコンポーネントです。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-118">Using the typical e-commerce example, what you likely need is to scale the product information component.</span></span> <span data-ttu-id="d9d5c-119">製品を購入するユーザーよりも多くのユーザーが製品を参照します。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-119">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="d9d5c-120">より多くの顧客が、支払いパイプラインではなくバスケットを使用します。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-120">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="d9d5c-121">コメントを追加したり、購入履歴を表示したりする顧客はそれほどいません。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-121">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="d9d5c-122">また、単一のリージョンで、コンテンツとマーケティング キャンペーンを管理する必要がある従業員数はおそらくほんの一握りです。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-122">And you likely have only a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="d9d5c-123">モノリシック デザインをスケーリングすると、コード全体が複数回展開されます。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-123">By scaling the monolithic design, all of the code is deployed multiple times.</span></span>

<span data-ttu-id="d9d5c-124">"すべてをスケーリングする" 問題に加えて、1 つのコンポーネントを変更した場合、アプリケーション全体を完全に再テストし、すべてのインスタンスを完全に再展開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-124">In addition to the "scale-everything" problem, changes to a single component require complete retesting of the entire application as well as a complete redeployment of all the instances.</span></span>

<span data-ttu-id="d9d5c-125">モノリシック アプローチは一般的であり、多くの組織がこのアーキテクチャ メソッドを使用して開発を行っています。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-125">The monolithic approach is common, and many organizations are developing with this architectural method.</span></span> <span data-ttu-id="d9d5c-126">多くのユーザーは十分な結果を得ていますが、他のユーザーは限界を感じています。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-126">Many enjoy good enough results, whereas others encounter limits.</span></span> <span data-ttu-id="d9d5c-127">多くの組織は、このモデルでアプリケーションを設計していました。これは、ツールとインフラストラクチャでは SOA の構築が非常に困難だったため、および、アプリケーションが大きくなるまでその必要性がわからなかったためです。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-127">Many designed their applications in this model because the tools and infrastructure were too difficult to build SOAs, and they didn't see the need—until the app grew.</span></span>

<span data-ttu-id="d9d5c-128">インフラストラクチャの観点から説明すると、図 4-2 に示すように、リソースの効率的な受け入れ可能な使用量の割合内で、各サーバーは同じホスト内で多数のアプリケーションを実行できます。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-128">From an infrastructure perspective, each server can run many applications within the same host and have an acceptable ratio of efficiency in your resources usage, as shown in Figure 4-2.</span></span>

![1 つのホストは、別のコンテナーで複数のアプリを実行できます。](./media/image2.png)

<span data-ttu-id="d9d5c-130">**図 4-2**</span><span class="sxs-lookup"><span data-stu-id="d9d5c-130">**Figure 4-2.**</span></span> <span data-ttu-id="d9d5c-131">複数のアプリ/コンテナーを実行しているホスト</span><span class="sxs-lookup"><span data-stu-id="d9d5c-131">A host running multiple apps/containers</span></span>

<span data-ttu-id="d9d5c-132">最後に、可用性の観点から考えた場合、モノリシック アプリケーションをデプロイする場合、全体をデプロイする必要があります。つまり、デプロイ期間中に、*停止および起動*する必要がある場合、すべての機能とすべてのユーザーが影響を受けます。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-132">Finally, from an availability perspective, monolithic applications must be deployed as a whole; that means that in case you must *stop and start*, all functionality and all users will be affected during the deployment window.</span></span> <span data-ttu-id="d9d5c-133">図 4-3 のとおり、特定の状況では、Azure とコンテナーの使用でこれらの状況を最小限に抑えることができ、アプリケーションをダウンさせる可能性を減らすことができます。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-133">In certain situations, the use of Azure and containers can minimize these situations and reduce the probability of downtime of your application, as you can see in Figure 4-3.</span></span>

<span data-ttu-id="d9d5c-134">Azure にモノリシック アプリケーションをデプロイするには、各インスタンスに専用の VM を使用します。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-134">You can deploy monolithic applications in Azure by using dedicated VMs for each instance.</span></span> <span data-ttu-id="d9d5c-135">[Azure Virtual Machine Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/) を使用すると、VM のスケーリングを簡単に行うことができます。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-135">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can scale the VMs easily.</span></span>

<span data-ttu-id="d9d5c-136">また [Azure App Service](https://azure.microsoft.com/services/app-service/) では、VM の管理を必要とせずに、モノリシック アプリケーションを実行し、インスタンスを簡単にスケーリングすることができます。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-136">You can also use [Azure App Services](https://azure.microsoft.com/services/app-service/) to run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="d9d5c-137">Azure App Services では、Docker コンテナーの単一インスタンスも実行できるため、デプロイが簡単になります。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-137">Azure App Services can run single instances of Docker containers, as well, simplifying the deployment.</span></span>

<span data-ttu-id="d9d5c-138">複数の VM を Docker のホストとしてデプロイして、VM ごとに任意の数のコンテナーを実行することができます。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-138">You can deploy multiple VMs as Docker hosts and run any number of containers per VM.</span></span> <span data-ttu-id="d9d5c-139">次に、図 4-3 に示すように、Azure Load Balancer を使用することにより、スケーリングを管理できます。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-139">Then, by using an Azure Load Balancer, as illustrated in the Figure 4-3, you can manage scaling.</span></span>

![モノリシック アプリは、アプリをコンテナーで実行するさまざまなホストにスケールアウトできます。](./media/image3.png)

<span data-ttu-id="d9d5c-141">**図 4-3**</span><span class="sxs-lookup"><span data-stu-id="d9d5c-141">**Figure 4-3**.</span></span> <span data-ttu-id="d9d5c-142">単一の Docker アプリケーション アプリ/コンテナーの複数のホストへのスケールアウト</span><span class="sxs-lookup"><span data-stu-id="d9d5c-142">Multiple hosts scaling-out a single Docker application apps/containers</span></span>

<span data-ttu-id="d9d5c-143">ホスト自体のデプロイを、従来のデプロイ手法を使用して管理できます。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-143">You can manage the deployment of the hosts themselves via traditional deployment techniques.</span></span>

<span data-ttu-id="d9d5c-144">`docker run` および `docker-compose up` などのコマンドを使用して、コマンドラインから Docker コンテナーを管理できます。また、継続的デリバリー (CD) パイプラインで自動化し、たとえば Azure DevOps Services から Docker ホストにデプロイすることもできます。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-144">You can manage Docker containers from the command line by using commands like `docker run` and `docker-compose up`, and you can also automate it in Continuous Delivery (CD) pipelines and deploy to Docker hosts from Azure DevOps Services, for instance.</span></span>

## <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="d9d5c-145">コンテナーとして展開するモノリシック アプリケーション</span><span class="sxs-lookup"><span data-stu-id="d9d5c-145">Monolithic application deployed as a container</span></span>

<span data-ttu-id="d9d5c-146">モノリシックの展開の管理にコンテナーを使用する利点があります。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-146">There are benefits to using containers to manage monolithic deployments.</span></span> <span data-ttu-id="d9d5c-147">コンテナーのインスタンスをスケーリングする処理は、追加の VM を展開するよりもはるかに高速で簡単です。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-147">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span>

<span data-ttu-id="d9d5c-148">更新プログラムを Docker イメージとして展開する方がはるかに高速で、ネットワークの効率が高くなります。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-148">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="d9d5c-149">通常、Docker コンテナーは数秒で起動するので、高速にロールアウトできます。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-149">Docker containers typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="d9d5c-150">Docker コンテナーの破棄は、`docker stop` コマンドの発行と同じくらい簡単で、通常は 1 秒未満で完了します。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-150">Tearing down a Docker container is as easy as invoking the `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="d9d5c-151">コンテナーは設計上、本質的に変更不可であるため、更新スクリプトが、ディスク上に残された特定の構成またはファイルを考慮しない場合があるため、VM の破損については心配する必要がありません。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-151">Because containers are inherently immutable, by design, you never need to worry about corrupted VMs because an update script forgot to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="d9d5c-152">モノリシック アプリケーションでは Docker の利点を得られますが、ここではその利点の一部のみに触れています。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-152">Although monolithic apps can benefit from Docker, we're touching on only the tips of the benefits.</span></span> <span data-ttu-id="d9d5c-153">コンテナー管理のそれよりも大きな利点は、コンテナー オーケストレーターを使用する展開によるものです。コンテナー オーケストレーターは、各コンテナー インスタンスのさまざまなインスタンスとライフサイクルを管理します。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-153">The larger benefits of managing containers come from deploying with container orchestrators that manage the various instances and life cycle of each container instance.</span></span> <span data-ttu-id="d9d5c-154">モノリシック アプリケーションを、スケーリング、開発、および展開を個別に実行できるサブシステムに分割することが、マイクロサービスの領域への入り口になります。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-154">Breaking up the monolithic application into subsystems that can be scaled, developed, and deployed individually is your entry point into the realm of microservices.</span></span>

<span data-ttu-id="d9d5c-155">コンテナーを使用してモノリシック アプリケーションを “リフト アンド シフト” する方法および、アプリケーションを最新化する方法については、Microsoft のこの追加のガイド「[Azure クラウドおよび Windows コンテナーで既存の .NET アプリケーションを最新化する](../../modernize-with-azure-containers/index.md)」を参照してください。これは、<https://aka.ms/LiftAndShiftWithContainersEbook> から PDF でダウンロードすることも可能です。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-155">To learn about how to “lift and shift” monolithic applications with containers and how you can modernize your applications, you can read this additional Microsoft guide, [Modernize existing .NET applications with Azure cloud and Windows Containers](../../modernize-with-azure-containers/index.md), that you can also download as PDF from <https://aka.ms/LiftAndShiftWithContainersEbook>.</span></span>

## <a name="publish-a-single-docker-container-app-to-azure-app-service"></a><span data-ttu-id="d9d5c-156">Azure App Service への 1 つの Docker コンテナー アプリの発行</span><span class="sxs-lookup"><span data-stu-id="d9d5c-156">Publish a single Docker container app to Azure App Service</span></span>

<span data-ttu-id="d9d5c-157">Azure にデプロイしたコンテナーを迅速に検証する場合でも、またはアプリが単なる単一のコンテナー アプリの場合でも、Azure App Service には、スケーラブルな単一のコンテナーベースのサービスを提供できる優れた方法があります。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-157">Either because you want to get a quick validation of a container deployed to Azure or because the app is simply a single-container app, Azure App Services provides a great way to provide scalable single-container services.</span></span>

<span data-ttu-id="d9d5c-158">Azure App Service は直感的に使用でき、起動してすぐに実行することができます。これは、コードを取得し Microsoft Visual Studio でビルドして Azure に直接デプロイするための Git との優れた統合が提供されているためです。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-158">Using Azure App Service is intuitive and you can get up and running quickly because it provides great Git integration to take your code, build it in Microsoft Visual Studio, and directly deploy it to Azure.</span></span> <span data-ttu-id="d9d5c-159">しかし、従来 (Docker を使用しない場合)、App Services でサポートされていないその他の機能、フレームワークまたは依存関係が必要であった場合、Azure チームがそれらの依存関係を App Service で更新するまで待つか、ユーザーがさらに制御でき、使用しているアプリケーションで必要なコンポーネントやフレームワークをインストールできる Service Fabric、Cloud Services、または単純な VM に切り替える必要がありました。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-159">But, traditionally (with no Docker), if you needed other capabilities, frameworks, or dependencies that aren't supported in App Services, you needed to wait for it until the Azure team updates those dependencies in App Service or switched to other services like Service Fabric, Cloud Services, or even plain VMs, for which you have further control and can install a required component or framework for your application.</span></span>

<span data-ttu-id="d9d5c-160">さて、図 4-4 に示すように、Visual Studio 2017 を使用する場合、Azure App Service のコンテナー サポートにより、アプリケーション環境に必要なものをすべて含めることができます。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-160">Now, as shown in Figure 4-4, when using Visual Studio 2017, container support in Azure App Service gives you the ability to include whatever you want in your app environment.</span></span> <span data-ttu-id="d9d5c-161">お使いのアプリに依存関係を追加した場合、それをコンテナー内で実行しているため、それらの依存関係を Dockerfile または Docker イメージに含めることができるようになります。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-161">If you added a dependency to your app, because you're running it in a container, you get the capability of including those dependencies in your Dockerfile or Docker image.</span></span>

![コンテナー レジストリのセレクターが強調表示された、Azure App Service に発行する Visual Studio ウィザードのビュー。](./media/image4.png)

<span data-ttu-id="d9d5c-163">**図 4-4**</span><span class="sxs-lookup"><span data-stu-id="d9d5c-163">**Figure 4-4**.</span></span> <span data-ttu-id="d9d5c-164">Visual Studio のアプリ/コンテナーから Azure App Service へのコンテナーの発行</span><span class="sxs-lookup"><span data-stu-id="d9d5c-164">Publishing a container to Azure App Service from Visual Studio apps/containers</span></span>

<span data-ttu-id="d9d5c-165">図 4-4 では、発行フローでイメージが Container Registry を介してプッシュされているのも示しています。これは、Azure Container Registry (Azure のデプロイの近くの、Azure Active Directory グループとアカウントによってセキュリティで保護されているレジストリ)、または Docker Hub やオンプレミス レジストリなどのその他の Docker レジストリにすることもできます。</span><span class="sxs-lookup"><span data-stu-id="d9d5c-165">Figure 4-4 also shows that the publish flow pushes an image through a Container Registry, which can be the Azure Container Registry (a registry near to your deployments in Azure and secured by Azure Active Directory groups and accounts) or any other Docker Registry like Docker Hub or on-premises registries.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="d9d5c-166">[前へ](common-container-design-principles.md)
>[次へ](state-and-data-in-docker-applications.md)</span><span class="sxs-lookup"><span data-stu-id="d9d5c-166">[Previous](common-container-design-principles.md)
[Next](state-and-data-in-docker-applications.md)</span></span>
