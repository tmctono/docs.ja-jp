---
title: DevOps コラボレーションの基盤としてのコンテナー
description: DevOps を効率化するコンテナーの重要な役割を理解します。
ms.date: 02/15/2019
ms.openlocfilehash: 8258f4331212d92376d64fef318adcdff492f61f
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/30/2019
ms.locfileid: "73094500"
---
# <a name="containers-as-the-foundation-for-devops-collaboration"></a><span data-ttu-id="014e4-103">DevOps コラボレーションの基盤としてのコンテナー</span><span class="sxs-lookup"><span data-stu-id="014e4-103">Containers as the foundation for DevOps collaboration</span></span>

<span data-ttu-id="014e4-104">コンテナーと Docker テクノロジの性質上、開発者は自分のソフトウェアや依存関係を IT 運用や運用環境と容易に共有できると同時に、"自分のコンピューターでは動作する" というよくある言い訳を排除できます。</span><span class="sxs-lookup"><span data-stu-id="014e4-104">By the very nature of the containers and Docker technology, developers can share their software and dependencies easily with IT operations and production environments while eliminating the typical "it works on my machine" excuse.</span></span> <span data-ttu-id="014e4-105">コンテナーを使用すれば、異なる環境間のアプリケーションの競合を解決できます。</span><span class="sxs-lookup"><span data-stu-id="014e4-105">Containers solve application conflicts between different environments.</span></span> <span data-ttu-id="014e4-106">間接的には、コンテナーと Docker により開発者と IT 運用担当はより密接に結びつけられ、両者は効果的なコラボレーションをより簡単に実現できます。</span><span class="sxs-lookup"><span data-stu-id="014e4-106">Indirectly, containers and Docker bring developers and IT operations closer together, making it easier for them to collaborate effectively.</span></span> <span data-ttu-id="014e4-107">コンテナー ワークフローを採用することで、多くの顧客に DevOps の継続性を提供できます。多くの顧客がこれを求めていましたが、以前はリリース パイプラインおよびビルド パイプライン用のより複雑な構成を介して実装する必要がありました。</span><span class="sxs-lookup"><span data-stu-id="014e4-107">Adopting the container workflow provides many customers with the DevOps continuity they've sought but previously had to implement via more complex configuration for release and build pipelines.</span></span> <span data-ttu-id="014e4-108">DevOps でのビルド/テスト/配置パイプラインはコンテナーにより簡素化されます。</span><span class="sxs-lookup"><span data-stu-id="014e4-108">Containers simplify the build/test/deploy pipelines in DevOps.</span></span>

![Docker アプリのライフ サイクルの所有権を示す図。](./media/containers-foundation-for-devops-collaboration/persona-workloads-docker-container-lifecycle.png)

<span data-ttu-id="014e4-110">**図 2-1**</span><span class="sxs-lookup"><span data-stu-id="014e4-110">**Figure 2-1.**</span></span> <span data-ttu-id="014e4-111">コンテナー化された Docker アプリケーションのライフサイクルでの "ペルソナ" あたりの主なワークロード</span><span class="sxs-lookup"><span data-stu-id="014e4-111">Main workloads per "personas" in the life cycle for containerized Docker applications</span></span>

<span data-ttu-id="014e4-112">Docker コンテナーでは、コンテナー内にあるもの (アプリケーションとサービス、ならびにフレームワークとコンポーネントに対する依存関係) と、サービスのコレクションで構成されたアプリケーションとしてコンテナーとサービスを一緒に動作させる方法を開発者が所有します。</span><span class="sxs-lookup"><span data-stu-id="014e4-112">With Docker containers, developers own what's within the container (application and service, and dependencies to frameworks and components) and how the containers and services behave together as an application composed by a collection of services.</span></span> <span data-ttu-id="014e4-113">複数のコンテナーの相互依存関係は、`docker-compose.yml` ファイル、または "*配置マニフェスト*" と呼べるものに定義されます。</span><span class="sxs-lookup"><span data-stu-id="014e4-113">The interdependencies of the multiple containers are defined in a `docker-compose.yml` file, or what could be called a *deployment manifest*.</span></span> <span data-ttu-id="014e4-114">一方で、IT 運用チーム (IT プロフェッショナルおよび IT 管理者) は運用環境の管理に集中することができます。それはインフラストラクチャ、スケーラビリティ、監視であり、最終的には、さまざまなコンテナーのコンテンツを把握する必要なく確実にアプリケーションからエンド ユーザーに正しく配信されるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="014e4-114">Meanwhile, IT operations teams (IT professionals and management) can focus on the management of production environments; infrastructure; scalability; monitoring; and, ultimately, ensuring that the applications are delivering properly for the end users, without having to know the contents of the various containers.</span></span> <span data-ttu-id="014e4-115">したがって、"コンテナー" という名前は、実世界の出荷用コンテナーとの類似性を思い出させるものです。</span><span class="sxs-lookup"><span data-stu-id="014e4-115">Hence, the name "container," recalling the analogy to real-world shipping containers.</span></span> <span data-ttu-id="014e4-116">要するに、コンテナーの内容物の所有者はコンテナーの出荷方法に関与する必要はなく、運送会社はその内容物について知ることなくまたは気にすることなくコンテナーを発送元から目的地に輸送します。</span><span class="sxs-lookup"><span data-stu-id="014e4-116">Thus, the owners of a container's content need not concern themselves with how the container will be shipped, and the shipping company transports a container from its point of origin to its destination without knowing or caring about the contents.</span></span> <span data-ttu-id="014e4-117">同様に、開発者は "転送" メカニズムに関与することなく、Docker コンテナー内でコンテンツを作成し所有することができます。</span><span class="sxs-lookup"><span data-stu-id="014e4-117">In a similar manner, developers can create and own the contents within a Docker container without the need to concern themselves with the "transport" mechanisms.</span></span>

<span data-ttu-id="014e4-118">図 2-1 の左側の柱では、開発者が Docker for Windows または Docker for Mac を使用して、Docker コンテナー内でローカルにコードを記述して実行します。</span><span class="sxs-lookup"><span data-stu-id="014e4-118">In the pillar on the left side of Figure 2-1, developers write and run code locally in Docker containers by using Docker for Windows or Mac.</span></span> <span data-ttu-id="014e4-119">開発者は、実行するベース オペレーティング システムと、コードを Docker イメージにビルドするためのビルド ステップを指定した Dockerfile 使用して、コードの操作環境を定義します。</span><span class="sxs-lookup"><span data-stu-id="014e4-119">They define the operating environment for the code by using a Dockerfile that specifies the base operating system to run as well as the build steps for building their code into a Docker image.</span></span> <span data-ttu-id="014e4-120">開発者は、前述の `docker-compose.yml` ファイル配置マニフェストを使用して、1 つまたは複数のイメージを相互運用する方法を定義します。</span><span class="sxs-lookup"><span data-stu-id="014e4-120">The developers define how one or more images will interoperate using the aforementioned `docker-compose.yml` file deployment manifest.</span></span> <span data-ttu-id="014e4-121">開発者は、ローカルでの開発が完了すると、そのアプリケーション コードと Docker 構成定ファイルを任意のコード レポジトリ (つまり、Git レポジトリ) にプッシュします。</span><span class="sxs-lookup"><span data-stu-id="014e4-121">As they complete their local development, they push their application code plus the Docker configuration files to the code repository of their choice (that is, Git repository).</span></span>

<span data-ttu-id="014e4-122">DevOps の柱では、コード リポジトリに提供された Dockerfile を使用してビルド - 継続的インテグレーション (CI) パイプラインが定義されます。</span><span class="sxs-lookup"><span data-stu-id="014e4-122">The DevOps pillar defines the build–Continuous Integration (CI) pipelines using the Dockerfile provided in the code repository.</span></span> <span data-ttu-id="014e4-123">CI システムでは、選択した Docker レジストリからベース コンテナー イメージが取得され、アプリケーションに合わせてカスタム Docker イメージが作成されます。</span><span class="sxs-lookup"><span data-stu-id="014e4-123">The CI system pulls the base container images from the selected Docker registry and builds the custom Docker images for the application.</span></span> <span data-ttu-id="014e4-124">次に、そのイメージは検証され、複数の環境への配置を行うために使用する Docker レジストリにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="014e4-124">The images then are validated and pushed to the Docker registry used for the deployments to multiple environments.</span></span>

<span data-ttu-id="014e4-125">右側の柱で、運用チームは、運用環境に配置されたアプリケーションとインフラストラクチャを管理しながら、環境とアプリケーションを監視してアプリケーションをどのように改善できるかについてのフィードバックと分析情報を開発チームに提供できるようにします。</span><span class="sxs-lookup"><span data-stu-id="014e4-125">In the pillar on the right, operations teams manage deployed applications and infrastructure in production while monitoring the environment and applications so that they can provide feedback and insights to the development team about how the application might be improved.</span></span> <span data-ttu-id="014e4-126">コンテナー アプリは、通常、コンテナー オーケストレーターを使用して運用環境内で実行されます。</span><span class="sxs-lookup"><span data-stu-id="014e4-126">Container apps are typically run in production using container orchestrators.</span></span>

<span data-ttu-id="014e4-127">2 つのチームは、基礎的なプラットフォーム (Docker コンテナー) を介してコラボレーションします。このプラットフォームでは、アプリケーション ライフサイクルにおける 2 つのチームのコラボレーションが大幅に改善されながら、コントラクトとしての懸念事項の分離が実現されます。</span><span class="sxs-lookup"><span data-stu-id="014e4-127">The two teams are collaborating through a foundational platform (Docker containers) that provides a separation of concerns as a contract, while greatly improving the two teams' collaboration in the application life cycle.</span></span> <span data-ttu-id="014e4-128">開発者はコンテナーのコンテンツ、その運用環境、およびコンテナーの相互依存関係を所有します。一方、運用チームは構築されたイメージとマニフェストを取得し、それらをオーケストレーション システムで実行します。</span><span class="sxs-lookup"><span data-stu-id="014e4-128">The developers own the container contents, its operating environment, and the container interdependencies, whereas the operations teams take the built images along with the manifest and runs them in their orchestration system.</span></span>

## <a name="challenges-in-application-life-cycle-when-using-docker"></a><span data-ttu-id="014e4-129">Docker を使用する場合のアプリケーション ライフサイクルの課題。</span><span class="sxs-lookup"><span data-stu-id="014e4-129">Challenges in application life cycle when using Docker.</span></span>

<span data-ttu-id="014e4-130">さまざまな理由から、ここ数年間でコンテナー化されたアプリケーションの数は増えるでしょう。その理由の 1 つとして、マイクロサービスに基づくアプリケーションの作成が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="014e4-130">There are many reasons that will increase the number of containerized applications in the upcoming years, and one of these reasons is the creation of applications based on microservices.</span></span>

<span data-ttu-id="014e4-131">過去 15 年間、Web サービスの使用が数千ものアプリケーションの基盤となってきました。おそらく数年後には、Docker コンテナー上で実行されるマイクロサービスベースのアプリケーションに関して同じ状況が発生するでしょう。</span><span class="sxs-lookup"><span data-stu-id="014e4-131">During the last 15 years, the use of web services has been the base of thousands of applications, and probably, after a few years, we'll find the same situation with microservice-based applications running on Docker containers.</span></span>

<span data-ttu-id="014e4-132">さらに、モノリシック アプリケーションに Docker コンテナーを使用することもでき、その場合も Docker のほとんどの利点が得られるということも言及に値します。</span><span class="sxs-lookup"><span data-stu-id="014e4-132">It is also worth to mention that you can also use Docker containers for monolithic applications and you still get most of the benefits of Docker.</span></span> <span data-ttu-id="014e4-133">コンテナーでターゲットにされるのは、マイクロサービスだけではありません。</span><span class="sxs-lookup"><span data-stu-id="014e4-133">Containers are not targeting only microservices.</span></span>

<span data-ttu-id="014e4-134">Docker のコンテナー化とマイクロサービスを使用することで、組織の開発プロセスには新たな課題が生じます。そのため、運用システム上で実行される多くのコンテナーおよびマイクロサービスを維持するために強固な戦略が必要です。</span><span class="sxs-lookup"><span data-stu-id="014e4-134">The use of Docker containerization and microservices causes new challenges in the development process of your organizations and therefore, you need a solid strategy to maintain many containers and microservices running on production systems.</span></span> <span data-ttu-id="014e4-135">最終的に、エンタープライズ アプリケーションでは、数百または数千ものコンテナー/インスタンスが運用環境で実行されることになります。</span><span class="sxs-lookup"><span data-stu-id="014e4-135">Eventually, enterprise applications will have hundreds or thousands of containers/instances running in production.</span></span>

<span data-ttu-id="014e4-136">これらの課題により DevOps ツールを使用する際には新たな要求が生み出されるため、DevOps アクティビティで新しいプロセスを定義し、次のような質問に対する答えを見つける必要があります。</span><span class="sxs-lookup"><span data-stu-id="014e4-136">These challenges create new demands when using DevOps tools, so you'll have to define new processes in your DevOps activities, and find answers for this type of questions:</span></span>

- <span data-ttu-id="014e4-137">開発向けに、また CI/CD、管理、および運用向けにどのようなツールを使用できますか?</span><span class="sxs-lookup"><span data-stu-id="014e4-137">Which tools can I use for development, for CI/CD, management and operations?</span></span>

- <span data-ttu-id="014e4-138">運用環境で実行する場合、会社はコンテナーでのエラーをどのように管理すればよいですか?</span><span class="sxs-lookup"><span data-stu-id="014e4-138">How can my company manage errors in containers when running in production?</span></span>

- <span data-ttu-id="014e4-139">運用環境のソフトウェアを最小限のダウンタイムで変更するにはどうすればよいですか?</span><span class="sxs-lookup"><span data-stu-id="014e4-139">How can we change pieces of our software in production with minimum downtime?</span></span>

- <span data-ttu-id="014e4-140">運用システムのスケーリングおよび監視を行うにはどうすればよいですか?</span><span class="sxs-lookup"><span data-stu-id="014e4-140">How can we scale and how can we monitor our production system?</span></span>

- <span data-ttu-id="014e4-141">ご利用のリリース パイプラインにコンテナーのテストと配置を含めるにはどうすればよいですか?</span><span class="sxs-lookup"><span data-stu-id="014e4-141">How can we include testing and deployment of containers in our release pipeline?</span></span>

- <span data-ttu-id="014e4-142">Microsoft Azure でコンテナー用のオープンソースのツールやプラットフォームを使用するにはどうすればよいですか?</span><span class="sxs-lookup"><span data-stu-id="014e4-142">How can we use Open Source tools/platforms for containers in Microsoft Azure?</span></span>

<span data-ttu-id="014e4-143">これらのすべての質問に答えることができれば、ご利用のアプリケーション (既存または新規のアプリ) を Docker コンテナーに移動する準備が整います。</span><span class="sxs-lookup"><span data-stu-id="014e4-143">If you can answer all those questions, you'll be better prepared to move your applications (existing or new apps) to Docker containers.</span></span>

## <a name="introduction-to-a-generic-end-to-end-docker-application-life-cycle-workflow"></a><span data-ttu-id="014e4-144">一般的なエンドツーエンドの Docker アプリケーション ライフ サイクル ワークフローの概要</span><span class="sxs-lookup"><span data-stu-id="014e4-144">Introduction to a generic end-to-end Docker application life cycle workflow</span></span>

<span data-ttu-id="014e4-145">図 2-2 に、Docker アプリケーション ライフサイクルの詳細なワークフローを示します。このインスタンスでは、特定の DevOps アクティビティと資産に重点を置いています。</span><span class="sxs-lookup"><span data-stu-id="014e4-145">Figure 2-2 presents a more detailed workflow for a Docker application life cycle, focusing in this instance on specific DevOps activities and assets.</span></span>

![Docker アプリの汎用的なエンドツーエンド ライフ サイクルを示す図。](./media/containers-foundation-for-devops-collaboration/generic-end-to-enddpcker-app-life-cycle.png)

<span data-ttu-id="014e4-147">**図 2-2**</span><span class="sxs-lookup"><span data-stu-id="014e4-147">**Figure 2-2.**</span></span> <span data-ttu-id="014e4-148">Docker でコンテナー化されたアプリケーション ライフ サイクルのワークフローの概要</span><span class="sxs-lookup"><span data-stu-id="014e4-148">High-level workflow for the Docker containerized application life cycle</span></span>

<span data-ttu-id="014e4-149">すべてのものは開発者から始まります。開発者は、内側のループのワークフローでコードの記述を開始します。</span><span class="sxs-lookup"><span data-stu-id="014e4-149">Everything begins with the developer, who starts writing code in the inner-loop workflow.</span></span> <span data-ttu-id="014e4-150">内側のループのステージでは、開発者はコード リポジトリ (たとえば、Git などのソース管理システム) にコードをプッシュする前に発生するすべてのことを定義します。</span><span class="sxs-lookup"><span data-stu-id="014e4-150">The inner-loop stage is where developers define everything that happens before pushing code into the code repository (for example, a source control system such as Git).</span></span> <span data-ttu-id="014e4-151">それがコミットされると、リポジトリによって継続的インテグレーション (CI) とその他のワークフローがトリガーされます。</span><span class="sxs-lookup"><span data-stu-id="014e4-151">After it's committed, the repository triggers Continuous Integration (CI) and the rest of the workflow.</span></span>

<span data-ttu-id="014e4-152">内側のループは基本的に "コード化"、"実行"、"テスト"、"デバッグ" のような典型的なステップと、アプリをローカルで実行する直前に必要な追加のステップで構成されています。</span><span class="sxs-lookup"><span data-stu-id="014e4-152">The inner loop basically consists of typical steps like "code," "run," "test," and "debug," plus the additional steps needed right before running the app locally.</span></span> <span data-ttu-id="014e4-153">これは、開発者が担当するプロセスであり、アプリを Docker コンテナーとして実行してテストします。</span><span class="sxs-lookup"><span data-stu-id="014e4-153">This is the developer's process to run and test the app as a Docker container.</span></span> <span data-ttu-id="014e4-154">内側のループのワークフローについては、以降のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="014e4-154">The inner-loop workflow will be explained in the sections that follow.</span></span>

<span data-ttu-id="014e4-155">エンドツーエンドのワークフローを振り返ってみると、DevOps ワークフローは単なるテクノロジまたはツールセットではありません。文化的な進化を必要とする考え方になります。</span><span class="sxs-lookup"><span data-stu-id="014e4-155">Taking a step back to look at the end-to end workflow, the DevOps workflow is more than a technology or a tool set: it's a mindset that requires cultural evolution.</span></span> <span data-ttu-id="014e4-156">アプリケーションのライフ サイクルをより速く、より予測可能にするのは、人、プロセス、そして適切なツールです。</span><span class="sxs-lookup"><span data-stu-id="014e4-156">It's people, processes, and the appropriate tools to make your application life cycle faster and more predictable.</span></span> <span data-ttu-id="014e4-157">コンテナー化されたワークフローを採用する企業は、通常、コンテナー化されたワークフローに対応する人とプロセスを実現するために組織を再構築します。</span><span class="sxs-lookup"><span data-stu-id="014e4-157">Enterprises that adopt a containerized workflow typically restructure their organizations to represent people and processes that match the containerized workflow.</span></span>

<span data-ttu-id="014e4-158">DevOps の実践では、エラーが発生しやすい手動プロセスを自動化に置き換えて、トレーサビリティの向上と繰り返し可能なワークフローを実現して、チームが一体となって競争上の圧力に迅速に対応できるように支援します。</span><span class="sxs-lookup"><span data-stu-id="014e4-158">Practicing DevOps can help teams respond faster together to competitive pressures by replacing error-prone manual processes with automation, which results in improved traceability and repeatable workflows.</span></span> <span data-ttu-id="014e4-159">組織はまた、オンプレミスとクラウドのリソースの組み合わせると共に緊密に統合されたツールを使用して、環境をより効率的に管理し、コスト削減を実現することができます。</span><span class="sxs-lookup"><span data-stu-id="014e4-159">Organizations also can manage environments more efficiently and realize cost savings with a combination of on-premises and cloud resources as well as tightly integrated tooling.</span></span>

<span data-ttu-id="014e4-160">Docker アプリケーション用に DevOps ワークフローを実装する場合、Docker テクノロジがワークフローのほぼすべてのステージに存在することがわかります。それは、内側のループ (コード、実行、デバッグ) で機能する開発ボックスから、ビルド-テスト-CI フェーズ、そして最後はステージングおよび運用環境へのそれらのコンテナーの配置に至ります。</span><span class="sxs-lookup"><span data-stu-id="014e4-160">When implementing your DevOps workflow for Docker applications, you'll see that Docker technologies are present in almost every stage of the workflow, from your development box while working in the inner loop (code, run, debug), the build-test-CI phase, and, finally, the deployment of those containers to the staging and production environments.</span></span>

<span data-ttu-id="014e4-161">品質プラクティスを改善することは、開発サイクルで早期に欠陥を識別して修正コストを削減するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="014e4-161">Improvement of quality practices helps to identify defects early in the development cycle, which reduces the cost of fixing them.</span></span> <span data-ttu-id="014e4-162">環境と依存関係をイメージに含めて、複数の環境に同じイメージを配置するという理念を採用することにより、環境固有の構成を抽出して配置をより信頼性の高いものにするという規範を促進します。</span><span class="sxs-lookup"><span data-stu-id="014e4-162">By including the environment and dependencies in the image and adopting a philosophy of deploying the same image across multiple environments, you promote a discipline of extracting the environment-specific configurations making deployments more reliable.</span></span>

<span data-ttu-id="014e4-163">効果的なインストルメンテーション (監視と診断) を通じて得られた豊富なデータからは、パフォーマンス上の問題とユーザーの行動に関する分析情報が提供され、将来の優先順位と投資を決めるためのガイドとなります。</span><span class="sxs-lookup"><span data-stu-id="014e4-163">Rich data obtained through effective instrumentation (monitoring and diagnostics) provides insight into performance issues and user behavior to guide future priorities and investments.</span></span>

<span data-ttu-id="014e4-164">DevOps は目的地ではなく道のりと見なすべきです。</span><span class="sxs-lookup"><span data-stu-id="014e4-164">DevOps should be considered a journey, not a destination.</span></span> <span data-ttu-id="014e4-165">これは、成功を実証し、学習し、そして進化することができる適切にスコープ化されたプロジェクトを通して段階的に実装される必要があります。</span><span class="sxs-lookup"><span data-stu-id="014e4-165">It should be implemented incrementally through appropriately scoped projects from which you can demonstrate success, learn, and evolve.</span></span>

## <a name="benefits-of-devops-for-containerized-applications"></a><span data-ttu-id="014e4-166">コンテナー化されたアプリケーションに対する DevOps の利点</span><span class="sxs-lookup"><span data-stu-id="014e4-166">Benefits of DevOps for containerized applications</span></span>

<span data-ttu-id="014e4-167">堅実な DevOps ワークフローから得られる最も重要な利点のいくつかを次に示します。</span><span class="sxs-lookup"><span data-stu-id="014e4-167">Here are some of the most important benefits provided by a solid DevOps workflow:</span></span>

- <span data-ttu-id="014e4-168">より高品質のソフトウェアをより速く、より高いコンプライアンスで提供できます。</span><span class="sxs-lookup"><span data-stu-id="014e4-168">Deliver better-quality software, faster and with better compliance.</span></span>

- <span data-ttu-id="014e4-169">継続的な改善と調整をより早く、より経済的に推進できます。</span><span class="sxs-lookup"><span data-stu-id="014e4-169">Drive continuous improvement and adjustments earlier and more economically.</span></span>

- <span data-ttu-id="014e4-170">ソフトウェアの提供と運用に関わる関係者間の透明性とコラボレーションを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="014e4-170">Increase transparency and collaboration among stakeholders involved in delivering and operating software.</span></span>

- <span data-ttu-id="014e4-171">セキュリティリスクを最小限に抑えながら、コストを管理し、プロビジョニングされたリソースをより効果的に利用できます。</span><span class="sxs-lookup"><span data-stu-id="014e4-171">Control costs and utilize provisioned resources more effectively while minimizing security risks.</span></span>

- <span data-ttu-id="014e4-172">オープンソースへの投資を含む、既存の DevOps 投資の多くと十分にプラグ アンド プレイすることができます。</span><span class="sxs-lookup"><span data-stu-id="014e4-172">Plug and play well with many of your existing DevOps investments, including investments in open-source.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="014e4-173">[前へ](index.md)
>[次へ](../Microsoft-platform-tools-containerized-apps/index.md)</span><span class="sxs-lookup"><span data-stu-id="014e4-173">[Previous](index.md)
[Next](../Microsoft-platform-tools-containerized-apps/index.md)</span></span>
