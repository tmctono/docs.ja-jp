---
title: マイクロサービス指向アプリケーションの設計
description: コンテナー化された .NET アプリケーションの .NET マイクロサービス アーキテクチャ | 十分な情報を得たうえでの決定を行うことができるように、マイクロサービス指向アプリケーションの利点と欠点を理解する。
ms.date: 10/02/2018
ms.openlocfilehash: 619440c02c1a82e05adb2cec9ddba933cd3e0a65
ms.sourcegitcommit: feb42222f1430ca7b8115ae45e7a38fc4a1ba623
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/02/2020
ms.locfileid: "76965764"
---
# <a name="design-a-microservice-oriented-application"></a><span data-ttu-id="5afe3-103">マイクロサービス指向アプリケーションを設計する</span><span class="sxs-lookup"><span data-stu-id="5afe3-103">Design a microservice-oriented application</span></span>

<span data-ttu-id="5afe3-104">このセクションでは、仮想のサーバー側エンタープライズ アプリケーションの開発について説明します。</span><span class="sxs-lookup"><span data-stu-id="5afe3-104">This section focuses on developing a hypothetical server-side enterprise application.</span></span>

## <a name="application-specifications"></a><span data-ttu-id="5afe3-105">アプリケーションの仕様</span><span class="sxs-lookup"><span data-stu-id="5afe3-105">Application specifications</span></span>

<span data-ttu-id="5afe3-106">仮想アプリケーションは、ビジネス ロジックを実行し、データベースにアクセスした後、HTML、JSON、または XML 応答を返すことで要求を処理します。</span><span class="sxs-lookup"><span data-stu-id="5afe3-106">The hypothetical application handles requests by executing business logic, accessing databases, and then returning HTML, JSON, or XML responses.</span></span> <span data-ttu-id="5afe3-107">このアプリケーションは、シングル ページ アプリケーション (SPA) を実行するデスクトップ ブラウザー、従来の Web アプリ、モバイル Web アプリ、およびネイティブ モバイル アプリを含むさまざまなクライアントをサポートする必要があるとします。</span><span class="sxs-lookup"><span data-stu-id="5afe3-107">We will say that the application must support a variety of clients, including desktop browsers running Single Page Applications (SPAs), traditional web apps, mobile web apps, and native mobile apps.</span></span> <span data-ttu-id="5afe3-108">さらに、アプリケーションは、サード パーティが使用する API を公開します。</span><span class="sxs-lookup"><span data-stu-id="5afe3-108">The application might also expose an API for third parties to consume.</span></span> <span data-ttu-id="5afe3-109">マイクロサービスまたは外部アプリケーションを非同期に統合して、部分的な障害が発生した場合に、このアプローチによって、マイクロサービスの回復を支援できるようにする必要もあります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-109">It should also be able to integrate its microservices or external applications asynchronously, so that approach will help resiliency of the microservices in the case of partial failures.</span></span>

<span data-ttu-id="5afe3-110">アプリケーションは、次の種類のコンポーネントで構成されます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-110">The application will consist of these types of components:</span></span>

- <span data-ttu-id="5afe3-111">プレゼンテーション コンポーネント。</span><span class="sxs-lookup"><span data-stu-id="5afe3-111">Presentation components.</span></span> <span data-ttu-id="5afe3-112">これらは、UI の処理とリモート サービスの使用を担当します。</span><span class="sxs-lookup"><span data-stu-id="5afe3-112">These are responsible for handling the UI and consuming remote services.</span></span>

- <span data-ttu-id="5afe3-113">ドメインまたはビジネス ロジック。</span><span class="sxs-lookup"><span data-stu-id="5afe3-113">Domain or business logic.</span></span> <span data-ttu-id="5afe3-114">これは、アプリケーションのドメイン ロジックです。</span><span class="sxs-lookup"><span data-stu-id="5afe3-114">This is the application's domain logic.</span></span>

- <span data-ttu-id="5afe3-115">データベース アクセス ロジック。</span><span class="sxs-lookup"><span data-stu-id="5afe3-115">Database access logic.</span></span> <span data-ttu-id="5afe3-116">これは、データベース (SQL または NoSQL) へのアクセスを担当するデータ アクセス コンポーネントで構成されます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-116">This consists of data access components responsible for accessing databases (SQL or NoSQL).</span></span>

- <span data-ttu-id="5afe3-117">アプリケーション統合ロジック。</span><span class="sxs-lookup"><span data-stu-id="5afe3-117">Application integration logic.</span></span> <span data-ttu-id="5afe3-118">これには、主にメッセージ ブローカーに基づくメッセージング チャネルが含まれます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-118">This includes a messaging channel, mainly based on message brokers.</span></span>

<span data-ttu-id="5afe3-119">特定のサブシステムが他のサブシステムよりも多くのスケーラビリティを必要とするため、アプリケーションには、垂直サブシステムが自律的にスケール アウトできる高いスケーラビリティが必要です。</span><span class="sxs-lookup"><span data-stu-id="5afe3-119">The application will require high scalability, while allowing its vertical subsystems to scale out autonomously, because certain subsystems will require more scalability than others.</span></span>

<span data-ttu-id="5afe3-120">アプリケーションは、複数のインフラストラクチャ環境 (複数のパブリック クラウドとオンプレミス) に配置できる必要があり、理想としてはクロスプラットフォームであり、Windows から Linux (またはその逆) に 簡単に移動できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-120">The application must be able to be deployed in multiple infrastructure environments (multiple public clouds and on-premises) and ideally should be cross-platform, able to move from Linux to Windows (or vice versa) easily.</span></span>

## <a name="development-team-context"></a><span data-ttu-id="5afe3-121">開発チームのコンテキスト</span><span class="sxs-lookup"><span data-stu-id="5afe3-121">Development team context</span></span>

<span data-ttu-id="5afe3-122">アプリケーションの開発プロセスについては、以下を前提としています。</span><span class="sxs-lookup"><span data-stu-id="5afe3-122">We also assume the following about the development process for the application:</span></span>

- <span data-ttu-id="5afe3-123">さまざまなビジネス領域のアプリケーションにフォーカスしている複数の開発チームがあること。</span><span class="sxs-lookup"><span data-stu-id="5afe3-123">You have multiple dev teams focusing on different business areas of the application.</span></span>

- <span data-ttu-id="5afe3-124">新しいチーム メンバーは短時間で生産的になる必要があり、アプリケーションを簡単に理解して変更できる必要があること。</span><span class="sxs-lookup"><span data-stu-id="5afe3-124">New team members must become productive quickly, and the application must be easy to understand and modify.</span></span>

- <span data-ttu-id="5afe3-125">アプリケーションは長期間進化し、ビジネス ルールは常に変化すること。</span><span class="sxs-lookup"><span data-stu-id="5afe3-125">The application will have a long-term evolution and ever-changing business rules.</span></span>

- <span data-ttu-id="5afe3-126">適切な長期にわたる保守容易性が必要なこと。これは、将来新しい変更を機敏に実装する一方で、複数のサブシステムを他のサブシステムに与える影響を最小限に抑えながら更新できることを意味します。</span><span class="sxs-lookup"><span data-stu-id="5afe3-126">You need good long-term maintainability, which means having agility when implementing new changes in the future while being able to update multiple subsystems with minimum impact on the other subsystems.</span></span>

- <span data-ttu-id="5afe3-127">アプリケーションの継続的インテグレーションと継続的デプロイを実践すること。</span><span class="sxs-lookup"><span data-stu-id="5afe3-127">You want to practice continuous integration and continuous deployment of the application.</span></span>

- <span data-ttu-id="5afe3-128">アプリケーションを進化させながら、新しいテクノロジ (フレームワークやプログラミング言語など) を活用すること。</span><span class="sxs-lookup"><span data-stu-id="5afe3-128">You want to take advantage of emerging technologies (frameworks, programming languages, etc.) while evolving the application.</span></span> <span data-ttu-id="5afe3-129">新しいテクノロジに移行するときに、アプリケーションの完全移行は行いません。理由は、完全移行にはコストがかかり、アプリケーションの予測可能性と安定性に影響する可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="5afe3-129">You do not want to make full migrations of the application when moving to new technologies, because that would result in high costs and impact the predictability and stability of the application.</span></span>

## <a name="choosing-an-architecture"></a><span data-ttu-id="5afe3-130">アーキテクチャの選択</span><span class="sxs-lookup"><span data-stu-id="5afe3-130">Choosing an architecture</span></span>

<span data-ttu-id="5afe3-131">アプリケーションを配置するアーキテクチャは何にすべきでしょうか。</span><span class="sxs-lookup"><span data-stu-id="5afe3-131">What should the application deployment architecture be?</span></span> <span data-ttu-id="5afe3-132">アプリケーションの仕様と開発コンテキストでは、アプリケーションをマイクロサービスとコンテナーとコラボレーションする形の自律的なサブシステムに分解して設計することを強くお勧めします。ここでは、マイクロサービスはコンテナーになります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-132">The specifications for the application, along with the development context, strongly suggest that you should architect the application by decomposing it into autonomous subsystems in the form of collaborating microservices and containers, where a microservice is a container.</span></span>

<span data-ttu-id="5afe3-133">このアプローチでは、各サービス (コンテナー) は、まとまりがある狭義に関連する一連の機能を実装します。</span><span class="sxs-lookup"><span data-stu-id="5afe3-133">In this approach, each service (container) implements a set of cohesive and narrowly related functions.</span></span> <span data-ttu-id="5afe3-134">たとえば、アプリケーションは、カタログ サービス、受注サービス、バスケット サービス、ユーザー プロファイル サービスなどで構成されます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-134">For example, an application might consist of services such as the catalog service, ordering service, basket service, user profile service, etc.</span></span>

<span data-ttu-id="5afe3-135">マイクロサービスは、HTTP (REST) などのプロトコルを使用して通信しますが、可能であれば常に非同期 (AMQP の使用など) でも通信します。これは、特に統合イベントの更新を伝達するときに実行されます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-135">Microservices communicate using protocols such as HTTP (REST), but also asynchronously (for example, using AMQP) whenever possible, especially when propagating updates with integration events.</span></span>

<span data-ttu-id="5afe3-136">マイクロサービスは、互いに独立したコンテナーとして開発と配置が行われます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-136">Microservices are developed and deployed as containers independently of one another.</span></span> <span data-ttu-id="5afe3-137">これは、開発チームが特定のマイクロサービスを、他のサブシステムに影響を与えずに開発して配置できることを意味します。</span><span class="sxs-lookup"><span data-stu-id="5afe3-137">This means that a development team can be developing and deploying a certain microservice without impacting other subsystems.</span></span>

<span data-ttu-id="5afe3-138">各マイクロサービスには独自のデータベースがあり、それによって、他のマイクロサービスから完全に切り離すことができます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-138">Each microservice has its own database, allowing it to be fully decoupled from other microservices.</span></span> <span data-ttu-id="5afe3-139">必要であれば、異なるマイクロサービスのデータベース間の整合性は、コマンド クエリ責務分離 (CQRS) での処理と同じように、アプリケーション レベルの統合を使用して (論理イベント バス経由で) 実現されます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-139">When necessary, consistency between databases from different microservices is achieved using application-level integration events (through a logical event bus), as handled in Command and Query Responsibility Segregation (CQRS).</span></span> <span data-ttu-id="5afe3-140">そのため、ビジネス上の制約は、複数のマイクロサービスと関連するデータベース間の最終的な整合性を容認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-140">Because of that, the business constraints must embrace eventual consistency between the multiple microservices and related databases.</span></span>

### <a name="eshoponcontainers-a-reference-application-for-net-core-and-microservices-deployed-using-containers"></a><span data-ttu-id="5afe3-141">eShopOnContainers: .NET Core とコンテナーを使用して配置されるマイクロサービス用のリファレンス アプリケーション</span><span class="sxs-lookup"><span data-stu-id="5afe3-141">eShopOnContainers: A reference application for .NET Core and microservices deployed using containers</span></span>

<span data-ttu-id="5afe3-142">知識を持っていない可能性がある仮想ビジネス ドメインを検討する代わりに、アーキテクチャとテクノロジにフォーカスできるようにするために、既知のビジネス ドメインが選択されています。具体的には、製品カタログの提示、顧客からの注文の受け取り、在庫の確認、およびその他のビジネス機能を実行する単純化された eコマース (eショップ) アプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="5afe3-142">So that you can focus on the architecture and technologies instead of thinking about a hypothetical business domain that you might not know, we have selected a well-known business domain—namely, a simplified e-commerce (e-shop) application that presents a catalog of products, takes orders from customers, verifies inventory, and performs other business functions.</span></span> <span data-ttu-id="5afe3-143">このコンテナー ベースのアプリケーションのソース コードは、[eShopOnContainers](https://aka.ms/MicroservicesArchitecture) GitHub リポジトリから入手できます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-143">This container-based application source code is available in the [eShopOnContainers](https://aka.ms/MicroservicesArchitecture) GitHub repo.</span></span>

<span data-ttu-id="5afe3-144">アプリケーションは、さまざまなストアの UI フロント エンド (Web アプリケーションとネイティブ モバイル アプリ) と、内部マイクロサービスへの統合されたエントリ ポイントとしてのいくつかの API ゲートウェイを使用する、サーバー側で必要なすべての操作用のバックエンド マイクロサービスとコンテナーを含む複数のサブシステムで構成されます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-144">The application consists of multiple subsystems, including several store UI front ends (a Web application and a native mobile app), along with the back-end microservices and containers for all the required server-side operations with several API Gateways as consolidated entry points to the internal microservices.</span></span> <span data-ttu-id="5afe3-145">図 6-1 は、リファレンス アプリケーションのアーキテクチャを示しています。</span><span class="sxs-lookup"><span data-stu-id="5afe3-145">Figure 6-1 shows the architecture of the reference application.</span></span>

![1 つの Docker ホストで eShopOnContainers を使用しているクライアント アプリの図。](./media/microservice-application-design/eshoponcontainers-reference-application-architecture.png)

<span data-ttu-id="5afe3-147">**図 6-1**。</span><span class="sxs-lookup"><span data-stu-id="5afe3-147">**Figure 6-1**.</span></span> <span data-ttu-id="5afe3-148">開発環境用の eShopOnContainers 参照アプリケーション アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="5afe3-148">The eShopOnContainers reference application architecture for development environment</span></span>

<span data-ttu-id="5afe3-149">上の図は、モバイル クライアントと SPA クライアントが単一の API ゲートウェイ エンドポイントと通信し、次にマイクロサービスと通信することを示しています。</span><span class="sxs-lookup"><span data-stu-id="5afe3-149">The above diagram shows that Mobile and SPA clients communicate to single API gateway endpoints, that then communicate to microservices.</span></span> <span data-ttu-id="5afe3-150">従来の Web クライアントは MVC マイクロサービスと通信し、API ゲートウェイを介してマイクロサービスと通信します。</span><span class="sxs-lookup"><span data-stu-id="5afe3-150">Traditional web clients communicate to MVC microservice, that communicates to microservices through the API gateway.</span></span>

<span data-ttu-id="5afe3-151">**ホスト環境**。</span><span class="sxs-lookup"><span data-stu-id="5afe3-151">**Hosting environment**.</span></span> <span data-ttu-id="5afe3-152">図 6-1 で、単一の Docker ホスト内に配置されたさまざまなコンテナーを確認します。</span><span class="sxs-lookup"><span data-stu-id="5afe3-152">In Figure 6-1, you see several containers deployed within a single Docker host.</span></span> <span data-ttu-id="5afe3-153">これは、docker-compose up コマンドを使用して単一の Docker ホストに配置する場合のものです。</span><span class="sxs-lookup"><span data-stu-id="5afe3-153">That would be the case when deploying to a single Docker host with the docker-compose up command.</span></span> <span data-ttu-id="5afe3-154">ただし、オーケストレーターまたはコンテナー クラスターを使用する場合は、各コンテナーを別のホスト (ノード) で実行でき、任意のノードで任意の数のコンテナーを実行できます。これについては、アーキテクチャのセクションで既に説明しました。</span><span class="sxs-lookup"><span data-stu-id="5afe3-154">However, if you are using an orchestrator or container cluster, each container could be running in a different host (node), and any node could be running any number of containers, as we explained earlier in the architecture section.</span></span>

<span data-ttu-id="5afe3-155">**通信アーキテクチャ**。</span><span class="sxs-lookup"><span data-stu-id="5afe3-155">**Communication architecture**.</span></span> <span data-ttu-id="5afe3-156">eShopOnContainers アプリケーションは、機能アクションの種類 (クエリ対更新とトランザクション) に応じて、2 種類の通信を使用します。</span><span class="sxs-lookup"><span data-stu-id="5afe3-156">The eShopOnContainers application uses two communication types, depending on the kind of the functional action (queries versus updates and transactions):</span></span>

- <span data-ttu-id="5afe3-157">API ゲートウェイ経由でのクライアントからマイクロサービスへの HTTP 通信。</span><span class="sxs-lookup"><span data-stu-id="5afe3-157">Http client-to-microservice communication through API Gateways.</span></span> <span data-ttu-id="5afe3-158">これは、クエリで、クライアント アプリから更新またはトランザクション コマンドを受け入れるときに使用されます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-158">This is used for queries and when accepting update or transactional commands from the client apps.</span></span> <span data-ttu-id="5afe3-159">API ゲートウェイを使用したアプローチについては、後のセクションで詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="5afe3-159">The approach using API Gateways is explained in detail in later sections.</span></span>

- <span data-ttu-id="5afe3-160">イベント ベースの非同期通信。</span><span class="sxs-lookup"><span data-stu-id="5afe3-160">Asynchronous event-based communication.</span></span> <span data-ttu-id="5afe3-161">これは、マイクロサービス間で更新を伝達するか、外部アプリケーションと統合するために、イベント バス経由で発生します。</span><span class="sxs-lookup"><span data-stu-id="5afe3-161">This occurs through an event bus to propagate updates across microservices or to integrate with external applications.</span></span> <span data-ttu-id="5afe3-162">イベント バスは、RabbitMQ などのメッセージング ブローカー インフラストラクチャ テクノロジを使用するか、Azure Service Bus、NServiceBus、MassTransit、Brighter などの上位レベル (抽象化レベル) のサービス バスを使用して実装できます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-162">The event bus can be implemented with any messaging-broker infrastructure technology like RabbitMQ, or using higher-level (abstraction-level) service buses like Azure Service Bus, NServiceBus, MassTransit, or Brighter.</span></span>

<span data-ttu-id="5afe3-163">アプリケーションは、コンテナーの形の一連のマイクロサービスとして配置されます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-163">The application is deployed as a set of microservices in the form of containers.</span></span> <span data-ttu-id="5afe3-164">クライアント アプリは、API ゲートウェイによって公開されたパブリック URL 経由でコンテナーとして実行されているこれらのマイクロサービスと通信できます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-164">Client apps can communicate with those microservices running as containers through the public URLs published by the API Gateways.</span></span>

### <a name="data-sovereignty-per-microservice"></a><span data-ttu-id="5afe3-165">マイクロサービス単位のデータ管理</span><span class="sxs-lookup"><span data-stu-id="5afe3-165">Data sovereignty per microservice</span></span>

<span data-ttu-id="5afe3-166">サンプル アプリケーションでは、SQL Server データベースがすべて単一のコンテナーとして配置されますが、各マイクロサービスで独自のデータベースまたはデータ ソースを所有します。</span><span class="sxs-lookup"><span data-stu-id="5afe3-166">In the sample application, each microservice owns its own database or data source, although all SQL Server databases are deployed as a single container.</span></span> <span data-ttu-id="5afe3-167">この設計上の決定は、開発者が GitHub からコードを取得して複製し、Visual Studio または Visual Studio Code で簡単に開くことができるようにすることのみを目的として行われました。</span><span class="sxs-lookup"><span data-stu-id="5afe3-167">This design decision was made only to make it easy for a developer to get the code from GitHub, clone it, and open it in Visual Studio or Visual Studio Code.</span></span> <span data-ttu-id="5afe3-168">または、これによって、カスタム Docker イメージを .NET Core CLI と Docker CLI を使用してコンパイルした後、Docker 開発環境に配置して実行しやすくなります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-168">Or alternatively, it makes it easy to compile the custom Docker images using the .NET Core CLI and the Docker CLI, and then deploy and run them in a Docker development environment.</span></span> <span data-ttu-id="5afe3-169">どちらの方法でも、データ ソース用のコンテナーを使用することで、開発者は、インフラストラクチャ (クラウドまたはオンプレミス) に強く依存している外部データベースやその他のデータ ソースのプロビジョニングなしで、ほんの数分でビルドと配置を実行できます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-169">Either way, using containers for data sources lets developers build and deploy in a matter of minutes without having to provision an external database or any other data source with hard dependencies on infrastructure (cloud or on-premises).</span></span>

<span data-ttu-id="5afe3-170">実際の運用環境では、高可用性とスケーラビリティを実現するために、データベースは、コンテナーではなく、クラウドまたはオンプレミスのデータベース サーバーに基づく必要があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-170">In a real production environment, for high availability and for scalability, the databases should be based on database servers in the cloud or on-premises, but not in containers.</span></span>

<span data-ttu-id="5afe3-171">そのため、マイクロサービス (およびこのアプリケーション内のデータベース) の配置の単位は Docker コンテナーであり、リファレンス アプリケーションはマイクロサービスの 原則を採用するマルチコンテナー アプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="5afe3-171">Therefore, the units of deployment for microservices (and even for databases in this application) are Docker containers, and the reference application is a multi-container application that embraces microservices principles.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="5afe3-172">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="5afe3-172">Additional resources</span></span>

- <span data-ttu-id="5afe3-173">**eShopOnContainers GitHub リポジトリ。参照アプリケーションのソース コード** </span><span class="sxs-lookup"><span data-stu-id="5afe3-173">**eShopOnContainers GitHub repo. Source code for the reference application** </span></span>\
  <https://aka.ms/eShopOnContainers/>

## <a name="benefits-of-a-microservice-based-solution"></a><span data-ttu-id="5afe3-174">マイクロサービス ベースのソリューションの利点</span><span class="sxs-lookup"><span data-stu-id="5afe3-174">Benefits of a microservice-based solution</span></span>

<span data-ttu-id="5afe3-175">このようなマイクロサービス ベースのソリューションには、多くの利点があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-175">A microservice-based solution like this has many benefits:</span></span>

<span data-ttu-id="5afe3-176">**各マイクロサービスが比較的小さい - 管理しやすく進化させやすい**。</span><span class="sxs-lookup"><span data-stu-id="5afe3-176">**Each microservice is relatively small—easy to manage and evolve**.</span></span> <span data-ttu-id="5afe3-177">具体的には、次のように使用します。</span><span class="sxs-lookup"><span data-stu-id="5afe3-177">Specifically:</span></span>

- <span data-ttu-id="5afe3-178">開発者が理解しやすく、適切な生産性ですぐに開始できます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-178">It is easy for a developer to understand and get started quickly with good productivity.</span></span>

- <span data-ttu-id="5afe3-179">コンテナーは短時間で開始されます。これにより、開発者の生産性が向上します。</span><span class="sxs-lookup"><span data-stu-id="5afe3-179">Containers start fast, which makes developers more productive.</span></span>

- <span data-ttu-id="5afe3-180">Visual Studio のような IDE は、小さなプロジェクトを高速で読み込みます。これにより、開発者の生産性が向上します。</span><span class="sxs-lookup"><span data-stu-id="5afe3-180">An IDE like Visual Studio can load smaller projects fast, making developers productive.</span></span>

- <span data-ttu-id="5afe3-181">各マイクロサービスの設計、開発、および配置は、他のマイクロサービスとは無関係に実行できます。これにより、新しいバージョンのマイクロサービスの配置を簡単かつ頻繁に実行できるため、機敏性が提供されます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-181">Each microservice can be designed, developed, and deployed independently of other microservices, which provides agility because it is easier to deploy new versions of microservices frequently.</span></span>

<span data-ttu-id="5afe3-182">**アプリケーションの個々 の領域をスケールアウトできます**。</span><span class="sxs-lookup"><span data-stu-id="5afe3-182">**It is possible to scale out individual areas of the application**.</span></span> <span data-ttu-id="5afe3-183">たとえば、カタログ サービスとバスケット サービスはスケールアウトが必要になることがありますが、受注サービスでは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="5afe3-183">For instance, the catalog service or the basket service might need to be scaled out, but not the ordering process.</span></span> <span data-ttu-id="5afe3-184">マイクロサービス インフラストラクチャは、スケールアウトする際に使用されるリソースに関して、モノリシック アーキテクチャよりも、はるかに効率的です。</span><span class="sxs-lookup"><span data-stu-id="5afe3-184">A microservices infrastructure will be much more efficient with regard to the resources used when scaling out than a monolithic architecture would be.</span></span>

<span data-ttu-id="5afe3-185">**開発作業を複数のチームに分割できます**。</span><span class="sxs-lookup"><span data-stu-id="5afe3-185">**You can divide the development work between multiple teams**.</span></span> <span data-ttu-id="5afe3-186">各サービスは、1 つの開発チームが所有できます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-186">Each service can be owned by a single development team.</span></span> <span data-ttu-id="5afe3-187">各チームは、管理、開発、配置、およびスケーリングを、残りのチームとは無関係に実行できます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-187">Each team can manage, develop, deploy, and scale their service independently of the rest of the teams.</span></span>

<span data-ttu-id="5afe3-188">**問題を分離できます**。</span><span class="sxs-lookup"><span data-stu-id="5afe3-188">**Issues are more isolated**.</span></span> <span data-ttu-id="5afe3-189">あるサービスに問題がある場合、当初影響を受けるのはそのサービスのみであり (マイクロサービス間に直接的な依存関係がある正しくない設計が使用されている場合は除きます)、他のサービスは要求の処理を続行できます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-189">If there is an issue in one service, only that service is initially impacted (except when the wrong design is used, with direct dependencies between microservices), and other services can continue to handle requests.</span></span> <span data-ttu-id="5afe3-190">対照的に、モノリシックな配置アーキテクチャで 1 つのコンポーネントが正常に機能していない場合、それが特にメモリ リークなどのリソースに関係している場合は、システム全体がダウンする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-190">In contrast, one malfunctioning component in a monolithic deployment architecture can bring down the entire system, especially when it involves resources, such as a memory leak.</span></span> <span data-ttu-id="5afe3-191">さらに、マイクロサービス内の問題が解決したら、アプリケーションの残りの部分に影響を与えることなく、影響を受けたマイクロサービスだけを配置できます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-191">Additionally, when an issue in a microservice is resolved, you can deploy just the affected microservice without impacting the rest of the application.</span></span>

<span data-ttu-id="5afe3-192">**最新のテクノロジを利用できます**。</span><span class="sxs-lookup"><span data-stu-id="5afe3-192">**You can use the latest technologies**.</span></span> <span data-ttu-id="5afe3-193">サービスの開発を個別に開始して、横並びで実行できるため (コンテナーと .NET Core のおかげです)、アプリケーション全体で古いスタックやフレームワークにとらわれることなく最新のテクノロジとフレームワークの使用を臨機応変に開始できます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-193">Because you can start developing services independently and run them side by side (thanks to containers and .NET Core), you can start using the latest technologies and frameworks expediently instead of being stuck on an older stack or framework for the whole application.</span></span>

## <a name="downsides-of-a-microservice-based-solution"></a><span data-ttu-id="5afe3-194">マイクロサービス ベースのソリューションのマイナス面</span><span class="sxs-lookup"><span data-stu-id="5afe3-194">Downsides of a microservice-based solution</span></span>

<span data-ttu-id="5afe3-195">このようなマイクロサービス ベースのソリューションには、いくつかの短所もあります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-195">A microservice-based solution like this also has some drawbacks:</span></span>

<span data-ttu-id="5afe3-196">**分散アプリケーション**。</span><span class="sxs-lookup"><span data-stu-id="5afe3-196">**Distributed application**.</span></span> <span data-ttu-id="5afe3-197">アプリケーションを分散させると、開発者によるサービスの設計とビルドが複雑になります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-197">Distributing the application adds complexity for developers when they are designing and building the services.</span></span> <span data-ttu-id="5afe3-198">たとえば、開発者は、HTTP や AMPQ などのプロトコルを使用してサービス間の通信を実装する必要があります。これにより、テストと例外処理が複雑になります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-198">For example, developers must implement inter-service communication using protocols like HTTP or AMPQ, which adds complexity for testing and exception handling.</span></span> <span data-ttu-id="5afe3-199">また、待機時間がシステムに追加されます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-199">It also adds latency to the system.</span></span>

<span data-ttu-id="5afe3-200">**配置の複雑性**。</span><span class="sxs-lookup"><span data-stu-id="5afe3-200">**Deployment complexity**.</span></span> <span data-ttu-id="5afe3-201">数十種類のマイクロサービスがあり、高いスケーラビリティを必要とするアプリケーション (サービスごとに複数のインスタンスを作成でき、それらのサービスを複数のホスト間でバランスを取る必要があります) では、IT の運用と管理に対する配置の複雑さが高まります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-201">An application that has dozens of microservices types and needs high scalability (it needs to be able to create many instances per service and balance those services across many hosts) means a high degree of deployment complexity for IT operations and management.</span></span> <span data-ttu-id="5afe3-202">マイクロサービス指向のインフラストラクチャ (オーケストレーターとスケジューラなど) を使用していない場合、複雑さの上昇によって、ビジネス アプリケーション自体を大きく上回る開発努力が必要になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-202">If you are not using a microservice-oriented infrastructure (like an orchestrator and scheduler), that additional complexity can require far more development efforts than the business application itself.</span></span>

<span data-ttu-id="5afe3-203">**アトミック トランザクション**。</span><span class="sxs-lookup"><span data-stu-id="5afe3-203">**Atomic transactions**.</span></span> <span data-ttu-id="5afe3-204">複数のマイクロサービス間のアトミック トランザクションは、通常は可能ではありません。</span><span class="sxs-lookup"><span data-stu-id="5afe3-204">Atomic transactions between multiple microservices usually are not possible.</span></span> <span data-ttu-id="5afe3-205">ビジネス要件は、複数のマイクロサービス間の最終的な整合性を容認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-205">The business requirements have to embrace eventual consistency between multiple microservices.</span></span>

<span data-ttu-id="5afe3-206">**グローバルなリソースのニーズの増加** (すべてのサーバーまたはホストの合計メモリ、ドライブ、およびネットワーク リソース)。</span><span class="sxs-lookup"><span data-stu-id="5afe3-206">**Increased global resource needs** (total memory, drives, and network resources for all the servers or hosts).</span></span> <span data-ttu-id="5afe3-207">多くの場合、モノリシック アプリケーションをマイクロサービスのアプローチに置き換える場合、新しいマイクロサービス ベースのアプリケーションで必要な初期のグローバル リソースの量は、元のモノリシック アプリケーションのインフラストラクチャの必要な量よりも大きくなります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-207">In many cases, when you replace a monolithic application with a microservices approach, the amount of initial global resources needed by the new microservice-based application will be larger than the infrastructure needs of the original monolithic application.</span></span> <span data-ttu-id="5afe3-208">これは、高いレベルの粒度と分散サービスによって多くのグローバル リソースが必要になるためです。</span><span class="sxs-lookup"><span data-stu-id="5afe3-208">This is because the higher degree of granularity and distributed services requires more global resources.</span></span> <span data-ttu-id="5afe3-209">ただし、リソースは一般に低コストであり、モノリシック アプリケーションを進化させる場合の長期的なコストに比べてアプリケーションの特定の領域のみをスケールアウトできるという利点を考慮すると、リソースの使用量の増加は、長期にわたって使用される大規模なアプリケーションにとっては、通常は適切なトレードオフになります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-209">However, given the low cost of resources in general and the benefit of being able to scale out just certain areas of the application compared to long-term costs when evolving monolithic applications, the increased use of resources is usually a good tradeoff for large, long-term applications.</span></span>

<span data-ttu-id="5afe3-210">**クライアントからマイクロサービスへの直接的な通信に伴う問題**。</span><span class="sxs-lookup"><span data-stu-id="5afe3-210">**Issues with direct client-to-microservice communication**.</span></span> <span data-ttu-id="5afe3-211">アプリケーションが数十個のマイクロサービスを含む大規模なものであるときに、クライアントからマイクロサービスへの直接的な通信が必要な場合は、課題と制限があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-211">When the application is large, with dozens of microservices, there are challenges and limitations if the application requires direct client-to-microservice communications.</span></span> <span data-ttu-id="5afe3-212">1 つの問題 は、クライアントのニーズと各マイクロサービスによって公開される API のニーズが一致しない可能性です。</span><span class="sxs-lookup"><span data-stu-id="5afe3-212">One problem is a potential mismatch between the needs of the client and the APIs exposed by each of the microservices.</span></span> <span data-ttu-id="5afe3-213">場合によっては、クライアント アプリケーションは、UI を構成するために多数の独立した要求を行う必要がありますが、これはインターネット経由では効率的ではない可能性があり、モバイル ネットワークでは実用的ではありません。</span><span class="sxs-lookup"><span data-stu-id="5afe3-213">In certain cases, the client application might need to make many separate requests to compose the UI, which can be inefficient over the Internet and would be impractical over a mobile network.</span></span> <span data-ttu-id="5afe3-214">そのため、クライアント アプリケーションからバックエンド システムへの要求は最小限に抑える必要があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-214">Therefore, requests from the client application to the back-end system should be minimized.</span></span>

<span data-ttu-id="5afe3-215">クライアントからマイクロサービスへの直接的な通信に伴う別の問題は、一部のマイクロサービスで使用するプロトコルが Web フレンドリではない場合があることです。</span><span class="sxs-lookup"><span data-stu-id="5afe3-215">Another problem with direct client-to-microservice communications is that some microservices might be using protocols that are not Web-friendly.</span></span> <span data-ttu-id="5afe3-216">あるサービスではバイナリ プロトコルが使用され、別のサービスでは AMQP メッセージングが使用されることがあります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-216">One service might use a binary protocol, while another service might use AMQP messaging.</span></span> <span data-ttu-id="5afe3-217">これらのプロトコルはファイアウォール フレンドリではなく、最善なのは内部的に使用することです。</span><span class="sxs-lookup"><span data-stu-id="5afe3-217">Those protocols are not firewall-friendly and are best used internally.</span></span> <span data-ttu-id="5afe3-218">通常、アプリケーションは、ファイアウォールの外部と通信するために HTTP や Websocket などのプロトコルを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-218">Usually, an application should use protocols such as HTTP and WebSockets for communication outside of the firewall.</span></span>

<span data-ttu-id="5afe3-219">さらに、クライアントからマイクロサービスへの直接的な通信に伴う別のマイナス面は、これらのマイクロサービスのコントラクトのリファクタリングが困難になることです。</span><span class="sxs-lookup"><span data-stu-id="5afe3-219">Yet another drawback with this direct client-to-service approach is that it makes it difficult to refactor the contracts for those microservices.</span></span> <span data-ttu-id="5afe3-220">時間の経過と共に、開発者は、システムをサービスに分割する方法を変更する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-220">Over time developers might want to change how the system is partitioned into services.</span></span> <span data-ttu-id="5afe3-221">たとえば、2 つのサービスをマージしたり、1 つのサービスを複数のサービスに分割したりします。</span><span class="sxs-lookup"><span data-stu-id="5afe3-221">For example, they might merge two services or split a service into two or more services.</span></span> <span data-ttu-id="5afe3-222">ただし、クライアントがサービスと直接的に通信している場合、この種のリファクタリングを実行すると、クライアント アプリとの互換性が破られる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-222">However, if clients communicate directly with the services, performing this kind of refactoring can break compatibility with client apps.</span></span>

<span data-ttu-id="5afe3-223">アーキテクチャのセクションで説明したように、マイクロサービスに基づく複雑なアプリケーションの設計とビルドを行うときは、単純なクライアントからマイクロサービスへの直接的な通信ではなく、複数の粒度の細かい API ゲートウェイの使用を検討してください。</span><span class="sxs-lookup"><span data-stu-id="5afe3-223">As mentioned in the architecture section, when designing and building a complex application based on microservices, you might consider the use of multiple fine-grained API Gateways instead of the simpler direct client-to-microservice communication approach.</span></span>

<span data-ttu-id="5afe3-224">**マイクロサービスの分割**。</span><span class="sxs-lookup"><span data-stu-id="5afe3-224">**Partitioning the microservices**.</span></span> <span data-ttu-id="5afe3-225">最後に、マイクロサービス アーキテクチャで採用するアプローチに関係なく、エンド ツー エンド アプリケーションを複数のマイクロサービスにどのように分割するかという別の課題があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-225">Finally, no matter which approach you take for your microservice architecture, another challenge is deciding how to partition an end-to-end application into multiple microservices.</span></span> <span data-ttu-id="5afe3-226">このガイドのアーキテクチャで説明したように、使用できるさまざまな手法とアプローチがあります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-226">As noted in the architecture section of the guide, there are several techniques and approaches you can take.</span></span> <span data-ttu-id="5afe3-227">基本的には、他の領域から切り離され、依存関係の数が少ないアプリケーションの領域を識別する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-227">Basically, you need to identify areas of the application that are decoupled from the other areas and that have a low number of hard dependencies.</span></span> <span data-ttu-id="5afe3-228">多くの場合、これは、ユース ケースによってサービスを分割することと同じです。</span><span class="sxs-lookup"><span data-stu-id="5afe3-228">In many cases, this is aligned to partitioning services by use case.</span></span> <span data-ttu-id="5afe3-229">たとえば、e ショップ アプリケーションには、受注プロセスに関連するすべてのビジネス ロジックを担当する受注サービスがあります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-229">For example, in our e-shop application, we have an ordering service that is responsible for all the business logic related to the order process.</span></span> <span data-ttu-id="5afe3-230">他の機能を実装するカタログ サービスとバスケット サービスもあります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-230">We also have the catalog service and the basket service that implement other capabilities.</span></span> <span data-ttu-id="5afe3-231">各サービスが少数の責任のみを持っていることが理想です。</span><span class="sxs-lookup"><span data-stu-id="5afe3-231">Ideally, each service should have only a small set of responsibilities.</span></span> <span data-ttu-id="5afe3-232">これは、クラスの変更理由は 1 つだけにする必要があるという、クラスに適用される単一責任原則 (SRP) に似ています。</span><span class="sxs-lookup"><span data-stu-id="5afe3-232">This is similar to the single responsibility principle (SRP) applied to classes, which states that a class should only have one reason to change.</span></span> <span data-ttu-id="5afe3-233">ただし、ここではマイクロサービスに関するものであるため、そのスコープは 1 つのクラスよりも大きくなります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-233">But in this case, it is about microservices, so the scope will be larger than a single class.</span></span> <span data-ttu-id="5afe3-234">何よりも、マイクロサービスは、独自のデータ ソースに対する責任も含めて、端から端まで完全に自律的である必要があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-234">Most of all, a microservice has to be completely autonomous, end to end, including responsibility for its own data sources.</span></span>

## <a name="external-versus-internal-architecture-and-design-patterns"></a><span data-ttu-id="5afe3-235">外部アーキテクチャ、内部アーキテクチャ、および設計パターン</span><span class="sxs-lookup"><span data-stu-id="5afe3-235">External versus internal architecture and design patterns</span></span>

<span data-ttu-id="5afe3-236">外部アーキテクチャは複数のサービスによって構成されるマイクロサービス アーキテクチャであり、このガイドのアーキテクチャのセクションで説明した原則に従っています。</span><span class="sxs-lookup"><span data-stu-id="5afe3-236">The external architecture is the microservice architecture composed by multiple services, following the principles described in the architecture section of this guide.</span></span> <span data-ttu-id="5afe3-237">ただし、各マイクロサービスの性質によっては、選択された高度なマイクロサービス アーキテクチャに関係なく、マイクロサービスごとに異なるパターンに基づいて複数の内部アーキテクチャを持つことが一般的であり、そのようにすることが推奨される場合もあります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-237">However, depending on the nature of each microservice, and independently of high-level microservice architecture you choose, it is common and sometimes advisable to have different internal architectures, each based on different patterns, for different microservices.</span></span> <span data-ttu-id="5afe3-238">マイクロサービスでは、複数のテクノロジとプログラミング言語を使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-238">The microservices can even use different technologies and programming languages.</span></span> <span data-ttu-id="5afe3-239">この多様性を図 6-2 に示します。</span><span class="sxs-lookup"><span data-stu-id="5afe3-239">Figure 6-2 illustrates this diversity.</span></span>

![外部アーキテクチャと内部アーキテクチャのパターンを比較した図。](./media/microservice-application-design/external-versus-internal-architecture.png)

<span data-ttu-id="5afe3-241">**図 6-2**。</span><span class="sxs-lookup"><span data-stu-id="5afe3-241">**Figure 6-2**.</span></span> <span data-ttu-id="5afe3-242">外部アーキテクチャ、内部アーキテクチャ、および設計</span><span class="sxs-lookup"><span data-stu-id="5afe3-242">External versus internal architecture and design</span></span>

<span data-ttu-id="5afe3-243">たとえば、*eShopOnContainers* の例では、カタログ、バスケット、およびユーザー プロファイルのマイクロサービス は単純です (基本的には CRUD サブシステムです)。</span><span class="sxs-lookup"><span data-stu-id="5afe3-243">For instance, in our *eShopOnContainers* sample, the catalog, basket, and user profile microservices are simple (basically, CRUD subsystems).</span></span> <span data-ttu-id="5afe3-244">そのため、その内部アーキテクチャと設計はわかりやすいものです。</span><span class="sxs-lookup"><span data-stu-id="5afe3-244">Therefore, their internal architecture and design is straightforward.</span></span> <span data-ttu-id="5afe3-245">ただし、もっと複雑であり、ドメインが非常に複雑である常に変化するビジネス ルールを表すマイクロサービス (受注マイクロサービスなど) が存在する場合があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-245">However, you might have other microservices, such as the ordering microservice, which is more complex and represents ever-changing business rules with a high degree of domain complexity.</span></span> <span data-ttu-id="5afe3-246">このような場合は、*eShopOnContainers* の受注マイクロサービスで実行しているように、ドメイン駆動設計 (DDD) アプローチによって定義される高度なパターンを特定のマイクロサービスの中で 実装することができます</span><span class="sxs-lookup"><span data-stu-id="5afe3-246">In cases like these, you might want to implement more advanced patterns within a particular microservice, like the ones defined with domain-driven design (DDD) approaches, as we are doing in the *eShopOnContainers* ordering microservice.</span></span> <span data-ttu-id="5afe3-247">(これらの DDD パターンについては、*eShopOnContainers* の受注マイクロサービスの実装を説明するセクションで検討します)。</span><span class="sxs-lookup"><span data-stu-id="5afe3-247">(We will review these DDD patterns in the section later that explains the implementation of the *eShopOnContainers* ordering microservice.)</span></span>

<span data-ttu-id="5afe3-248">マイクロサービスごとに異なるテクノロジを使用する別の理由は、各マイクロサービスの性質です。</span><span class="sxs-lookup"><span data-stu-id="5afe3-248">Another reason for a different technology per microservice might be the nature of each microservice.</span></span> <span data-ttu-id="5afe3-249">たとえば、C\# のようなオブジェクト指向プログラミング言語ではなく、F\# のような関数型プログラミング言語や、AI と機械学習ドメインをターゲットにしている場合は R のような言語を使用するほうがふさわしい場合があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-249">For example, it might be better to use a functional programming language like F\#, or even a language like R if you are targeting AI and machine learning domains, instead of a more object-oriented programming language like C\#.</span></span>

<span data-ttu-id="5afe3-250">重要なのは、各マイクロサービスは、さまざまな設計パターンに基づいて異なる内部アーキテクチャを持つことができるということです。</span><span class="sxs-lookup"><span data-stu-id="5afe3-250">The bottom line is that each microservice can have a different internal architecture based on different design patterns.</span></span> <span data-ttu-id="5afe3-251">すべてのマイクロサービスを高度な DDD パターンを使用して実装する必要はありません。これを行うと、過剰エンジニア リングになります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-251">Not all microservices should be implemented using advanced DDD patterns, because that would be over-engineering them.</span></span> <span data-ttu-id="5afe3-252">同様に、常に変化するビジネス ロジックを使用する複雑なマイクロサービスは、CRUD コンポーネントとして実装すべきではありません。これを行うと、コードの質が低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-252">Similarly, complex microservices with ever-changing business logic should not be implemented as CRUD components, or you can end up with low-quality code.</span></span>

## <a name="the-new-world-multiple-architectural-patterns-and-polyglot-microservices"></a><span data-ttu-id="5afe3-253">新しい世界: 複数のアーキテクチャ パターンと多言語マイクロサービス</span><span class="sxs-lookup"><span data-stu-id="5afe3-253">The new world: multiple architectural patterns and polyglot microservices</span></span>

<span data-ttu-id="5afe3-254">ソフトウェア アーキテクトと開発者が使用するアーキテクチャ パターンは多数あります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-254">There are many architectural patterns used by software architects and developers.</span></span> <span data-ttu-id="5afe3-255">そのいくつかを次に示します (アーキテクチャ スタイルとアーキテクチャ パターンの混合)。</span><span class="sxs-lookup"><span data-stu-id="5afe3-255">The following are a few (mixing architecture styles and architecture patterns):</span></span>

- <span data-ttu-id="5afe3-256">単純な CRUD、単一階層、単一レイヤー。</span><span class="sxs-lookup"><span data-stu-id="5afe3-256">Simple CRUD, single-tier, single-layer.</span></span>

- <span data-ttu-id="5afe3-257">[従来の N レイヤー](https://docs.microsoft.com/previous-versions/msp-n-p/ee658109(v=pandp.10))。</span><span class="sxs-lookup"><span data-stu-id="5afe3-257">[Traditional N-Layered](https://docs.microsoft.com/previous-versions/msp-n-p/ee658109(v=pandp.10)).</span></span>

- <span data-ttu-id="5afe3-258">[ドメイン駆動設計の N レイヤー](https://devblogs.microsoft.com/cesardelatorre/published-first-alpha-version-of-domain-oriented-n-layered-architecture-v2-0/)。</span><span class="sxs-lookup"><span data-stu-id="5afe3-258">[Domain-Driven Design N-layered](https://devblogs.microsoft.com/cesardelatorre/published-first-alpha-version-of-domain-oriented-n-layered-architecture-v2-0/).</span></span>

- <span data-ttu-id="5afe3-259">[クリーン アーキテクチャ](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)([eShopOnWeb](https://aka.ms/WebAppArchitecture)で使用されています)</span><span class="sxs-lookup"><span data-stu-id="5afe3-259">[Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html) (as used with [eShopOnWeb](https://aka.ms/WebAppArchitecture))</span></span>

- <span data-ttu-id="5afe3-260">[コマンド クエリ責務分離](https://martinfowler.com/bliki/CQRS.html) (CQRS)。</span><span class="sxs-lookup"><span data-stu-id="5afe3-260">[Command and Query Responsibility Segregation](https://martinfowler.com/bliki/CQRS.html) (CQRS).</span></span>

- <span data-ttu-id="5afe3-261">[イベント駆動アーキテクチャ](https://en.wikipedia.org/wiki/Event-driven_architecture) (EDA)。</span><span class="sxs-lookup"><span data-stu-id="5afe3-261">[Event-Driven Architecture](https://en.wikipedia.org/wiki/Event-driven_architecture) (EDA).</span></span>

<span data-ttu-id="5afe3-262">マイクロサービスは、ASP.NET Core Web API、NancyFx、ASP.NET Core SignalR (.NET Core 2 で利用可能)、F\#、Node.js、Python、Java、C++、GoLang などのさまざまなテクノロジと言語を使用してビルドすることもできます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-262">You can also build microservices with many technologies and languages, such as ASP.NET Core Web APIs, NancyFx, ASP.NET Core SignalR (available with .NET Core 2), F\#, Node.js, Python, Java, C++, GoLang, and more.</span></span>

<span data-ttu-id="5afe3-263">重要な点は、すべての状況に適合する特定のアーキテクチャ パターン、アーキテクチャ スタイル、テクノロジは存在しないことです。</span><span class="sxs-lookup"><span data-stu-id="5afe3-263">The important point is that no particular architecture pattern or style, nor any particular technology, is right for all situations.</span></span> <span data-ttu-id="5afe3-264">図 6-3 は、さまざまなマイクロサービスで使用できる可能性があるいくつかのアプローチとテクノロジを示しています (順不同です)。</span><span class="sxs-lookup"><span data-stu-id="5afe3-264">Figure 6-3 shows some approaches and technologies (although not in any particular order) that could be used in different microservices.</span></span>

![多言語ワールド アーキテクチャの 12 の複雑なマイクロサービスを示す図。](./media/microservice-application-design/multi-architectural-patterns-polyglot-microservices.png)

<span data-ttu-id="5afe3-266">**図 6-3**。</span><span class="sxs-lookup"><span data-stu-id="5afe3-266">**Figure 6-3**.</span></span> <span data-ttu-id="5afe3-267">複数のアーキテクチャ パターンと多言語マイクロサービスの世界</span><span class="sxs-lookup"><span data-stu-id="5afe3-267">Multi-architectural patterns and the polyglot microservices world</span></span>

<span data-ttu-id="5afe3-268">複数のアーキテクチャ パターンと多言語マイクロサービスとは、言語とテクノロジを混合して、各マイクロサービスのニーズに一致させることができ、引き続き互いに通信できるということです。</span><span class="sxs-lookup"><span data-stu-id="5afe3-268">Multi-architectural pattern and polyglot microservices means you can mix and match languages and technologies to the needs of each microservice and still have them talking to each other.</span></span> <span data-ttu-id="5afe3-269">図 6-3 に示すように、多数のマイクロサービス (ドメイン駆動設計の用語では境界コンテキスト、自律型のマイクロサービスでは単に "サブシステム" と呼ばれます) で構成されるアプリケーションでは、各マイクロサービスを異なる方法で実装できます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-269">As shown in Figure 6-3, in applications composed of many microservices (Bounded Contexts in domain-driven design terminology, or simply "subsystems" as autonomous microservices), you might implement each microservice in a different way.</span></span> <span data-ttu-id="5afe3-270">それぞれのアーキテクチャ パターンは異なる場合があり、アプリケーションの性質、ビジネス要件、および優先度に応じて異なる言語とデータベースを使用できます。</span><span class="sxs-lookup"><span data-stu-id="5afe3-270">Each might have a different architecture pattern and use different languages and databases depending on the application's nature, business requirements, and priorities.</span></span> <span data-ttu-id="5afe3-271">場合によっては、複数のマイクロサービスが同じようになることがあります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-271">In some cases, the microservices might be similar.</span></span> <span data-ttu-id="5afe3-272">各サブシステムのコンテキスト境界と要件は通常異なっているため、通常はそのような状態にはなりません。</span><span class="sxs-lookup"><span data-stu-id="5afe3-272">But that is not usually the case, because each subsystem's context boundary and requirements are usually different.</span></span>

<span data-ttu-id="5afe3-273">たとえば、単純な CRUD メンテナンス アプリケーションは、DDD パターンを設計して実装しても意味はありません。</span><span class="sxs-lookup"><span data-stu-id="5afe3-273">For instance, for a simple CRUD maintenance application, it might not make sense to design and implement DDD patterns.</span></span> <span data-ttu-id="5afe3-274">ただし、中核となるドメインまたは主要業務では、絶えず変化するビジネス ルールとビジネスの複雑さに対応するために、より高度なパターンを適用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-274">But for your core domain or core business, you might need to apply more advanced patterns to tackle business complexity with ever-changing business rules.</span></span>

<span data-ttu-id="5afe3-275">特に、複数のサブシステムによって構成される大規模なアプリケーションを処理する場合は、1 つのアーキテクチャ パターンに基づく 1 つの最上位レベルのアーキテクチャを適用すべきではありません。</span><span class="sxs-lookup"><span data-stu-id="5afe3-275">Especially when you deal with large applications composed by multiple subsystems, you should not apply a single top-level architecture based on a single architecture pattern.</span></span> <span data-ttu-id="5afe3-276">たとえば、アプリケーション全体の最上位レベルのアーキテクチャとして CQRS を適用すべきではありませんが、CQRS は特定のサービス セットでは有用である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5afe3-276">For instance, CQRS should not be applied as a top-level architecture for a whole application, but might be useful for a specific set of services.</span></span>

<span data-ttu-id="5afe3-277">すべてのケースに対応できる特効薬のようなアーキテクチャ パターンは存在しません。</span><span class="sxs-lookup"><span data-stu-id="5afe3-277">There is no silver bullet or a right architecture pattern for every given case.</span></span> <span data-ttu-id="5afe3-278">"1 つのアーキテクチャ パターンですべてを統治する" ことはできません。</span><span class="sxs-lookup"><span data-stu-id="5afe3-278">You cannot have "one architecture pattern to rule them all."</span></span> <span data-ttu-id="5afe3-279">以降のセクションの説明に従って、各マイクロサービスの優先度に応じて、マイクロサービスごとに適切なアプローチを選択してください。</span><span class="sxs-lookup"><span data-stu-id="5afe3-279">Depending on the priorities of each microservice, you must choose a different approach for each, as explained in the following sections.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="5afe3-280">[前へ](index.md)
>[次へ](data-driven-crud-microservice.md)</span><span class="sxs-lookup"><span data-stu-id="5afe3-280">[Previous](index.md)
[Next](data-driven-crud-microservice.md)</span></span>
