---
title: マイクロサービスごとのデータベース
description: モノリシックアプリケーションとクラウドネイティブアプリケーションのデータストレージを比較します。
author: robvet
ms.date: 01/22/2020
ms.openlocfilehash: e472309d3dc815070fc2d2c220bf4fe00b8c29ae
ms.sourcegitcommit: 13e79efdbd589cad6b1de634f5d6b1262b12ab01
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/28/2020
ms.locfileid: "76795063"
---
# <a name="database-per-microservice"></a><span data-ttu-id="57be0-103">マイクロサービスごとのデータベース</span><span class="sxs-lookup"><span data-stu-id="57be0-103">Database-per-microservice</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="57be0-104">このブック全体で説明したように、クラウドネイティブアプローチは、アプリケーションの設計、展開、および管理の方法を変更します。</span><span class="sxs-lookup"><span data-stu-id="57be0-104">As we've seen throughout this book, a cloud-native approach changes the way you design, deploy, and manage applications.</span></span> <span data-ttu-id="57be0-105">また、データの管理と保存の方法も変わります。</span><span class="sxs-lookup"><span data-stu-id="57be0-105">It also changes the way you manage and store data.</span></span>

<span data-ttu-id="57be0-106">図5-1 は、違いを比較したものです。</span><span class="sxs-lookup"><span data-stu-id="57be0-106">Figure 5-1 contrasts the differences.</span></span>

![クラウドネイティブアプリケーションのデータストレージ](./media/distributed-data.png)

<span data-ttu-id="57be0-108">**図 5-1**.</span><span class="sxs-lookup"><span data-stu-id="57be0-108">**Figure 5-1**.</span></span> <span data-ttu-id="57be0-109">クラウドネイティブアプリケーションでのデータ管理</span><span class="sxs-lookup"><span data-stu-id="57be0-109">Data management in cloud-native applications</span></span>

<span data-ttu-id="57be0-110">経験豊富な開発者は、図5-1 の左側のアーキテクチャを簡単に認識できます。</span><span class="sxs-lookup"><span data-stu-id="57be0-110">Experienced developers will easily recognize the architecture on the left-side of figure 5-1.</span></span> <span data-ttu-id="57be0-111">この*モノリシックアプリケーション*では、ビジネスサービスコンポーネントは、1つのリレーショナルデータベースのデータを共有する共有サービス層に併置します。</span><span class="sxs-lookup"><span data-stu-id="57be0-111">In this *monolithic application*, business service components collocate together in a shared services tier, sharing data from a single relational database.</span></span>

<span data-ttu-id="57be0-112">多くの点で、1つのデータベースはデータ管理をシンプルに維持します。</span><span class="sxs-lookup"><span data-stu-id="57be0-112">In many ways, a single database keeps data management simple.</span></span> <span data-ttu-id="57be0-113">複数のテーブル間でのデータのクエリは簡単です。</span><span class="sxs-lookup"><span data-stu-id="57be0-113">Querying data across multiple tables is straightforward.</span></span> <span data-ttu-id="57be0-114">データ更新の変更またはすべてのロールバック</span><span class="sxs-lookup"><span data-stu-id="57be0-114">Changes to data update together or they all rollback.</span></span> <span data-ttu-id="57be0-115">[ACID トランザクション](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties)は、厳密かつ迅速な一貫性を保証します。</span><span class="sxs-lookup"><span data-stu-id="57be0-115">[ACID transactions](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) guarantee strong and immediate consistency.</span></span>

<span data-ttu-id="57be0-116">クラウドネイティブの設計では、別のアプローチを採用しています。</span><span class="sxs-lookup"><span data-stu-id="57be0-116">Designing for cloud-native, we take a different approach.</span></span> <span data-ttu-id="57be0-117">図5-1 の右側では、ビジネス機能が小規模で独立したマイクロサービスに分離になっていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="57be0-117">On the right-side of Figure 5-1, note how business functionality segregates into small, independent microservices.</span></span> <span data-ttu-id="57be0-118">各マイクロサービスは、特定のビジネス機能とその独自のデータをカプセル化します。</span><span class="sxs-lookup"><span data-stu-id="57be0-118">Each microservice encapsulates a specific business capability and its own data.</span></span> <span data-ttu-id="57be0-119">モノリシックデータベースは、それぞれがマイクロサービスに合わせて、多数の小さなデータベースを含む分散データモデルに分解されます。</span><span class="sxs-lookup"><span data-stu-id="57be0-119">The monolithic database decomposes into a distributed data model with many smaller databases, each aligning with a microservice.</span></span> <span data-ttu-id="57be0-120">スモークがクリアされると、*マイクロサービスごとにデータベース*を公開する設計が登場します。</span><span class="sxs-lookup"><span data-stu-id="57be0-120">When the smoke clears, we emerge with a design that exposes a *database per microservice*.</span></span>

## <a name="why"></a><span data-ttu-id="57be0-121">その理由については、</span><span class="sxs-lookup"><span data-stu-id="57be0-121">Why?</span></span>

<span data-ttu-id="57be0-122">マイクロサービスごとのこのデータベースには、特に、急速に進化して大規模なスケールをサポートする必要があるシステムに関して、多くのメリットがあります。</span><span class="sxs-lookup"><span data-stu-id="57be0-122">This database per microservice provides many benefits, especially for systems that must evolve rapidly and support massive scale.</span></span> <span data-ttu-id="57be0-123">このモデルでは...</span><span class="sxs-lookup"><span data-stu-id="57be0-123">With this model...</span></span>

- <span data-ttu-id="57be0-124">ドメインデータはサービス内にカプセル化されます。</span><span class="sxs-lookup"><span data-stu-id="57be0-124">Domain data is encapsulated within the service</span></span>
- <span data-ttu-id="57be0-125">データスキーマは、他のサービスに直接影響を与えることなく進化できます。</span><span class="sxs-lookup"><span data-stu-id="57be0-125">Data schema can evolve without directly impacting other services</span></span>
- <span data-ttu-id="57be0-126">各データストアは個別にスケーリングできます。</span><span class="sxs-lookup"><span data-stu-id="57be0-126">Each data store can independently scale</span></span>
- <span data-ttu-id="57be0-127">あるサービスでのデータストアの障害が他のサービスに直接影響することはない</span><span class="sxs-lookup"><span data-stu-id="57be0-127">A data store failure in one service won't directly impact other services</span></span>

<span data-ttu-id="57be0-128">また、データを分離することにより、各マイクロサービスは、ワークロード、ストレージのニーズ、および読み取り/書き込みパターンに最適に最適化されたデータストアの種類を実装できます。</span><span class="sxs-lookup"><span data-stu-id="57be0-128">Segregating data also enables each microservice to implement the data store type that is best optimized for its workload, storage needs, and read/write patterns.</span></span> <span data-ttu-id="57be0-129">選択肢としては、リレーショナル、ドキュメント、キー値、さらにはグラフベースのデータストアなどがあります。</span><span class="sxs-lookup"><span data-stu-id="57be0-129">Choices include relational, document, key-value, and even graph-based data stores.</span></span>

<span data-ttu-id="57be0-130">図5-2 は、クラウドネイティブシステムの多言語永続化の原則を示しています。</span><span class="sxs-lookup"><span data-stu-id="57be0-130">Figure 5-2 presents the principle of polyglot persistence in a cloud-native system.</span></span>

![多言語データ永続化](./media/polyglot-data-persistence.png)

<span data-ttu-id="57be0-132">**図 5-2**</span><span class="sxs-lookup"><span data-stu-id="57be0-132">**Figure 5-2**.</span></span> <span data-ttu-id="57be0-133">多言語データ永続化</span><span class="sxs-lookup"><span data-stu-id="57be0-133">Polyglot data persistence</span></span>

<span data-ttu-id="57be0-134">前の図では、各マイクロサービスが異なる種類のデータストアをサポートしていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="57be0-134">Note in the previous figure how each microservice supports a different type of data store.</span></span>

- <span data-ttu-id="57be0-135">製品カタログマイクロサービスは、基になるデータの豊富なリレーショナル構造に対応するためにリレーショナルデータベースを消費します。</span><span class="sxs-lookup"><span data-stu-id="57be0-135">The product catalog microservice consumes a relational database to accommodate the rich relational structure of its underlying data.</span></span>
- <span data-ttu-id="57be0-136">ショッピングカートマイクロサービスは、単純なキー値データストアをサポートする分散キャッシュを消費します。</span><span class="sxs-lookup"><span data-stu-id="57be0-136">The shopping cart microservice consumes a distributed cache that supports its simple, key-value data store.</span></span>
- <span data-ttu-id="57be0-137">注文マイクロサービスは、書き込み操作に NoSql ドキュメントデータベースを使用し、高度な非正規化キー/値ストアを使用して、大量の読み取り操作に対応します。</span><span class="sxs-lookup"><span data-stu-id="57be0-137">The ordering microservice consumes both a NoSql document database for write operations along with a highly denormalized key/value store to accommodate high-volumes of read operations.</span></span>
  
<span data-ttu-id="57be0-138">リレーショナルデータベースは、複雑なデータを含むマイクロサービスに関連していますが、NoSQL データベースでは非常に人気があります。</span><span class="sxs-lookup"><span data-stu-id="57be0-138">While relational databases remain relevant for microservices with complex data, NoSQL databases have gained considerable popularity.</span></span> <span data-ttu-id="57be0-139">大規模で高可用性を実現します。</span><span class="sxs-lookup"><span data-stu-id="57be0-139">They provide massive scale and high availability.</span></span> <span data-ttu-id="57be0-140">これらのスキーマを使用すると、開発者は、型指定されたデータクラスのアーキテクチャから移動したり、変更をコストのかかる時間がかかるようにしたりすることができます。</span><span class="sxs-lookup"><span data-stu-id="57be0-140">Their schemaless nature allows developers to move away from an architecture of typed data classes and ORMs that make change expensive and time-consuming.</span></span> <span data-ttu-id="57be0-141">NoSQL データベースについては、この章で後ほど説明します。</span><span class="sxs-lookup"><span data-stu-id="57be0-141">We cover NoSQL databases later in this chapter.</span></span>

 <span data-ttu-id="57be0-142">データを個別のマイクロサービスにカプセル化すると、機敏性、パフォーマンス、スケーラビリティが向上しますが、多くの課題があります。</span><span class="sxs-lookup"><span data-stu-id="57be0-142">While encapsulating  data into separate microservices can increase agility, performance, and scalability, it also presents many challenges.</span></span> <span data-ttu-id="57be0-143">次のセクションでは、これらの課題と、それらを克服するためのパターンとプラクティスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="57be0-143">In the next section, we discuss these challenges along with patterns and practices to help overcome them.</span></span>  

## <a name="cross-service-queries"></a><span data-ttu-id="57be0-144">クロスサービスクエリ</span><span class="sxs-lookup"><span data-stu-id="57be0-144">Cross-service queries</span></span>

<span data-ttu-id="57be0-145">マイクロサービスは独立しており、在庫、出荷、注文などの特定の機能機能に焦点を当てていますが、多くの場合、他のマイクロサービスとの統合が必要になります。</span><span class="sxs-lookup"><span data-stu-id="57be0-145">While microservices are independent and focus on specific functional capabilities, like inventory, shipping, or ordering, they frequently require integration with other microservices.</span></span> <span data-ttu-id="57be0-146">多くの場合、統合には、データに対して別のマイクロサービスに*クエリ*を実行することが含まれます。</span><span class="sxs-lookup"><span data-stu-id="57be0-146">Often the integration involves one microservice *querying* another for data.</span></span> <span data-ttu-id="57be0-147">図5-3 は、このシナリオを示しています。</span><span class="sxs-lookup"><span data-stu-id="57be0-147">Figure 5-3 shows the scenario.</span></span>

![マイクロサービス間でのクエリ](./media/cross-service-query.png)

<span data-ttu-id="57be0-149">**図 5-3**</span><span class="sxs-lookup"><span data-stu-id="57be0-149">**Figure 5-3**.</span></span> <span data-ttu-id="57be0-150">マイクロサービス間でのクエリ</span><span class="sxs-lookup"><span data-stu-id="57be0-150">Querying across microservices</span></span>

<span data-ttu-id="57be0-151">前の図には、ユーザーのショッピングバスケットに項目を追加するショッピングバスケットマイクロサービスがあります。</span><span class="sxs-lookup"><span data-stu-id="57be0-151">In the preceding figure, we see a shopping basket microservice that adds an item to a user's shopping basket.</span></span> <span data-ttu-id="57be0-152">このマイクロサービスのデータストアには、バスケットと品目のデータが含まれていますが、製品や価格のデータは保持されません。</span><span class="sxs-lookup"><span data-stu-id="57be0-152">While the data store for this microservice contains basket and line item data, it doesn't maintain product or pricing data.</span></span> <span data-ttu-id="57be0-153">代わりに、これらのデータ項目はカタログと料金マイクロサービスによって所有されます。</span><span class="sxs-lookup"><span data-stu-id="57be0-153">Instead, those data items are owned by the catalog and pricing microservices.</span></span> <span data-ttu-id="57be0-154">これにより、問題が発生します。</span><span class="sxs-lookup"><span data-stu-id="57be0-154">This presents a problem.</span></span> <span data-ttu-id="57be0-155">製品や価格データがデータベースに含まれていない場合、買い物かごマイクロサービスで製品をユーザーのショッピングバスケットに追加するにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="57be0-155">How can the shopping basket microservice add a product to the user's shopping basket when it doesn't have product nor pricing data in its database?</span></span>

<span data-ttu-id="57be0-156">第4章で説明されている1つのオプションは、ショッピングカートからカタログおよび料金マイクロサービスへの[直接 HTTP 呼び出し](service-to-service-communication.md#queries)です。</span><span class="sxs-lookup"><span data-stu-id="57be0-156">One option discussed in Chapter 4 is a [direct HTTP call](service-to-service-communication.md#queries) from the shopping basket to the catalog and pricing microservices.</span></span> <span data-ttu-id="57be0-157">ただし、第4章では、 *1 つのマイクロサービス*に対して同期 HTTP 呼び出しを行っています。これにより、自律性が減少し、アーキテクチャ上のメリットが低下します。</span><span class="sxs-lookup"><span data-stu-id="57be0-157">However, in chapter 4, we said synchronous HTTP calls *couple* microservices together, reducing their autonomy and diminishing their architectural benefits.</span></span>

<span data-ttu-id="57be0-158">また、各サービスに対して個別の受信キューと出力キューを使用して、要求/応答パターンを実装することもできます。</span><span class="sxs-lookup"><span data-stu-id="57be0-158">We could also implement a request-reply pattern with separate inbound and outbound queues for each service.</span></span> <span data-ttu-id="57be0-159">ただし、このパターンは複雑で、要求メッセージと応答メッセージを関連付けるためにプラミングが必要です。</span><span class="sxs-lookup"><span data-stu-id="57be0-159">However, this pattern is complicated and requires plumbing to correlate request and response messages.</span></span>
<span data-ttu-id="57be0-160">バックエンドマイクロサービス呼び出しを分離しますが、呼び出しが完了するまで、呼び出し元のサービスは同期的に待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="57be0-160">While it does decouple the backend microservice calls, the calling service must still synchronously wait for the call to complete.</span></span> <span data-ttu-id="57be0-161">ネットワークの輻輳、一時的なエラー、またはオーバーロードされたマイクロサービスによって、実行時間が長く、操作が失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="57be0-161">Network congestion, transient faults, or an overloaded microservice and can result in long-running and even failed operations.</span></span>

<span data-ttu-id="57be0-162">代わりに、図5-4 に示すように、サービス間の依存関係を削除するために広く使用されているパターンが具体化された[ビューパターン](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)となります。</span><span class="sxs-lookup"><span data-stu-id="57be0-162">Instead, a widely accepted pattern for removing cross-service dependencies is the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-4.</span></span>

![具体化ビューパターン](./media/materialized-view-pattern.png)

<span data-ttu-id="57be0-164">**図 5-4**</span><span class="sxs-lookup"><span data-stu-id="57be0-164">**Figure 5-4**.</span></span> <span data-ttu-id="57be0-165">具体化ビューパターン</span><span class="sxs-lookup"><span data-stu-id="57be0-165">Materialized View Pattern</span></span>

<span data-ttu-id="57be0-166">このパターンでは、買い物かごサービスにローカルデータテーブル (*読み取りモデル*と呼ばれます) を配置します。</span><span class="sxs-lookup"><span data-stu-id="57be0-166">With this pattern, you place a local data table (known as a *read model*) in the shopping basket service.</span></span> <span data-ttu-id="57be0-167">このテーブルには、製品および料金マイクロサービスに必要なデータの非正規化されたコピーが含まれています。</span><span class="sxs-lookup"><span data-stu-id="57be0-167">This table contains a denormalized copy of the data needed from the product and pricing microservices.</span></span> <span data-ttu-id="57be0-168">ショッピングカートマイクロサービスにデータを直接コピーすることで、高価なクロスサービス呼び出しが不要になります。</span><span class="sxs-lookup"><span data-stu-id="57be0-168">Copying the data directly into the shopping basket microservice eliminates the need for expensive cross-service calls.</span></span> <span data-ttu-id="57be0-169">サービスに対してローカルなデータを使用すると、サービスの応答時間と信頼性が向上します。</span><span class="sxs-lookup"><span data-stu-id="57be0-169">With the data local to the service, you improve the service's response time and reliability.</span></span> <span data-ttu-id="57be0-170">さらに、独自のデータコピーを用意することにより、買い物かごサービスの回復性が向上します。</span><span class="sxs-lookup"><span data-stu-id="57be0-170">Additionally, having its own copy of the data makes the shopping basket service more resilient.</span></span> <span data-ttu-id="57be0-171">カタログサービスが使用できなくなると、買い物かごサービスに直接影響することはありません。</span><span class="sxs-lookup"><span data-stu-id="57be0-171">If the catalog service should become unavailable, it wouldn't directly impact the shopping basket service.</span></span> <span data-ttu-id="57be0-172">ショッピングカートは、独自のストアのデータを操作し続けることができます。</span><span class="sxs-lookup"><span data-stu-id="57be0-172">The shopping basket can continue operating with the data from its own store.</span></span> 

<span data-ttu-id="57be0-173">このアプローチを使用すると、システム内に重複するデータが存在することになります。</span><span class="sxs-lookup"><span data-stu-id="57be0-173">The catch with this approach is that you now have duplicate data in your system.</span></span> <span data-ttu-id="57be0-174">ただし、クラウドネイティブシステムで*戦略的*にデータを複製することは、確立された手法であり、アンチパターンや悪い慣習とは見なされません。</span><span class="sxs-lookup"><span data-stu-id="57be0-174">However, *strategically* duplicating data in cloud-native systems is an established practice and not considered an anti-pattern, or bad practice.</span></span> <span data-ttu-id="57be0-175">1*つのサービスのみ*がデータセットを所有し、それに対する権限を持つことができることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="57be0-175">Keep in mind that *one and only one service* can own a data set and have authority over it.</span></span> <span data-ttu-id="57be0-176">レコードのシステムが更新されたときに、読み取りモデルを同期する必要があります。</span><span class="sxs-lookup"><span data-stu-id="57be0-176">You'll need to synchronize the read models when the system of record is updated.</span></span> <span data-ttu-id="57be0-177">同期は通常、[発行/サブスクライブパターン](service-to-service-communication.md#events)を使用した非同期メッセージングによって実装されます (図5.4 を参照)。</span><span class="sxs-lookup"><span data-stu-id="57be0-177">Synchronization is typically implemented via asynchronous messaging with a [publish/subscribe pattern](service-to-service-communication.md#events), as shown in Figure 5.4.</span></span>

## <a name="distributed-transactions"></a><span data-ttu-id="57be0-178">分散トランザクション</span><span class="sxs-lookup"><span data-stu-id="57be0-178">Distributed transactions</span></span>

<span data-ttu-id="57be0-179">マイクロサービス間でデータのクエリを実行することは困難ですが、複数のマイクロサービスにトランザクションを実装することは、さらに複雑になります。</span><span class="sxs-lookup"><span data-stu-id="57be0-179">While querying data across microservices is difficult, implementing a transaction across several microservices is even more complex.</span></span> <span data-ttu-id="57be0-180">異なるマイクロサービスの独立したデータソース間でデータの一貫性を維持するための固有の課題を袖口することはできません。</span><span class="sxs-lookup"><span data-stu-id="57be0-180">The inherent challenge of maintaining data consistency across independent data sources in different microservices can't be understated.</span></span> <span data-ttu-id="57be0-181">クラウドネイティブアプリケーションでの分散トランザクションの欠如は、分散トランザクションをプログラムによって管理する必要があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="57be0-181">The lack of distributed transactions in cloud-native applications means that you must manage distributed transactions programmatically.</span></span> <span data-ttu-id="57be0-182">*一貫性*のある世界から、*最終的な整合性*に移行します。</span><span class="sxs-lookup"><span data-stu-id="57be0-182">You move from a world of *immediate consistency* to that of *eventual consistency*.</span></span>

<span data-ttu-id="57be0-183">図5-5 は、この問題を示しています。</span><span class="sxs-lookup"><span data-stu-id="57be0-183">Figure 5-5 shows the problem.</span></span>

![Saga パターンでのトランザクション](./media/saga-transaction-operation.png)

<span data-ttu-id="57be0-185">**図 5-5**</span><span class="sxs-lookup"><span data-stu-id="57be0-185">**Figure 5-5**.</span></span> <span data-ttu-id="57be0-186">マイクロサービス間でのトランザクションの実装</span><span class="sxs-lookup"><span data-stu-id="57be0-186">Implementing a transaction across microservices</span></span>

<span data-ttu-id="57be0-187">前の図では、5つの独立したマイクロサービスが、注文を作成する分散トランザクションに参加しています。</span><span class="sxs-lookup"><span data-stu-id="57be0-187">In the preceding figure, five independent microservices participate in a distributed transaction that creates an order.</span></span> <span data-ttu-id="57be0-188">各マイクロサービスは、独自のデータストアを保持し、そのストアのローカルトランザクションを実装します。</span><span class="sxs-lookup"><span data-stu-id="57be0-188">Each microservice maintains its own data store and implements a local transaction for its store.</span></span> <span data-ttu-id="57be0-189">注文を作成するには *、個々のマイクロサービスのローカル*トランザクションが成功する必要があります。これを行わないと、操作を中止してロール*バックする必要があります*。</span><span class="sxs-lookup"><span data-stu-id="57be0-189">To create the order, the local transaction for *each* individual microservice must succeed, or *all* must abort and roll back the operation.</span></span> <span data-ttu-id="57be0-190">組み込みのトランザクションサポートは各マイクロサービス内で利用できますが、データの整合性を維持するために、5つのサービスすべてにわたって分散トランザクションがサポートされているわけではありません。</span><span class="sxs-lookup"><span data-stu-id="57be0-190">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction that would span across all five services to keep data consistent.</span></span>

<span data-ttu-id="57be0-191">代わりに、この分散トランザクションを*プログラム*で構築する必要があります。</span><span class="sxs-lookup"><span data-stu-id="57be0-191">Instead, you must construct this distributed transaction *programmatically*.</span></span>

<span data-ttu-id="57be0-192">分散トランザクションサポートを追加するための一般的なパターンは、Saga パターンです。</span><span class="sxs-lookup"><span data-stu-id="57be0-192">A popular pattern for adding distributed transactional support is the Saga pattern.</span></span> <span data-ttu-id="57be0-193">ローカルトランザクションをプログラムによってグループ化し、それぞれを順番に呼び出すことによって実装されます。</span><span class="sxs-lookup"><span data-stu-id="57be0-193">It's implemented by grouping local transactions together programmatically and sequentially invoking each one.</span></span> <span data-ttu-id="57be0-194">ローカルトランザクションのいずれかが失敗した場合、Saga は操作を中止し、一連の[補正トランザクション](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="57be0-194">If any of the local transactions fail, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction).</span></span> <span data-ttu-id="57be0-195">補正トランザクションは、前のローカルトランザクションによって行われた変更を元に戻し、データの整合性を復元します。</span><span class="sxs-lookup"><span data-stu-id="57be0-195">The compensating transactions undo the changes made by the preceding local transactions and restore data consistency.</span></span> <span data-ttu-id="57be0-196">図5-6 は、Saga パターンを使用した失敗したトランザクションを示しています。</span><span class="sxs-lookup"><span data-stu-id="57be0-196">Figure 5-6 shows a failed transaction with the Saga pattern.</span></span>

![Saga パターンでロールバックする](./media/saga-rollback-operation.png)

<span data-ttu-id="57be0-198">**図 5-6**.</span><span class="sxs-lookup"><span data-stu-id="57be0-198">**Figure 5-6**.</span></span> <span data-ttu-id="57be0-199">トランザクションのロールバック</span><span class="sxs-lookup"><span data-stu-id="57be0-199">Rolling back a transaction</span></span>

<span data-ttu-id="57be0-200">前の図では、インベントリマイクロサービスでの*インベントリの更新*操作が失敗しました。</span><span class="sxs-lookup"><span data-stu-id="57be0-200">In the previous figure, the *Update Inventory* operation has failed in the Inventory microservice.</span></span> <span data-ttu-id="57be0-201">Saga は、補正トランザクション (赤) のセットを呼び出して、在庫数を調整し、支払いと注文を取り消し、各マイクロサービスのデータを一貫性のある状態に戻します。</span><span class="sxs-lookup"><span data-stu-id="57be0-201">The Saga invokes a set of compensating transactions (in red) to adjust the inventory counts, cancel the payment and the order, and return the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="57be0-202">Saga パターンは、通常、関連する一連のイベントとして choreographed されるか、関連する一連のコマンドとして調整されます。</span><span class="sxs-lookup"><span data-stu-id="57be0-202">Saga patterns are typically choreographed as a series of related events, or orchestrated as a set of related commands.</span></span> <span data-ttu-id="57be0-203">4章では、調整された saga 実装の基盤となるサービスアグリゲーターパターンについて説明しました。</span><span class="sxs-lookup"><span data-stu-id="57be0-203">In Chapter 4, we discussed the service aggregator pattern that would be the foundation for an orchestrated saga implementation.</span></span> <span data-ttu-id="57be0-204">また、イベントと共に Azure Service Bus と、choreographed saga の実装の基礎となるトピック Azure Event Grid についても説明しました。</span><span class="sxs-lookup"><span data-stu-id="57be0-204">We also discussed eventing along with Azure Service Bus and Azure Event Grid topics that would be a foundation for a choreographed saga implementation.</span></span>

## <a name="high-volume-data"></a><span data-ttu-id="57be0-205">大量のデータ</span><span class="sxs-lookup"><span data-stu-id="57be0-205">High volume data</span></span>

<span data-ttu-id="57be0-206">大規模なクラウドネイティブアプリケーションは、多くの場合、大量のデータ要件をサポートします。</span><span class="sxs-lookup"><span data-stu-id="57be0-206">Large cloud-native applications often support high-volume data requirements.</span></span> <span data-ttu-id="57be0-207">このようなシナリオでは、従来のデータストレージ手法によってボトルネックが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="57be0-207">In these scenarios, traditional data storage techniques can cause bottlenecks.</span></span> <span data-ttu-id="57be0-208">大規模な環境に配置する複雑なシステムでは、コマンドクエリ責務分離 (CQRS) とイベントソーシングの両方で、アプリケーションのパフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="57be0-208">For complex systems that deploy on a large scale, both Command and Query Responsibility Segregation (CQRS) and Event Sourcing may improve application performance.</span></span>  

### <a name="cqrs"></a><span data-ttu-id="57be0-209">CQRS</span><span class="sxs-lookup"><span data-stu-id="57be0-209">CQRS</span></span>

<span data-ttu-id="57be0-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs)は、パフォーマンス、スケーラビリティ、およびセキュリティを最大化するのに役立つアーキテクチャパターンです。</span><span class="sxs-lookup"><span data-stu-id="57be0-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that can help maximize performance, scalability, and security.</span></span> <span data-ttu-id="57be0-211">このパターンでは、データを書き込む操作からデータを読み取る操作を分離します。</span><span class="sxs-lookup"><span data-stu-id="57be0-211">The pattern separates operations that read data from those operations that write data.</span></span> 

<span data-ttu-id="57be0-212">通常のシナリオでは、同じエンティティモデルとデータリポジトリオブジェクトが読み取り操作と書き込み操作の*両方*に使用されます。</span><span class="sxs-lookup"><span data-stu-id="57be0-212">For normal scenarios, the same entity model and data repository object are used for *both* read and write operations.</span></span>

<span data-ttu-id="57be0-213">ただし、大量のデータを使用するシナリオでは、読み取りと書き込みのために個別のモデルとデータテーブルを利用できます。</span><span class="sxs-lookup"><span data-stu-id="57be0-213">However, a high volume data scenario can benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="57be0-214">パフォーマンスを向上させるために、読み取り操作では、負荷の高いテーブル結合やテーブルロックを避けるために、データの非常に非正規化された表現に対してクエリを実行できます。</span><span class="sxs-lookup"><span data-stu-id="57be0-214">To improve performance, the read operation could query against a highly denormalized representation of the data to avoid expensive repetitive table joins and table locks.</span></span> <span data-ttu-id="57be0-215">*書き込み*操作は、*コマンド*と呼ばれ、一貫性を保証するデータの完全に正規化された表現に対して更新されます。</span><span class="sxs-lookup"><span data-stu-id="57be0-215">The *write* operation, known as a *command*, would update against a fully normalized representation of the data that would guarantee consistency.</span></span> <span data-ttu-id="57be0-216">次に、両方の表現を同期させておくためのメカニズムを実装する必要があります。通常、書き込みテーブルが変更されるたびに、その変更を読み取りテーブルにレプリケートするイベントが発行されます。</span><span class="sxs-lookup"><span data-stu-id="57be0-216">You then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it publishes an event that replicates the modification to the read table.</span></span>

<span data-ttu-id="57be0-217">図5-7 は、CQRS パターンの実装を示しています。</span><span class="sxs-lookup"><span data-stu-id="57be0-217">Figure 5-7 shows an implementation of the CQRS pattern.</span></span>

![コマンド クエリ責務分離](./media/cqrs-implementation.png)

<span data-ttu-id="57be0-219">**図 5-7**</span><span class="sxs-lookup"><span data-stu-id="57be0-219">**Figure 5-7**.</span></span> <span data-ttu-id="57be0-220">CQRS の実装</span><span class="sxs-lookup"><span data-stu-id="57be0-220">CQRS implementation</span></span>

<span data-ttu-id="57be0-221">前の図では、個別のコマンドモデルとクエリモデルが実装されています。</span><span class="sxs-lookup"><span data-stu-id="57be0-221">In the previous figure, separate command and query models are implemented.</span></span> <span data-ttu-id="57be0-222">各データ書き込み操作は、書き込みストアに保存され、読み取りストアに反映されます。</span><span class="sxs-lookup"><span data-stu-id="57be0-222">Each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="57be0-223">[最終的な整合性](http://www.cloudcomputingpatterns.org/eventual_consistency/)の原則でデータ伝達プロセスがどのように動作するかに注意してください。</span><span class="sxs-lookup"><span data-stu-id="57be0-223">Pay close attention to how the data propagation process operates on the principle of [eventual consistency](http://www.cloudcomputingpatterns.org/eventual_consistency/).</span></span> <span data-ttu-id="57be0-224">読み取りモデルは、最終的に書き込みモデルと同期しますが、プロセスに遅延が発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="57be0-224">The read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span> <span data-ttu-id="57be0-225">最終的な整合性については、次のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="57be0-225">We discuss eventual consistency in the next section.</span></span>

<span data-ttu-id="57be0-226">この分離により、読み取りと書き込みを個別にスケーリングできます。</span><span class="sxs-lookup"><span data-stu-id="57be0-226">This separation enables reads and writes to scale independently.</span></span> <span data-ttu-id="57be0-227">読み取り操作では、クエリ用に最適化されたスキーマを使用します。書き込みでは、更新に対して最適化されたスキーマが使用されます。</span><span class="sxs-lookup"><span data-stu-id="57be0-227">Read operations use a schema optimized for queries, while the writes use a schema optimized for updates.</span></span> <span data-ttu-id="57be0-228">読み取りクエリは非正規化されたデータに対して行われますが、複雑なビジネスロジックを書き込みモデルに適用することができます。</span><span class="sxs-lookup"><span data-stu-id="57be0-228">Read queries go against denormalized data, while complex business logic can be applied to the write model.</span></span> <span data-ttu-id="57be0-229">また、読み取りを公開するよりも書き込み操作に対してセキュリティを強化することもできます。</span><span class="sxs-lookup"><span data-stu-id="57be0-229">As well, you might impose tighter security on write operations than those exposing reads.</span></span>

<span data-ttu-id="57be0-230">CQRS を実装することで、クラウドネイティブサービスのアプリケーションパフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="57be0-230">Implementing CQRS can improve application performance for cloud-native services.</span></span> <span data-ttu-id="57be0-231">ただし、より複雑な設計になります。</span><span class="sxs-lookup"><span data-stu-id="57be0-231">However, it does result in a more complex design.</span></span> <span data-ttu-id="57be0-232">この原則は、クラウドネイティブアプリケーションのこれらのセクションに慎重かつ戦略的に適用して、それを活用します。</span><span class="sxs-lookup"><span data-stu-id="57be0-232">Apply this principle carefully and strategically to those sections of your cloud-native application that will benefit from it.</span></span> <span data-ttu-id="57be0-233">CQRS の詳細については、「Microsoft book [.Net マイクロサービス: コンテナー化された .Net アプリケーションのアーキテクチャ](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="57be0-233">For more on CQRS, see the Microsoft book [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span></span>

### <a name="event-sourcing"></a><span data-ttu-id="57be0-234">イベントソーシング</span><span class="sxs-lookup"><span data-stu-id="57be0-234">Event sourcing</span></span>

<span data-ttu-id="57be0-235">大量のデータを最適化するための別の方法として、[イベントソーシング](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing)があります。</span><span class="sxs-lookup"><span data-stu-id="57be0-235">Another approach to optimizing high volume data scenarios involves [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span></span>

<span data-ttu-id="57be0-236">システムは通常、データエンティティの現在の状態を格納します。</span><span class="sxs-lookup"><span data-stu-id="57be0-236">A system typically stores the current state of a data entity.</span></span> <span data-ttu-id="57be0-237">たとえば、ユーザーが電話番号を変更した場合、顧客レコードは新しい番号で更新されます。</span><span class="sxs-lookup"><span data-stu-id="57be0-237">If a user changes their phone number, for example, the customer record is updated with the new number.</span></span> <span data-ttu-id="57be0-238">データエンティティの現在の状態は常にわかっていますが、更新ごとに前の状態が上書きされます。</span><span class="sxs-lookup"><span data-stu-id="57be0-238">We always know the current state of a data entity, but each update overwrites the previous state.</span></span> 

<span data-ttu-id="57be0-239">ほとんどの場合、このモデルは正常に動作します。</span><span class="sxs-lookup"><span data-stu-id="57be0-239">In most cases, this model works fine.</span></span> <span data-ttu-id="57be0-240">ただし、大量のシステムでは、トランザクションロックや頻繁な更新操作のオーバーヘッドによって、データベースのパフォーマンス、応答性、スケーラビリティの制限が影響を受ける可能性があります。</span><span class="sxs-lookup"><span data-stu-id="57be0-240">In high volume systems, however, overhead from transactional locking and frequent update operations can impact database performance, responsiveness, and limit scalability.</span></span>

<span data-ttu-id="57be0-241">イベントソーシングは、データをキャプチャするための別のアプローチを取ります。</span><span class="sxs-lookup"><span data-stu-id="57be0-241">Event Sourcing takes a different approach to capturing data.</span></span> <span data-ttu-id="57be0-242">データに影響を与える各操作は、イベントストアに保存されます。</span><span class="sxs-lookup"><span data-stu-id="57be0-242">Each operation that affects data is persisted to an event store.</span></span> <span data-ttu-id="57be0-243">データレコードの状態を更新する代わりに、会計士の台帳と同様に、各変更を過去のイベントの連続するリストに追加します。</span><span class="sxs-lookup"><span data-stu-id="57be0-243">Instead of updating the state of a data record, we append each change to a sequential list of past events - similar to an accountant's ledger.</span></span> <span data-ttu-id="57be0-244">イベントストアは、データのレコードのシステムになります。</span><span class="sxs-lookup"><span data-stu-id="57be0-244">The Event Store becomes the system of record for the data.</span></span> <span data-ttu-id="57be0-245">これは、マイクロサービスの境界コンテキスト内で、具体化されたさまざまなビューを伝達するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="57be0-245">It's used to propagate various materialized views within the bounded context of a microservice.</span></span> <span data-ttu-id="57be0-246">図5.8 は、パターンを示しています。</span><span class="sxs-lookup"><span data-stu-id="57be0-246">Figure 5.8 shows the pattern.</span></span>

![イベントソーシング](./media/event-sourcing.png)

<span data-ttu-id="57be0-248">**図 5-8**.</span><span class="sxs-lookup"><span data-stu-id="57be0-248">**Figure 5-8**.</span></span> <span data-ttu-id="57be0-249">イベントソーシング</span><span class="sxs-lookup"><span data-stu-id="57be0-249">Event Sourcing</span></span>

<span data-ttu-id="57be0-250">前の図では、ユーザーのショッピングカートの各エントリ (blue) が、基になるイベントストアに追加されていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="57be0-250">In the previous figure, note how each entry (in blue) for a user's shopping cart is appended to an underlying event store.</span></span> <span data-ttu-id="57be0-251">隣接する具体化されたビューでは、各ショッピングカートに関連付けられているすべてのイベントを再生することにより、現在の状態がプロジェクトによって射影されます。</span><span class="sxs-lookup"><span data-stu-id="57be0-251">In the adjoining materialized view, the system projects the current state by replaying all the events associated with each shopping cart.</span></span> <span data-ttu-id="57be0-252">このビューまたは読み取りモデルは、UI に再び表示されます。</span><span class="sxs-lookup"><span data-stu-id="57be0-252">This view, or read model, is then exposed back to the UI.</span></span> <span data-ttu-id="57be0-253">イベントは、外部のシステムやアプリケーションと統合したり、クエリを実行してエンティティの現在の状態を確認したりすることもできます。</span><span class="sxs-lookup"><span data-stu-id="57be0-253">Events can also be integrated with external systems and applications or queried to determine the current state of an entity.</span></span> <span data-ttu-id="57be0-254">この方法では、履歴を保持します。</span><span class="sxs-lookup"><span data-stu-id="57be0-254">With this approach, you maintain history.</span></span> <span data-ttu-id="57be0-255">エンティティの現在の状態だけでなく、この状態に到達したこともわかっています。</span><span class="sxs-lookup"><span data-stu-id="57be0-255">You know not only the current state of an entity, but also how you reached this state.</span></span>

<span data-ttu-id="57be0-256">機械的は、イベントソーシングは書き込みモデルを簡略化します。</span><span class="sxs-lookup"><span data-stu-id="57be0-256">Mechanically speaking, event sourcing simplifies the write model.</span></span> <span data-ttu-id="57be0-257">更新または削除はありません。</span><span class="sxs-lookup"><span data-stu-id="57be0-257">There are no updates or deletes.</span></span> <span data-ttu-id="57be0-258">各データエントリを不変イベントとして追加すると、リレーショナルデータベースに関連付けられている競合、ロック、および同時実行の競合を最小限に抑えることができます。</span><span class="sxs-lookup"><span data-stu-id="57be0-258">Appending each data entry as an immutable event minimizes contention, locking, and concurrency conflicts associated with relational databases.</span></span> <span data-ttu-id="57be0-259">具体化されたビューパターンを使用して読み取りモデルを構築すると、書き込みモデルからビューを切り離し、最適なデータストアを選択してアプリケーションの UI のニーズを最適化することができます。</span><span class="sxs-lookup"><span data-stu-id="57be0-259">Building read models with the materialized view pattern enables you to decouple the view from the write model and choose the best data store to optimize the needs of your application UI.</span></span>

<span data-ttu-id="57be0-260">このパターンでは、イベントソーシングを直接サポートするデータストアを考えてみます。</span><span class="sxs-lookup"><span data-stu-id="57be0-260">For this pattern, consider a data store that directly supports event sourcing.</span></span> <span data-ttu-id="57be0-261">Azure Cosmos DB、MongoDB、Cassandra、CouchDB、RavenDB は適切な候補です。</span><span class="sxs-lookup"><span data-stu-id="57be0-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB, and RavenDB are good candidates.</span></span>

<span data-ttu-id="57be0-262">すべてのパターンとテクノロジと同様に、必要に応じて戦略的に実装します。</span><span class="sxs-lookup"><span data-stu-id="57be0-262">As with all patterns and technologies, implement strategically and when needed.</span></span> <span data-ttu-id="57be0-263">イベントソーシングは、パフォーマンスとスケーラビリティを向上させることができますが、複雑さと学習曲線を犠牲にしています。</span><span class="sxs-lookup"><span data-stu-id="57be0-263">While event sourcing can provide increased performance and scalability, it comes at the expense of complexity and a learning curve.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="57be0-264">[前へ](service-mesh-communication-infrastructure.md)
>[次へ](relational-vs-nosql-data.md)</span><span class="sxs-lookup"><span data-stu-id="57be0-264">[Previous](service-mesh-communication-infrastructure.md)
[Next](relational-vs-nosql-data.md)</span></span>
