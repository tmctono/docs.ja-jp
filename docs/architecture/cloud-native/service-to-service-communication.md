---
title: サービス間の通信
description: バックエンドクラウドネイティブマイクロサービスが他のバックエンドマイクロサービスと通信する方法について説明します。
author: robvet
ms.date: 09/09/2019
ms.openlocfilehash: a5124b8b83f62ff17b1230ead63db26e0c1f2a5b
ms.sourcegitcommit: 7f8eeef060ddeb2cabfa52843776faf652c5a1f5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/14/2019
ms.locfileid: "74087597"
---
# <a name="service-to-service-communication"></a><span data-ttu-id="9c0ca-103">サービス間の通信</span><span class="sxs-lookup"><span data-stu-id="9c0ca-103">Service-to-service communication</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="9c0ca-104">フロントエンドクライアントから、バックエンドマイクロサービスが相互に通信できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-104">Moving from the front-end client, we now address back-end microservices communicate with each other.</span></span>

<span data-ttu-id="9c0ca-105">クラウドネイティブアプリケーションを構築する場合は、バックエンドサービスが相互に通信する方法を区別する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-105">When constructing a cloud-native application, you'll want to be sensitive to how back-end services communicate with each other.</span></span> <span data-ttu-id="9c0ca-106">理想的には、サービス間の通信が少なくて済むということです。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-106">Ideally, the less inter-service communication, the better.</span></span> <span data-ttu-id="9c0ca-107">ただし、バックエンドサービスが操作を完了するために相互に依存していることが多いため、回避することは常に可能であるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-107">However, avoidance isn't always possible as back-end services often rely on one another to complete an operation.</span></span>

<span data-ttu-id="9c0ca-108">サービス間通信の実装には、広く受け入れられている方法がいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-108">There are several widely accepted approaches to implementing cross-service communication.</span></span> <span data-ttu-id="9c0ca-109">多くの場合、*通信の相互作用の種類*によって最適な方法が決定されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-109">The *type of communication interaction* will often determine the best approach.</span></span>

<span data-ttu-id="9c0ca-110">次のような相互作用の種類を考えてみます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-110">Consider the following interaction types:</span></span>

- <span data-ttu-id="9c0ca-111">*クエリ*–呼び出し側のマイクロサービスが、"特定の顧客 Id の購入者情報を提供します" など、呼び出されたマイクロサービスからの応答を必要とする場合。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-111">*Query* – when a calling microservice requires a response from a called microservice, such as, "Hey, give me the buyer information for a given customer Id."</span></span>

- <span data-ttu-id="9c0ca-112">*コマンド*–呼び出しを行うマイクロサービスが、アクションを実行するために別のマイクロサービスを必要としているが、応答を必要としない場合 (この注文を発送するだけです)。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-112">*Command* – when the calling microservice needs another microservice to execute an action but doesn't require a response, such as, "Hey, just ship this order."</span></span>

- <span data-ttu-id="9c0ca-113">*イベント*–発行元と呼ばれるマイクロサービスが、状態が変更されたか、アクションが発生したことを示すイベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-113">*Event* – when a microservice, called the publisher, raises an event that state has changed or an action has occurred.</span></span> <span data-ttu-id="9c0ca-114">サブスクライバーと呼ばれるその他のマイクロサービスは、イベントに適切に反応できます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-114">Other microservices, called subscribers, who are interested, can react to the event appropriately.</span></span> <span data-ttu-id="9c0ca-115">パブリッシャーとサブスクライバーが互いを認識していません。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-115">The publisher and the subscribers aren't aware of each other.</span></span>

<span data-ttu-id="9c0ca-116">マイクロサービスシステムは、通常、サービス間の対話を必要とする操作を実行するときに、これらの相互作用の種類を組み合わせて使用します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-116">Microservice systems typically use a combination of these interaction types when executing operations that require cross-service interaction.</span></span> <span data-ttu-id="9c0ca-117">それぞれの方法と、それらを実装する方法について詳しく見ていきましょう。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-117">Let's take a close look at each and how you might implement them.</span></span>

## <a name="queries"></a><span data-ttu-id="9c0ca-118">クエリ</span><span class="sxs-lookup"><span data-stu-id="9c0ca-118">Queries</span></span>

<span data-ttu-id="9c0ca-119">多くの場合、1つのマイクロサービスが別のマイクロサービスに*クエリ*を実行し、操作を完了するために直ちに対応する必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-119">Many times, one microservice might need to *query* another, requiring an immediate response to complete an operation.</span></span> <span data-ttu-id="9c0ca-120">買い物かごマイクロサービスでは、商品情報と、バスケットに商品を追加するための料金が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-120">A shopping basket microservice may need product information and a price to add an item to its basket.</span></span> <span data-ttu-id="9c0ca-121">クエリ操作を実装するには、いくつかの方法があります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-121">There are a number of approaches for implementing query operations.</span></span>

### <a name="requestresponse-messaging"></a><span data-ttu-id="9c0ca-122">要求/応答メッセージング</span><span class="sxs-lookup"><span data-stu-id="9c0ca-122">Request/Response Messaging</span></span>

<span data-ttu-id="9c0ca-123">このシナリオを実装するための1つのオプションは、図4-8 に示すように、バックエンドマイクロサービスを呼び出して、クエリを実行する必要があるマイクロサービスに対して HTTP 要求を直接実行することです。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-123">One option for implementing this scenario is for the calling back-end microservice to make direct HTTP requests to the microservices it needs to query, shown in Figure 4-8.</span></span>

![直接 HTTP 通信](./media/direct-http-communication.png)

<span data-ttu-id="9c0ca-125">**図 4-8**</span><span class="sxs-lookup"><span data-stu-id="9c0ca-125">**Figure 4-8**.</span></span> <span data-ttu-id="9c0ca-126">直接 HTTP 通信</span><span class="sxs-lookup"><span data-stu-id="9c0ca-126">Direct HTTP communication</span></span>

<span data-ttu-id="9c0ca-127">マイクロサービス間の直接 HTTP 呼び出しを実装するのは比較的簡単ですが、この方法を最小限に抑えるために注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-127">While direct HTTP calls between microservices are relatively simple to implement, care should be taken to minimize this practice.</span></span> <span data-ttu-id="9c0ca-128">を開始するために、これらの呼び出しは常に*同期*的であり、結果が返されるか、または要求がタイムアウトするまで、操作をブロックします。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-128">To start, these calls are always *synchronous* and will block the operation until a result is returned or the request times outs.</span></span> <span data-ttu-id="9c0ca-129">自己完結型、独立したサービス、個別に進化し、頻繁に展開できることは、相互に結合されるようになりました。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-129">What were once self-contained, independent services, able to evolve independently and deploy frequently, now become coupled to each other.</span></span> <span data-ttu-id="9c0ca-130">マイクロサービス間の結合が増加するにつれて、アーキテクチャ上のメリットが減少します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-130">As coupling among microservices increase, their architectural benefits diminish.</span></span>

<span data-ttu-id="9c0ca-131">別のマイクロサービスに対して単一の直接 HTTP 呼び出しを行う頻度の低い要求を実行すると、一部のシステムで許容される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-131">Executing an infrequent request that makes a single direct HTTP call to another microservice might be acceptable for some systems.</span></span> <span data-ttu-id="9c0ca-132">ただし、複数のマイクロサービスに対して直接 HTTP 呼び出しを呼び出す大量の呼び出しは推奨されません。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-132">However, high-volume calls that invoke direct HTTP calls to multiple microservices aren't advisable.</span></span> <span data-ttu-id="9c0ca-133">待機時間が長くなり、システムのパフォーマンス、スケーラビリティ、可用性に悪影響を及ぼす可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-133">They can increase latency and negatively impact the performance, scalability, and availability of your system.</span></span> <span data-ttu-id="9c0ca-134">さらに悪いことに、次の図4-9 に示すように、長い一連の直接 HTTP 通信によって、同期マイクロサービス呼び出しの深いチェーンが複雑になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-134">Even worse, a long series of direct HTTP communication can lead to deep and complex chains of synchronous microservices calls, shown in Figure 4-9:</span></span>

![HTTP クエリのチェーン](./media/chaining-http-queries.png)

<span data-ttu-id="9c0ca-136">**図 4-9**</span><span class="sxs-lookup"><span data-stu-id="9c0ca-136">**Figure 4-9**.</span></span> <span data-ttu-id="9c0ca-137">HTTP クエリのチェーン</span><span class="sxs-lookup"><span data-stu-id="9c0ca-137">Chaining HTTP queries</span></span>

<span data-ttu-id="9c0ca-138">前の図に示されている設計のリスクを考えてみてください。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-138">You can certainly imagine the risk in the design shown in the previous image.</span></span> <span data-ttu-id="9c0ca-139">手順 \#3 でエラーが発生した場合はどうなりますか。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-139">What happens if Step \#3 fails?</span></span> <span data-ttu-id="9c0ca-140">または、手順 \#8 に失敗しますか?</span><span class="sxs-lookup"><span data-stu-id="9c0ca-140">Or Step \#8 fails?</span></span> <span data-ttu-id="9c0ca-141">どのように回復すればよいですか。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-141">How do you recover?</span></span> <span data-ttu-id="9c0ca-142">基になるサービスがビジー状態になっているために、ステップ \#6 が遅い場合はどうなりますか。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-142">What if Step \#6 is slow because the underlying service is busy?</span></span> <span data-ttu-id="9c0ca-143">続行するにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-143">How do you continue?</span></span> <span data-ttu-id="9c0ca-144">すべてが正しく動作する場合でも、この呼び出しで発生する待機時間を考慮してください。これは、各ステップの待機時間の合計です。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-144">Even if all works correctly, think of the latency this call would incur, which is the sum of the latency of each step.</span></span>

<span data-ttu-id="9c0ca-145">前の図に示した大規模な結合により、サービスが最適にモデル化されていないことがわかります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-145">The large degree of coupling in the previous image suggests the services weren't optimally modeled.</span></span> <span data-ttu-id="9c0ca-146">チームによる設計の見直しに behoove ます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-146">It would behoove the team to revisit their design.</span></span>

### <a name="materialized-view-pattern"></a><span data-ttu-id="9c0ca-147">具体化ビューパターン</span><span class="sxs-lookup"><span data-stu-id="9c0ca-147">Materialized View pattern</span></span>

<span data-ttu-id="9c0ca-148">マイクロサービスの結合を削除するための一般的なオプションは、具体化された[ビューパターン](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)です。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-148">A popular option for removing microservice coupling is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="9c0ca-149">このパターンでは、マイクロサービスは、他のサービスによって所有されている独自のローカルの非正規化されたデータのコピーを格納します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-149">With this pattern, a microservice stores its own local, denormalized copy of data that's owned by other services.</span></span> <span data-ttu-id="9c0ca-150">製品カタログと料金マイクロサービスを照会するショッピングバスケットマイクロサービスではなく、そのデータのローカルコピーを保持します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-150">Instead of the Shopping Basket microservice querying the Product Catalog and Pricing microservices, it maintains its own local copy of that data.</span></span> <span data-ttu-id="9c0ca-151">このパターンは、不要な結合を排除し、信頼性と応答時間を向上させます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-151">This pattern eliminates unnecessary coupling and improves reliability and response time.</span></span> <span data-ttu-id="9c0ca-152">操作全体が1つのプロセス内で実行されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-152">The entire operation executes inside a single process.</span></span> <span data-ttu-id="9c0ca-153">このパターンと、5章のその他のデータの問題について説明します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-153">We explore this pattern and other data concerns in Chapter 5.</span></span>

### <a name="service-aggregator-pattern"></a><span data-ttu-id="9c0ca-154">サービスアグリゲーターパターン</span><span class="sxs-lookup"><span data-stu-id="9c0ca-154">Service Aggregator Pattern</span></span>

<span data-ttu-id="9c0ca-155">マイクロサービスからマイクロサービスへの結合を排除するもう1つのオプションは、図4-10 の紫色の[マイクロサービス](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/)です。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-155">Another option for eliminating microservice-to-microservice coupling is an [Aggregator microservice](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/), shown in purple in Figure 4-10.</span></span>

![アグリゲーターサービス](./media/aggregator-service.png)

<span data-ttu-id="9c0ca-157">**図 4-10**</span><span class="sxs-lookup"><span data-stu-id="9c0ca-157">**Figure 4-10**.</span></span> <span data-ttu-id="9c0ca-158">アグリゲーターマイクロサービス</span><span class="sxs-lookup"><span data-stu-id="9c0ca-158">Aggregator microservice</span></span>

<span data-ttu-id="9c0ca-159">このパターンは、複数のバックエンドマイクロサービスへの呼び出しを行う操作を分離し、そのロジックを専用のマイクロサービスに一元化します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-159">The pattern isolates an operation that makes calls to multiple back-end microservices, centralizing its logic into a specialized microservice.</span></span>  <span data-ttu-id="9c0ca-160">前の図の紫色のチェックアウトアグリゲーターマイクロサービスは、チェックアウト操作のワークフローを調整します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-160">The purple checkout aggregator microservice in the previous figure orchestrates the workflow for the Checkout operation.</span></span> <span data-ttu-id="9c0ca-161">シーケンス処理された順序で、複数のバックエンドマイクロサービスを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-161">It includes calls to several back-end microservices in a sequenced order.</span></span> <span data-ttu-id="9c0ca-162">ワークフローからのデータが集計され、呼び出し元に返されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-162">Data from the workflow is aggregated and returned to the caller.</span></span> <span data-ttu-id="9c0ca-163">直接の HTTP 呼び出しを実装しますが、アグリゲーターマイクロサービスは、バックエンドマイクロサービス間の直接的な依存関係を減らします。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-163">While it still implements direct HTTP calls, the aggregator microservice reduces direct dependencies among back-end microservices.</span></span>

### <a name="requestreply-pattern"></a><span data-ttu-id="9c0ca-164">要求/応答パターン</span><span class="sxs-lookup"><span data-stu-id="9c0ca-164">Request/Reply Pattern</span></span>

<span data-ttu-id="9c0ca-165">同期 HTTP メッセージを分離するためのもう1つの方法は、キュー通信を使用する[要求/応答パターン](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html)です。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-165">Another approach for decoupling synchronous HTTP messages is a [Request-Reply Pattern](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html), which uses queuing communication.</span></span> <span data-ttu-id="9c0ca-166">キューを使用した通信は、常に一方向のチャネルであり、プロデューサーがメッセージを送信し、コンシューマーがメッセージを受信します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-166">Communication using a queue is always a one-way channel, with a producer sending the message and consumer receiving it.</span></span> <span data-ttu-id="9c0ca-167">このパターンでは、図4-11 に示すように、要求キューと応答キューの両方が実装されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-167">With this pattern, both a request queue and response queue are implemented, shown in Figure 4-11.</span></span>

![要求/応答パターン](./media/request-reply-pattern.png)

<span data-ttu-id="9c0ca-169">**図 4-11**</span><span class="sxs-lookup"><span data-stu-id="9c0ca-169">**Figure 4-11**.</span></span> <span data-ttu-id="9c0ca-170">要求/応答パターン</span><span class="sxs-lookup"><span data-stu-id="9c0ca-170">Request-reply pattern</span></span>

<span data-ttu-id="9c0ca-171">ここでは、メッセージプロデューサーが一意の相関 ID を含むクエリベースのメッセージを作成し、それを要求キューに配置します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-171">Here, the message producer creates a query-based message that contains a unique correlation ID and places it into a request queue.</span></span> <span data-ttu-id="9c0ca-172">コンシューマーサービスはメッセージをデキューし、処理して応答を同じ相関 ID を持つ応答キューに配置します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-172">The consuming service dequeues the messages, processes it and places the response into the response queue with the same correlation ID.</span></span> <span data-ttu-id="9c0ca-173">プロデューサーサービスはメッセージをデキューし、関連付け ID と照合して処理を続行します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-173">The producer service dequeues the message, matches it with the correlation ID and continues processing.</span></span> <span data-ttu-id="9c0ca-174">キューについては、次のセクションで詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-174">We cover queues in detail in the next section.</span></span>

## <a name="commands"></a><span data-ttu-id="9c0ca-175">コマンド</span><span class="sxs-lookup"><span data-stu-id="9c0ca-175">Commands</span></span>

<span data-ttu-id="9c0ca-176">別の種類の通信相互作用は*コマンド*です。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-176">Another type of communication interaction is a *command*.</span></span> <span data-ttu-id="9c0ca-177">マイクロサービスでは、アクションを実行するために別のマイクロサービスが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-177">A microservice may need another microservice to perform an action.</span></span> <span data-ttu-id="9c0ca-178">注文マイクロサービスでは、承認された注文の発送を作成するために出荷マイクロサービスが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-178">The Ordering microservice may need the Shipping microservice to create a shipment for an approved order.</span></span> <span data-ttu-id="9c0ca-179">図4-12 では、プロデューサーと呼ばれる1つのマイクロサービスが、別のマイクロサービス (コンシューマー) にメッセージを送信して、処理を実行しています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-179">In Figure 4-12, one microservice, called a Producer, sends a message to another microservice, the Consumer, commanding it to do something.</span></span>

![コマンドとキューのやり取り](./media/command-interaction-with-queue.png)

<span data-ttu-id="9c0ca-181">**図 4-12**.</span><span class="sxs-lookup"><span data-stu-id="9c0ca-181">**Figure 4-12**.</span></span> <span data-ttu-id="9c0ca-182">コマンドとキューのやり取り</span><span class="sxs-lookup"><span data-stu-id="9c0ca-182">Command interaction with a queue</span></span>

<span data-ttu-id="9c0ca-183">ほとんどの場合、プロデューサーは応答を必要とせず、メッセージを*起動し忘れ*てしまう可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-183">Most often, the Producer doesn't require a response and can *fire-and-forget* the message.</span></span> <span data-ttu-id="9c0ca-184">応答が必要な場合、コンシューマーは別のチャネルでプロデューサーに別のメッセージを送り返します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-184">If a reply is needed, the Consumer sends a separate message back to Producer on another channel.</span></span> <span data-ttu-id="9c0ca-185">コマンドメッセージは、メッセージキューを使用して非同期に送信することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-185">A command message is best sent asynchronously with a message queue.</span></span> <span data-ttu-id="9c0ca-186">ライトウェイトメッセージブローカーでサポートされます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-186">supported by a lightweight message broker.</span></span> <span data-ttu-id="9c0ca-187">前の図では、キューが両方のサービスを分離および分離する方法に注意してください。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-187">In the previous diagram, note how a queue separates and decouples both services.</span></span>

<span data-ttu-id="9c0ca-188">メッセージキューは、プロデューサーとコンシューマーがメッセージを渡す中間構造です。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-188">A message queue is an intermediary construct through which a producer and consumer pass a message.</span></span> <span data-ttu-id="9c0ca-189">キューは、非同期のポイントツーポイントのメッセージングパターンを実装します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-189">Queues implement an asynchronous, point-to-point messaging pattern.</span></span> <span data-ttu-id="9c0ca-190">プロデューサーは、コマンドを送信する必要がある場所を認識し、適切にルーティングします。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-190">The Producer knows where a command needs to be sent and routes appropriately.</span></span> <span data-ttu-id="9c0ca-191">キューは、チャネルから読み取るコンシューマーインスタンスの1つだけがメッセージを処理することを保証します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-191">The queue guarantees that a message is processed by exactly one of the consumer instances that are reading from the channel.</span></span> <span data-ttu-id="9c0ca-192">このシナリオでは、プロデューサーまたはコンシューマーサービスは、もう一方に影響を与えずにスケールアウトできます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-192">In this scenario, either the producer or consumer service can scale out without affecting the other.</span></span> <span data-ttu-id="9c0ca-193">また、テクノロジは互いに異なる場合があります。つまり、Java マイクロサービスが[Golang](https://golang.org)マイクロサービスを呼び出す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-193">As well, technologies can be disparate on each side, meaning that we might have a Java microservice calling a [Golang](https://golang.org) microservice.</span></span>

<span data-ttu-id="9c0ca-194">第1章では、*サービスのバックアップ*について説明しました。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-194">In chapter 1, we talked about *backing services*.</span></span> <span data-ttu-id="9c0ca-195">バッキングサービスは、クラウドネイティブシステムが依存する補助的なリソースです。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-195">Backing services are ancillary resources upon which cloud-native systems depend.</span></span> <span data-ttu-id="9c0ca-196">メッセージキューは、バッキングサービスです。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-196">Message queues are backing services.</span></span> <span data-ttu-id="9c0ca-197">Azure クラウドでは、クラウドネイティブシステムがコマンドメッセージングを実装するために使用できる2種類のメッセージキューをサポートしています。 Azure Storage キューと Azure Service Bus キューです。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-197">The Azure cloud supports two types of message queues that your cloud-native systems can consume to implement command messaging: Azure Storage Queues and Azure Service Bus Queues.</span></span>

### <a name="azure-storage-queues"></a><span data-ttu-id="9c0ca-198">Azure Storage キュー</span><span class="sxs-lookup"><span data-stu-id="9c0ca-198">Azure Storage Queues</span></span>

<span data-ttu-id="9c0ca-199">Azure storage キューは、Azure ストレージアカウントによってサポートされる、高速で手頃な価格の単純なキューインフラストラクチャを提供します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-199">Azure storage queues offer a simple queueing infrastructure that is fast, affordable, and backed by Azure storage accounts.</span></span>

<span data-ttu-id="9c0ca-200">[Azure Storage キュー](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction)は、信頼性の高い永続的なメッセージング機能を備えた REST ベースのキューメカニズムを備えています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-200">[Azure Storage Queues](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) feature a REST-based queuing mechanism with reliable and persistent messaging.</span></span> <span data-ttu-id="9c0ca-201">これらは最小限の機能セットを提供しますが、安価で、数百万のメッセージを格納します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-201">They provide a minimal feature set, but are inexpensive and store millions of messages.</span></span> <span data-ttu-id="9c0ca-202">容量の範囲は最大 500 TB です。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-202">Their capacity ranges up to 500 TB.</span></span> <span data-ttu-id="9c0ca-203">1つのメッセージのサイズは最大 64 KB です。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-203">A single message can be up to 64 KB in size.</span></span>

<span data-ttu-id="9c0ca-204">HTTP または HTTPS を使用した認証された呼び出しを介して、世界中のどこからでもメッセージにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-204">You can access messages from anywhere in the world via authenticated calls using HTTP or HTTPS.</span></span> <span data-ttu-id="9c0ca-205">ストレージキューは、多数の同時実行クライアントにスケールアウトして、トラフィックの急増に対応できます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-205">Storage queues can scale out to large numbers of concurrent clients to handle traffic spikes.</span></span>

<span data-ttu-id="9c0ca-206">ただし、サービスには制限があります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-206">That said, there are limitations with the service:</span></span>

- <span data-ttu-id="9c0ca-207">メッセージの順序は保証されません。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-207">Message order isn't guaranteed.</span></span>

- <span data-ttu-id="9c0ca-208">メッセージは、自動的に削除される7日間だけ保持できます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-208">A message can only persist for seven days before it's automatically removed.</span></span>

- <span data-ttu-id="9c0ca-209">状態管理、重複検出、またはトランザクションのサポートは使用できません。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-209">Support for state management, duplicate detection, or transactions isn't available.</span></span>

<span data-ttu-id="9c0ca-210">図4-13 は、Azure Storage キューの階層を示しています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-210">Figure 4-13 shows the hierarchy of an Azure Storage Queue.</span></span>

![ストレージキューの階層](./media/storage-queue-hierarchy.png)

<span data-ttu-id="9c0ca-212">**図 4-13**.</span><span class="sxs-lookup"><span data-stu-id="9c0ca-212">**Figure 4-13**.</span></span> <span data-ttu-id="9c0ca-213">ストレージキューの階層</span><span class="sxs-lookup"><span data-stu-id="9c0ca-213">Storage queue hierarchy</span></span>

<span data-ttu-id="9c0ca-214">前の図では、storage キューによって、基になる Azure Storage アカウントにメッセージがどのように格納されているかを確認してください。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-214">In the previous figure, note how storage queues store their messages in the underlying Azure Storage account.</span></span>

<span data-ttu-id="9c0ca-215">開発者向けに、Microsoft では、ストレージキュー処理用のクライアントとサーバー側のライブラリをいくつか提供しています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-215">For developers, Microsoft provides several client and server-side libraries for Storage queue processing.</span></span> <span data-ttu-id="9c0ca-216">.NET、Java、JavaScript、Ruby、Python、およびゴーを含むほとんどの主要なプラットフォームがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-216">Most major platforms are supported including .NET, Java, JavaScript, Ruby, Python, and Go.</span></span> <span data-ttu-id="9c0ca-217">開発者は、これらのライブラリと直接通信することはできません。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-217">Developers should never communicate directly with these libraries.</span></span> <span data-ttu-id="9c0ca-218">これにより、マイクロサービスコードが Azure Storage Queue サービスに密に結合されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-218">Doing so will tightly couple your microservice code to the Azure Storage Queue service.</span></span> <span data-ttu-id="9c0ca-219">API の実装の詳細を分離することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-219">It's a better practice to insulate the implementation details of the API.</span></span> <span data-ttu-id="9c0ca-220">汎用操作を公開し、具象ライブラリをカプセル化する intermediation レイヤー (中間 API) を導入します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-220">Introduce an intermediation layer, or intermediate API, that exposes generic operations and encapsulates the concrete library.</span></span> <span data-ttu-id="9c0ca-221">この疎結合により、メインラインサービスコードを変更することなく、1つのキューサービスを別のキューサービスにスワップアウトできます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-221">This loose coupling enables you to swap out one queuing service for another without having to make changes to the mainline service code.</span></span>

<span data-ttu-id="9c0ca-222">Azure Storage キューは、クラウドネイティブアプリケーションにコマンドメッセージングを実装するための経済的なオプションです。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-222">Azure Storage queues are an economical option to implement command messaging in your cloud-native applications.</span></span> <span data-ttu-id="9c0ca-223">特に、キューのサイズが 80 GB を超える場合や、単純な機能セットが許容される場合です。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-223">Especially when a queue size will exceed 80 GB, or a simple feature set is acceptable.</span></span> <span data-ttu-id="9c0ca-224">料金は、メッセージのストレージに対してのみ課金されます。時間単位の固定料金はありません。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-224">You only pay for the storage of the messages; there are no fixed hourly charges.</span></span>

### <a name="azure-service-bus-queues"></a><span data-ttu-id="9c0ca-225">Azure Service Bus キュー</span><span class="sxs-lookup"><span data-stu-id="9c0ca-225">Azure Service Bus Queues</span></span>

<span data-ttu-id="9c0ca-226">より複雑なメッセージング要件については、Azure Service Bus キューを検討してください。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-226">For more complex messaging requirements, consider Azure Service Bus queues.</span></span>

<span data-ttu-id="9c0ca-227">[Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview)は、堅牢なメッセージインフラストラクチャを構築しています。*仲介型メッセージングモデル*がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-227">Sitting atop a robust message infrastructure, [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) supports a *brokered messaging model*.</span></span> <span data-ttu-id="9c0ca-228">メッセージは、コンシューマーによって受信されるまで、ブローカー (キュー) に確実に格納されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-228">Messages are reliably stored in a broker (the queue) until received by the consumer.</span></span> <span data-ttu-id="9c0ca-229">キューは、メッセージがキューに追加された順序に従って、先入れ先出し (FIFO) のメッセージ配信を保証します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-229">The queue guarantees First-In/First-Out (FIFO) message delivery, respecting the order in which messages were added to the queue.</span></span>

<span data-ttu-id="9c0ca-230">メッセージのサイズは、最大 256 KB まで、非常に大きくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-230">The size of a message can be much larger, up to 256 KB.</span></span> <span data-ttu-id="9c0ca-231">メッセージは、無期限にキューに保持されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-231">Messages are persisted in the queue for an unlimited period of time.</span></span> <span data-ttu-id="9c0ca-232">Service Bus は、HTTP ベースの呼び出しだけでなく、 [AMPQ プロトコル](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview)の完全なサポートも提供します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-232">Service Bus supports not only HTTP-based calls, but also provides full support for the [AMPQ protocol](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview).</span></span> <span data-ttu-id="9c0ca-233">AMPQ は、バイナリプロトコルと高い信頼性をサポートするベンダー全体のオープン標準です。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-233">AMPQ is an open-standard across vendors that supports a binary protocol and higher degrees of reliability.</span></span>

<span data-ttu-id="9c0ca-234">Service Bus には、[トランザクションのサポート](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)や[重複検出機能](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)など、豊富な機能セットが用意されています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-234">Service Bus provides a rich set of features, including [transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) and a [duplicate detection feature](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection).</span></span> <span data-ttu-id="9c0ca-235">キューは、メッセージごとに "最大で1回の配信" を保証します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-235">The queue guarantees "at most once delivery" per message.</span></span> <span data-ttu-id="9c0ca-236">既に送信済みのメッセージは自動的に破棄されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-236">It automatically discards a message that has already been sent.</span></span> <span data-ttu-id="9c0ca-237">プロデューサーが不明な場合は、同じメッセージを再送信し、1つのコピーのみが処理されることを保証 Service Bus ます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-237">If a producer is in doubt, it can resend the same message, and Service Bus guarantees that only one copy will be processed.</span></span> <span data-ttu-id="9c0ca-238">重複検出を使用すると、インフラストラクチャの追加の組み込みを構築する必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-238">Duplicate detection frees you from  having to build additional infrastructure plumbing.</span></span>

<span data-ttu-id="9c0ca-239">さらに、パーティション分割とセッションという2つのエンタープライズ機能があります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-239">Two more enterprise features are partitioning and sessions.</span></span> <span data-ttu-id="9c0ca-240">従来の Service Bus キューは、1つのメッセージブローカーによって処理され、1つのメッセージストアに格納されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-240">A conventional Service Bus queue is handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="9c0ca-241">ただし、 [Service Bus パーティション分割](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning)では、複数のメッセージブローカーとメッセージストアにキューを分散します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-241">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) spreads the queue across multiple message brokers and message stores.</span></span> <span data-ttu-id="9c0ca-242">全体のスループットは、1つのメッセージブローカーまたはメッセージングストアのパフォーマンスによって制限されなくなりました。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-242">The overall throughput is no longer limited by the performance of a single message broker or messaging store.</span></span> <span data-ttu-id="9c0ca-243">メッセージングストアが一時的に停止しても、パーティション分割されたキューは表示されません。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-243">A temporary outage of a messaging store doesn't render a partitioned queue unavailable.</span></span>

<span data-ttu-id="9c0ca-244">[Service Bus セッション](https://codingcanvas.com/azure-service-bus-sessions/)は、グループに関連するメッセージの方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-244">[Service Bus Sessions](https://codingcanvas.com/azure-service-bus-sessions/) provide a way to group-related messages.</span></span> <span data-ttu-id="9c0ca-245">メッセージをまとめて処理し、最後に操作を完了するワークフローシナリオを想像してみてください。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-245">Imagine a workflow scenario where messages must be processed together and the operation completed at the end.</span></span> <span data-ttu-id="9c0ca-246">利用するには、キューに対してセッションを明示的に有効にする必要があります。また、関連する各メッセージに同じセッション ID が含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-246">To take advantage, sessions must be explicitly enabled for the queue and each related messaged must contain the same session ID.</span></span>

<span data-ttu-id="9c0ca-247">ただし、いくつかの重要な注意点があります。 Service Bus キューのサイズは 80 GB に制限されています。これは、ストアキューで使用できるものよりもはるかに小さくなっています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-247">However, there are some important caveats: Service Bus queues size is limited to 80 GB, which is much smaller than what's available from store queues.</span></span> <span data-ttu-id="9c0ca-248">また、Service Bus キューには、操作ごとに基本コストと料金が発生します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-248">Additionally, Service Bus queues incur a base cost and charge per operation.</span></span>

<span data-ttu-id="9c0ca-249">図4-14 は、Service Bus キューのアーキテクチャの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-249">Figure 4-14 outlines the high-level architecture of a Service Bus queue.</span></span>

![Service Bus キュー](./media/service-bus-queue.png)

<span data-ttu-id="9c0ca-251">**図 4-14**.</span><span class="sxs-lookup"><span data-stu-id="9c0ca-251">**Figure 4-14**.</span></span> <span data-ttu-id="9c0ca-252">Service Bus キュー</span><span class="sxs-lookup"><span data-stu-id="9c0ca-252">Service Bus queue</span></span>

<span data-ttu-id="9c0ca-253">前の図では、ポイントツーポイントの関係に注意してください。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-253">In the previous figure, note the point-to-point relationship.</span></span> <span data-ttu-id="9c0ca-254">同じプロバイダーの2つのインスタンスは、メッセージを1つの Service Bus キューにエンキューします。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-254">Two instances of the same provider are enqueuing messages into a single Service Bus queue.</span></span> <span data-ttu-id="9c0ca-255">各メッセージは、右側にある3つのコンシューマーインスタンスのうちの1つのみによって使用されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-255">Each message is consumed by only one of three consumer instances on the right.</span></span> <span data-ttu-id="9c0ca-256">次に、さまざまなコンシューマーが同じメッセージに関心を持つ可能性があるメッセージングを実装する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-256">Next, we discuss how to implement messaging where different consumers may all be interested the same message.</span></span>

## <a name="events"></a><span data-ttu-id="9c0ca-257">イベント</span><span class="sxs-lookup"><span data-stu-id="9c0ca-257">Events</span></span>

<span data-ttu-id="9c0ca-258">メッセージキューは、プロデューサーがコンシューマーにメッセージを非同期に送信できる通信を実装するための効果的な方法です。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-258">Message queuing is an effective way to implement communication where a producer can asynchronously send a consumer a message.</span></span> <span data-ttu-id="9c0ca-259">しかし、同じメッセージに*多くの異なるコンシューマー*が関心を持っている場合はどうなるでしょうか。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-259">However, what happens when *many different consumers* are interested in the same message?</span></span> <span data-ttu-id="9c0ca-260">コンシューマーごとに専用のメッセージキューが拡張されることはなく、管理が困難になります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-260">A dedicated message queue for each consumer wouldn't scale well and would become difficult to manage.</span></span>

<span data-ttu-id="9c0ca-261">このシナリオに対処するために、メッセージの相互作用 (*イベント*) の3番目の種類に移ります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-261">To address this scenario, we move to the third type of message interaction, the *event*.</span></span> <span data-ttu-id="9c0ca-262">1つのマイクロサービスによってアクションが発生したことが通知されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-262">One microservice announces that an action had occurred.</span></span> <span data-ttu-id="9c0ca-263">他のマイクロサービス (関心がある場合) は、アクションまたはイベントに反応します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-263">Other microservices, if interested, react to the action, or event.</span></span>

<span data-ttu-id="9c0ca-264">イベント処理は2段階のプロセスです。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-264">Eventing is a two-step process.</span></span> <span data-ttu-id="9c0ca-265">特定の状態の変更に対して、マイクロサービスはイベントをメッセージブローカに発行し、他の任意のマイクロサービスで使用できるようにします。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-265">For a given state change, a microservice publishes an event to a message broker, making it available to any other interested microservice.</span></span> <span data-ttu-id="9c0ca-266">関心のあるマイクロサービスは、メッセージブローカーでイベントをサブスクライブすることによって通知されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-266">The interested microservice is notified by subscribing to the event in the message broker.</span></span> <span data-ttu-id="9c0ca-267">[イベントベースの通信](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications)を実装するには、[発行/サブスクライブ](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber)パターンを使用します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-267">You use the [Publish/Subscribe](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber) pattern to implement [event-based communication](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications).</span></span>

<span data-ttu-id="9c0ca-268">図4-15 は、2つの他のマイクロサービスがサブスクライブしているイベントを発行する買い物かごマイクロサービスを示しています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-268">Figure 4-15 shows a shopping basket microservice publishing an event with two other microservices subscribing to it.</span></span>

![イベントドリブンメッセージング](./media/event-driven-messaging.png)

<span data-ttu-id="9c0ca-270">**図 4-15**.</span><span class="sxs-lookup"><span data-stu-id="9c0ca-270">**Figure 4-15**.</span></span> <span data-ttu-id="9c0ca-271">イベントドリブンメッセージング</span><span class="sxs-lookup"><span data-stu-id="9c0ca-271">Event-Driven messaging</span></span>

<span data-ttu-id="9c0ca-272">通信チャネルの中央にある*イベントバス*コンポーネントに注意してください。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-272">Note the *event bus* component that sits in the middle of the communication channel.</span></span> <span data-ttu-id="9c0ca-273">これは、メッセージブローカーをカプセル化し、基になるアプリケーションから分離するカスタムクラスです。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-273">It's a custom class that encapsulates the message broker and decouples it from the underlying application.</span></span> <span data-ttu-id="9c0ca-274">注文とインベントリのマイクロサービスは、個別にイベントを操作します。また、ショッピングカートマイクロサービスについての知識も不要です。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-274">The ordering and inventory microservices independently operate the event with no knowledge of each other, nor the shopping basket microservice.</span></span> <span data-ttu-id="9c0ca-275">登録されたイベントは、イベントバスに発行されると、動作します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-275">When the registered event is published to the event bus, they act upon it.</span></span>

<span data-ttu-id="9c0ca-276">イベントによって、キューテクノロジから*トピック*に移動します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-276">With eventing, we move from queuing technology to *topics*.</span></span> <span data-ttu-id="9c0ca-277">[トピック](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)はキューに似ていますが、1対多のメッセージングパターンをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-277">A [topic](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) is similar to a queue, but supports a one-to-many messaging pattern.</span></span> <span data-ttu-id="9c0ca-278">1つのマイクロサービスがメッセージを公開します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-278">One microservice publishes a message.</span></span> <span data-ttu-id="9c0ca-279">複数のサブスクライブマイクロサービスは、そのメッセージの受信と操作を選択できます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-279">Multiple subscribing microservices can choose to receive and act upon that message.</span></span> <span data-ttu-id="9c0ca-280">図4-16 に、トピックアーキテクチャを示します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-280">Figure 4-16 shows a topic architecture.</span></span>

![トピックのアーキテクチャ](./media/topic-architecture.png)

<span data-ttu-id="9c0ca-282">**図 4-16**.</span><span class="sxs-lookup"><span data-stu-id="9c0ca-282">**Figure 4-16**.</span></span> <span data-ttu-id="9c0ca-283">トピックのアーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="9c0ca-283">Topic architecture</span></span>

<span data-ttu-id="9c0ca-284">前の図では、パブリッシャーがトピックにメッセージを送信しています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-284">In the previous figure, publishers send messages to the topic.</span></span> <span data-ttu-id="9c0ca-285">最後に、サブスクライバーはサブスクリプションからメッセージを受信します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-285">At the end, subscribers receive messages from subscriptions.</span></span> <span data-ttu-id="9c0ca-286">中央では、トピックは、一連の*ルール*に基づいてメッセージを (濃い青色のボックスに表示される) サブスクリプションに転送します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-286">In the middle, the topic forwards messages to subscriptions based on a set of *rules*, shown in dark blue boxes.</span></span> <span data-ttu-id="9c0ca-287">ルールは、特定のメッセージをサブスクリプションに転送するフィルターとして機能します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-287">Rules act as a filter that forward specific messages to a subscription.</span></span> <span data-ttu-id="9c0ca-288">ここでは、"CreateOrder" イベントはサブスクリプション \#1 とサブスクリプション \#3 に送信されますが、サブスクリプション \#2 には送信されません。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-288">Here, a "CreateOrder" event would be sent to Subscription \#1 and Subscription \#3, but not to Subscription \#2.</span></span> <span data-ttu-id="9c0ca-289">"OrderCompleted" イベントは、サブスクリプション \#2 とサブスクリプション \#3 に送信されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-289">An "OrderCompleted" event would be sent to Subscription \#2 and Subscription \#3.</span></span>

<span data-ttu-id="9c0ca-290">Azure クラウドでは、Azure Service Bus トピックと Azure EventGrid という2つの異なるトピックサービスがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-290">The Azure cloud supports two different topic services: Azure Service Bus Topics and Azure EventGrid.</span></span>

### <a name="azure-service-bus-topics"></a><span data-ttu-id="9c0ca-291">Azure Service Bus のトピック</span><span class="sxs-lookup"><span data-stu-id="9c0ca-291">Azure Service Bus Topics</span></span>

<span data-ttu-id="9c0ca-292">Azure Service Bus キューの堅牢な仲介型メッセージモデルと同じように、 [Azure Service Bus のトピック](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)もあります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-292">Sitting on top of the same robust brokered message model of Azure Service Bus queues are [Azure Service Bus Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="9c0ca-293">トピックは、複数の独立したパブリッシャーからメッセージを受信し、最大2000のサブスクライバーにメッセージを送信できます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-293">A topic can receive messages from multiple independent publishers and send messages to up to 2,000 subscribers.</span></span> <span data-ttu-id="9c0ca-294">実行時にサブスクリプションを動的に追加または削除するには、システムを停止するか、トピックを再作成します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-294">Subscriptions can be dynamically added or removed at runtime without stopping the system or recreating the topic.</span></span>

<span data-ttu-id="9c0ca-295">Azure Service Bus キューの多くの高度な機能は、[重複の検出](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)やトランザクションの[サポート](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)などのトピックでも使用できます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-295">Many advanced features from Azure Service Bus queues are also available for topics, including [Duplicate Detection](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) and [Transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions).</span></span> <span data-ttu-id="9c0ca-296">既定では、Service Bus のトピックは1つのメッセージブローカーによって処理され、1つのメッセージストアに格納されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-296">By default, Service Bus topics are handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="9c0ca-297">ただし、 [Service Bus パーティション分割](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning)では、多数のメッセージブローカーとメッセージストアに分散することによってトピックをスケーリングします。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-297">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) scales a topic by spreading it across many message brokers and message stores.</span></span>

<span data-ttu-id="9c0ca-298">[スケジュール](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing)されたメッセージの配信では、特定の処理時間のメッセージにタグが付けられます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-298">[Scheduled Message Delivery](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing) tags a message with a specific time for processing.</span></span> <span data-ttu-id="9c0ca-299">このメッセージは、その時点より前のトピックには表示されません。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-299">The message won't appear in the topic before that time.</span></span> <span data-ttu-id="9c0ca-300">[メッセージの遅延](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral)により、メッセージの取得を後で遅らせることができます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-300">[Message Deferral](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral) enables you to defer a retrieval of a message to a later time.</span></span> <span data-ttu-id="9c0ca-301">どちらも、操作が特定の順序で処理されるワークフロー処理のシナリオでよく使用されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-301">Both are commonly used in workflow processing scenarios where operations are processed in a particular order.</span></span> <span data-ttu-id="9c0ca-302">前の作業が完了するまで、受信したメッセージの処理を延期することができます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-302">You can postpone processing of received messages until prior work has been completed.</span></span>

<span data-ttu-id="9c0ca-303">Service Bus トピックは、クラウドネイティブシステムで公開/サブスクライブ通信を有効にするための堅牢で実証されたテクノロジです。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-303">Service Bus topics are a robust and proven technology for enabling publish/subscribe communication in your cloud-native systems.</span></span>

### <a name="azure-event-grid"></a><span data-ttu-id="9c0ca-304">Azure Event Grid</span><span class="sxs-lookup"><span data-stu-id="9c0ca-304">Azure Event Grid</span></span>

<span data-ttu-id="9c0ca-305">Azure Service Bus は、エンタープライズ機能の完全なセットを備えた、徹底的にテストされたメッセージングブローカーですが、 [Azure Event Grid](https://docs.microsoft.com/azure/event-grid/overview)はブロックの新しい kid です。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-305">While Azure Service Bus is a battle-tested messaging broker with a full set of enterprise features, [Azure Event Grid](https://docs.microsoft.com/azure/event-grid/overview) is the new kid on the block.</span></span>

<span data-ttu-id="9c0ca-306">一見すると、Event Grid は別のトピックベースのメッセージングシステムのように見えます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-306">At first glance, Event Grid may look like just another topic-based messaging system.</span></span> <span data-ttu-id="9c0ca-307">ただし、多くの点で異なります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-307">However, it's different in many ways.</span></span> <span data-ttu-id="9c0ca-308">イベントドリブンなワークロードに重点を置いて、サーバーレスインフラストラクチャでのリアルタイムイベント処理、ディープ Azure 統合、オープンプラットフォームのすべての機能を実現します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-308">Focused on event-driven workloads, it enables real-time event processing, deep Azure integration, and an open-platform - all on serverless infrastructure.</span></span> <span data-ttu-id="9c0ca-309">最新のクラウドネイティブアプリケーションとサーバーレスアプリケーション向けに設計されています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-309">It's designed for contemporary cloud-native and serverless applications</span></span>

<span data-ttu-id="9c0ca-310">一元化されたイベント*バックプレーン*(パイプ) として、Event Grid は、Azure リソース内および独自のサービスからのイベントに反応します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-310">As a centralized *eventing backplane*, or pipe, Event Grid reacts to events inside Azure resources and from your own services.</span></span>

<span data-ttu-id="9c0ca-311">イベント通知は Event Grid トピックにパブリッシュされます。これにより、各イベントがサブスクリプションにルーティングされます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-311">Event notifications are published to an Event Grid Topic, which, in turn, routes each event to a subscription.</span></span> <span data-ttu-id="9c0ca-312">サブスクライバーはサブスクリプションにマップされ、イベントを使用します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-312">Subscribers map to subscriptions and consume the events.</span></span> <span data-ttu-id="9c0ca-313">Service Bus と同様に、Event Grid では、受信するイベントのルールがサブスクリプションによって設定されるフィルター選択された*サブスクライバーモデル*がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-313">Like Service Bus, Event Grid supports a *filtered subscriber model* where a subscription sets rule for the events it wishes to receive.</span></span> <span data-ttu-id="9c0ca-314">Event Grid は、1秒あたり1000万イベントの保証によって高速スループットを実現し、ほぼリアルタイムの配信を可能にします。これにより、Azure Service Bus によって生成される可能性がはるかに高くなります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-314">Event Grid provides fast throughput with a guarantee of 10 million events per second enabling near real-time delivery - far more than what Azure Service Bus can generate.</span></span>

<span data-ttu-id="9c0ca-315">Event Grid のために、Azure インフラストラクチャのファブリックに深く統合されています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-315">A sweet spot for Event Grid is its deep integration into the fabric of Azure infrastructure.</span></span> <span data-ttu-id="9c0ca-316">Azure リソース (Cosmos DB など) は、組み込みのイベントを他の関心のある Azure リソースに直接発行できます。カスタムコードは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-316">An Azure resource, such as Cosmos DB, can publish built-in events directly to other interested Azure resources - without the need for custom code.</span></span> <span data-ttu-id="9c0ca-317">Event Grid は、Azure サブスクリプション、リソースグループ、またはサービスからイベントを発行できるため、開発者はクラウドリソースのライフサイクルをきめ細かく制御できます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-317">Event Grid can publish events from an Azure Subscription, Resource Group, or Service, giving developers fine-grained control over the lifecycle of cloud resources.</span></span> <span data-ttu-id="9c0ca-318">ただし、Event Grid は Azure に限定されません。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-318">However, Event Grid isn't limited to Azure.</span></span> <span data-ttu-id="9c0ca-319">これは、アプリケーションまたはサードパーティのサービスから発行されたカスタム HTTP イベントを使用したり、イベントを外部サブスクライバーにルーティングしたりできるオープンプラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-319">It's an open platform that can consume custom HTTP events published from applications or third-party services and route events to external subscribers.</span></span>

<span data-ttu-id="9c0ca-320">Azure リソースからネイティブイベントを発行およびサブスクライブする場合、コーディングは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-320">When publishing and subscribing to native events from Azure resources, no coding is required.</span></span> <span data-ttu-id="9c0ca-321">単純な構成では、トピックとサブスクリプションの組み込みの組み込み機能を利用して、ある Azure リソースのイベントを別のリソースに統合できます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-321">With simple configuration, you can integrate events from one Azure resource to another leveraging built-in plumbing for Topics and Subscriptions.</span></span> <span data-ttu-id="9c0ca-322">図4-17 は、Event Grid の構造を示しています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-322">Figure 4-17 shows the anatomy of Event Grid.</span></span>

![Event Grid の構造](./media/event-grid-anatomy.png)

<span data-ttu-id="9c0ca-324">**図 4-17**.</span><span class="sxs-lookup"><span data-stu-id="9c0ca-324">**Figure 4-17**.</span></span> <span data-ttu-id="9c0ca-325">Event Grid の構造</span><span class="sxs-lookup"><span data-stu-id="9c0ca-325">Event Grid anatomy</span></span>

<span data-ttu-id="9c0ca-326">EventGrid と Service Bus の主な違いは、基になる*メッセージ交換パターン*です。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-326">A major difference between EventGrid and Service Bus is the underlying *message exchange pattern*.</span></span>

<span data-ttu-id="9c0ca-327">Service Bus には、古いスタイルの*プルモデル*が実装されています。このモデルでは、ダウンストリームサブスクライバーが新しいメッセージのトピックサブスクリプションをアクティブにポーリングします。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-327">Service Bus implements an older style *pull model* in which the downstream subscriber actively polls the topic subscription for new messages.</span></span> <span data-ttu-id="9c0ca-328">この方法を使用すると、サブスクライバーはメッセージを処理するペースを完全に制御できます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-328">On the upside, this approach gives the subscriber full control of the pace at which it processes messages.</span></span> <span data-ttu-id="9c0ca-329">特定の時点で処理するメッセージのタイミングと数を制御します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-329">It controls when and how many messages to process at any given time.</span></span> <span data-ttu-id="9c0ca-330">未読のメッセージは、処理されるまでサブスクリプションに残ります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-330">Unread messages remain in the subscription until processed.</span></span> <span data-ttu-id="9c0ca-331">重大な欠点は、イベントが生成されてから、そのメッセージを処理のためにサブスクライバーにプルするポーリング操作までの待機時間です。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-331">A significant shortcoming is the latency between the time the event is generated and the polling operation that pulls that message to the subscriber for processing.</span></span> <span data-ttu-id="9c0ca-332">また、次のイベントの定数ポーリングのオーバーヘッドによって、リソースとコストが消費されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-332">Also, the overhead of constant polling for the next event consumes resources and money.</span></span>

<span data-ttu-id="9c0ca-333">ただし、EventGrid は異なります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-333">EventGrid, however, is different.</span></span> <span data-ttu-id="9c0ca-334">これは、イベントが受信時に EventHandlers に送信される*プッシュモデル*を実装し、ほぼリアルタイムのイベント配信を提供します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-334">It implements a *push model* in which events are sent to the EventHandlers as received, giving near real-time event delivery.</span></span> <span data-ttu-id="9c0ca-335">また、ポーリングと同様に継続的にではなく、イベントを使用する必要がある場合にのみ、サービスがトリガーされるため、コストを削減できます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-335">It also reduces cost as the service is triggered only when it's needed to consume an event – not continually as with polling.</span></span> <span data-ttu-id="9c0ca-336">ただし、イベントハンドラーは受信負荷を処理し、それ自体が過負荷になるのを防ぐための調整メカニズムを提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-336">That said, an event handler must handle the incoming load and provide throttling mechanisms to protect itself from becoming overwhelmed.</span></span> <span data-ttu-id="9c0ca-337">Azure Functions や Logic Apps など、これらのイベントを使用する多くの Azure サービスでは、増加した負荷を処理する自動自動スケール機能が提供されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-337">Many Azure services that consume these events, such as Azure Functions and Logic Apps provide automatic autoscaling capabilities to handle increased loads.</span></span>  

<span data-ttu-id="9c0ca-338">Event Grid は、完全に管理されたサーバーレスクラウドサービスです。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-338">Event Grid is a fully managed serverless cloud service.</span></span> <span data-ttu-id="9c0ca-339">トラフィックに基づいて動的に拡張され、購入済みの容量ではなく実際の使用量に対してのみ課金されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-339">It dynamically scales based on your traffic and charges you only for your actual usage, not pre-purchased capacity.</span></span> <span data-ttu-id="9c0ca-340">1か月あたりの最初の10万操作は無料です。イベントの受信 (受信イベント通知) として定義されている操作、サブスクリプションの配信試行、管理呼び出し、およびサブジェクト別のフィルター処理です。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-340">The first 100,000 operations per month are free – operations being defined as event ingress (incoming event notifications), subscription delivery attempts, management calls, and filtering by subject.</span></span> <span data-ttu-id="9c0ca-341">99.99% の可用性により、EventGrid は24時間以内にイベントの配信を保証し、配信に失敗した場合の組み込みの再試行機能を備えています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-341">With 99.99% availability, EventGrid guarantees the delivery of an event within a 24-hour period, with built-in retry functionality for unsuccessful delivery.</span></span> <span data-ttu-id="9c0ca-342">配信されていないメッセージは、解決のために "配信不能" キューに移動できます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-342">Undelivered messages can be moved to a "dead-letter" queue for resolution.</span></span>  <span data-ttu-id="9c0ca-343">Azure Service Bus とは異なり、Event Grid は高速なパフォーマンスのためにチューニングされており、順序付けされたメッセージング、トランザクション、セッションなどの機能をサポートしていません。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-343">Unlike Azure Service Bus, Event Grid is tuned for fast performance and doesn't support features like ordered messaging, transactions, and sessions.</span></span>

### <a name="streaming-messages-in-the-azure-cloud"></a><span data-ttu-id="9c0ca-344">Azure クラウドでのメッセージのストリーミング</span><span class="sxs-lookup"><span data-stu-id="9c0ca-344">Streaming messages in the Azure cloud</span></span>

<span data-ttu-id="9c0ca-345">Azure Service Bus と Event Grid は、新しいドキュメントのような単一の独立したイベントを公開するアプリケーションに対して、Cosmos DB に挿入された優れたサポートを提供します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-345">Azure Service Bus and Event Grid provide great support for applications that expose single, discrete events like a new document has been inserted into a Cosmos DB.</span></span> <span data-ttu-id="9c0ca-346">しかし、クラウドネイティブシステムで*関連イベントのストリーム*を処理する必要がある場合はどうでしょうか。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-346">But, what if your cloud-native system needs to process a *stream of related events*?</span></span> <span data-ttu-id="9c0ca-347">[イベントストリーム](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems)はより複雑です。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-347">[Event streams](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems) are more complex.</span></span> <span data-ttu-id="9c0ca-348">通常は、時間順で相互関係があり、グループとして処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-348">They're typically time-ordered, interrelated, and must be processed as a group.</span></span>

<span data-ttu-id="9c0ca-349">[Azure Event Hub](https://azure.microsoft.com/services/event-hubs/)は、イベントを収集、変換、および格納するデータストリーミングプラットフォームおよびイベントインジェストサービスです。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-349">[Azure Event Hub](https://azure.microsoft.com/services/event-hubs/) is a data streaming platform and event ingestion service that collects, transforms, and stores events.</span></span> <span data-ttu-id="9c0ca-350">テレメトリコンテキストから生成された継続的なイベント通知など、ストリーミングデータをキャプチャするために微調整されています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-350">It's fine-tuned to capture streaming data, such as continuous event notifications emitted from a telemetry context.</span></span> <span data-ttu-id="9c0ca-351">このサービスは、拡張性が高く、 [1 秒あたり何百万ものイベント](https://docs.microsoft.com/azure/event-hubs/event-hubs-about)を格納および処理できます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-351">The service is highly scalable and can store and [process millions of events per second](https://docs.microsoft.com/azure/event-hubs/event-hubs-about).</span></span> <span data-ttu-id="9c0ca-352">図4-18 に示すように、多くの場合、イベントパイプラインのフロントドアとして、取り込みストリームをイベントの消費から切り離します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-352">Shown in Figure 4-18, it's often a front door for an event pipeline, decoupling ingest stream from event consumption.</span></span>

![Azure イベントハブ](./media/azure-event-hub.png)

<span data-ttu-id="9c0ca-354">**図 4-18**.</span><span class="sxs-lookup"><span data-stu-id="9c0ca-354">**Figure 4-18**.</span></span> <span data-ttu-id="9c0ca-355">Azure イベントハブ</span><span class="sxs-lookup"><span data-stu-id="9c0ca-355">Azure Event Hub</span></span>

<span data-ttu-id="9c0ca-356">イベントハブでは、短い待機時間と構成可能な時間のリテンション期間がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-356">Event Hub supports low latency and configurable time retention.</span></span> <span data-ttu-id="9c0ca-357">キューやトピックとは異なり、コンシューマーによって読み取られた後にイベントデータを保持 Event Hubs ます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-357">Unlike queues and topics, Event Hubs keep event data after it's been read by a consumer.</span></span> <span data-ttu-id="9c0ca-358">この機能により、内部および外部の他のデータ分析サービスは、データを再生してさらに分析することができます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-358">This feature enables other data analytic services, both internal and external, to replay the data for further analysis.</span></span> <span data-ttu-id="9c0ca-359">イベントハブに格納されているイベントは、保有期間の有効期限が切れたときにのみ削除されます。既定では1日ですが、構成することができます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-359">Events stored in event hub are only deleted upon expiration of the retention period, which is one day by default, but configurable.</span></span>

<span data-ttu-id="9c0ca-360">イベントハブでは、HTTPS や AMQP などの一般的なイベント発行プロトコルがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-360">Event Hub supports common event publishing protocols including HTTPS and AMQP.</span></span> <span data-ttu-id="9c0ca-361">Kafka 1.0 もサポートしています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-361">It also supports Kafka 1.0.</span></span> <span data-ttu-id="9c0ca-362">[既存の kafka アプリケーションは](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview)、大規模な kafka クラスターを管理する代わりに、kafka プロトコルを使用して Event Hub と通信できます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-362">[Existing Kafka applications can communicate with Event Hub](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview) using the Kafka protocol providing an alternative to managing large Kafka clusters.</span></span> <span data-ttu-id="9c0ca-363">オープンソースのクラウドネイティブシステムの多くは、Kafka を採用しています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-363">Many open-source cloud-native systems embrace Kafka.</span></span>

<span data-ttu-id="9c0ca-364">Event Hubs は、メッセージストリームの特定のサブセット (パーティション) のみを読み取る、パーティション分割された[コンシューマーモデル](https://docs.microsoft.com/azure/event-hubs/event-hubs-features)を介してメッセージストリーミングを実装します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-364">Event Hubs implements message streaming through a [partitioned consumer model](https://docs.microsoft.com/azure/event-hubs/event-hubs-features) in which each consumer only reads a specific subset, or partition, of the message stream.</span></span> <span data-ttu-id="9c0ca-365">このパターンでは、イベント処理の横の倍率を大きくすることができ、キューおよびトピックで使用できないその他のストリームに重点を置いた機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-365">This pattern enables tremendous horizontal scale for event processing and provides other stream-focused features that are unavailable in queues and topics.</span></span> <span data-ttu-id="9c0ca-366">パーティションは、イベントハブに保持される順序付けられた一連のイベントです。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-366">A partition is an ordered sequence of events that is held in an event hub.</span></span> <span data-ttu-id="9c0ca-367">新しいイベントが到着すると、このシーケンスの末尾に追加されます。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-367">As newer events arrive, they're added to the end of this sequence.</span></span><span data-ttu-id="9c0ca-368"> 図4-19 は、イベントハブでのパーティション分割を示しています。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-368"> Figure 4-19 shows partitioning in an Event Hub.</span></span>

![イベントハブのパーティション分割](./media/event-hub-partitioning.png)

<span data-ttu-id="9c0ca-370">**図 4-19**</span><span class="sxs-lookup"><span data-stu-id="9c0ca-370">**Figure 4-19**.</span></span> <span data-ttu-id="9c0ca-371">イベントハブのパーティション分割</span><span class="sxs-lookup"><span data-stu-id="9c0ca-371">Event Hub partitioning</span></span>

<span data-ttu-id="9c0ca-372">各コンシューマーグループは、同じリソースから読み取るのではなく、メッセージストリームのサブセットまたはパーティションをまたいで読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-372">Instead of reading from the same resource, each consumer group reads across a subset, or partition, of the message stream.</span></span>

<span data-ttu-id="9c0ca-373">多数のイベントをストリーミングする必要があるクラウドネイティブアプリケーションの場合、Azure Event Hub は堅牢で手頃な価格のソリューションになります。</span><span class="sxs-lookup"><span data-stu-id="9c0ca-373">For cloud-native applications that must stream large numbers of events, Azure Event Hub can be a robust and affordable solution.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="9c0ca-374">[前へ](front-end-communication.md)
>[次へ](rest-grpc.md)</span><span class="sxs-lookup"><span data-stu-id="9c0ca-374">[Previous](front-end-communication.md)
[Next](rest-grpc.md)</span></span>
