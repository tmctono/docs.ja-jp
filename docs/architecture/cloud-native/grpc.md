---
title: gRPC
description: GRPC、クラウドネイティブアプリケーションでのその役割、および HTTP RESTful 通信との違いについて説明します。
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: 35a8325dd82e946d88b09b223287e2871be88ffa
ms.sourcegitcommit: 71b8f5a2108a0f1a4ef1d8d75c5b3e129ec5ca1e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/29/2020
ms.locfileid: "84201330"
---
# <a name="grpc"></a><span data-ttu-id="9c858-103">gRPC</span><span class="sxs-lookup"><span data-stu-id="9c858-103">gRPC</span></span>

<span data-ttu-id="9c858-104">ここまでは、 [REST ベース](https://docs.microsoft.com/azure/architecture/best-practices/api-design)の通信に重点を置いてきました。</span><span class="sxs-lookup"><span data-stu-id="9c858-104">So far in this book, we've focused on [REST-based](https://docs.microsoft.com/azure/architecture/best-practices/api-design) communication.</span></span> <span data-ttu-id="9c858-105">REST は、エンティティリソースに対する CRUD ベースの操作を定義する柔軟なアーキテクチャスタイルであることがわかりました。</span><span class="sxs-lookup"><span data-stu-id="9c858-105">We've seen that REST is a flexible architectural style that defines CRUD-based operations against entity resources.</span></span> <span data-ttu-id="9c858-106">クライアントは、要求/応答通信モデルを使用して、HTTP を介してリソースと対話します。</span><span class="sxs-lookup"><span data-stu-id="9c858-106">Clients interact with resources across HTTP with a request/response communication model.</span></span> <span data-ttu-id="9c858-107">REST は広く実装されていますが、新しい通信テクノロジである gRPC は、クラウドネイティブコミュニティ全体で大きな勢いを獲得しています。</span><span class="sxs-lookup"><span data-stu-id="9c858-107">While REST is widely implemented, a newer communication technology, gRPC, has gained tremendous momentum across the cloud-native community.</span></span>

## <a name="what-is-grpc"></a><span data-ttu-id="9c858-108">GRPC とは</span><span class="sxs-lookup"><span data-stu-id="9c858-108">What is gRPC?</span></span>

<span data-ttu-id="9c858-109">gRPC は、古い[リモートプロシージャコール (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call)プロトコルを進化させる最新の高パフォーマンスフレームワークです。</span><span class="sxs-lookup"><span data-stu-id="9c858-109">gRPC is a modern, high-performance framework that evolves the age-old [remote procedure call (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) protocol.</span></span> <span data-ttu-id="9c858-110">アプリケーションレベルでは、gRPC によって、クライアントとバックエンドサービス間のメッセージングが合理化されます。</span><span class="sxs-lookup"><span data-stu-id="9c858-110">At the application level, gRPC streamlines messaging between clients and back-end services.</span></span> <span data-ttu-id="9c858-111">Google から提供される gRPC はオープンソースであり、クラウドネイティブオファリングの[クラウドネイティブコンピューティングファンデーション (CNCF)](https://www.cncf.io/)エコシステムの一部です。</span><span class="sxs-lookup"><span data-stu-id="9c858-111">Originating from Google, gRPC is open source and part of the  [Cloud Native Computing Foundation (CNCF)](https://www.cncf.io/) ecosystem of cloud-native offerings.</span></span> <span data-ttu-id="9c858-112">CNCF は gRPC を[incubating プロジェクト](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc)と見なします。</span><span class="sxs-lookup"><span data-stu-id="9c858-112">CNCF considers gRPC an [incubating project](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc).</span></span> <span data-ttu-id="9c858-113">Incubating は、エンドユーザーが実稼働アプリケーションでテクノロジを使用しており、プロジェクトの共同作成者の数が正常であることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9c858-113">Incubating means end users are using the technology in production applications, and the project has a healthy number of contributors.</span></span>

<span data-ttu-id="9c858-114">一般的な gRPC クライアントアプリは、ビジネス操作を実装する、ローカルのインプロセス関数を公開します。</span><span class="sxs-lookup"><span data-stu-id="9c858-114">A typical gRPC client app will expose a local, in-process function that implements a business operation.</span></span> <span data-ttu-id="9c858-115">内部的には、ローカル関数は、リモートコンピューター上で別の関数を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9c858-115">Under the covers, that local function invokes another function on a remote machine.</span></span> <span data-ttu-id="9c858-116">ローカル呼び出しとして表示されるのは、リモートサービスへの透過的なアウトプロセス呼び出しです。</span><span class="sxs-lookup"><span data-stu-id="9c858-116">What appears to be a local call essentially becomes a transparent out-of-process call to a remote service.</span></span> <span data-ttu-id="9c858-117">RPC のプラミングは、コンピューター間のポイントツーポイントのネットワーク通信、シリアル化、および実行を抽象化します。</span><span class="sxs-lookup"><span data-stu-id="9c858-117">The RPC plumbing abstracts the point-to-point networking communication, serialization, and execution between computers.</span></span>

<span data-ttu-id="9c858-118">クラウドネイティブアプリケーションでは、開発者は多くの場合、プログラミング言語、フレームワーク、およびテクノロジに対して機能します。</span><span class="sxs-lookup"><span data-stu-id="9c858-118">In cloud-native applications, developers often work across programming languages, frameworks, and technologies.</span></span> <span data-ttu-id="9c858-119">この*相互運用性*により、メッセージコントラクトと、クロスプラットフォーム通信に必要なプラミングが複雑になります。</span><span class="sxs-lookup"><span data-stu-id="9c858-119">This *interoperability* complicates message contracts and the plumbing required for cross-platform communication.</span></span>  <span data-ttu-id="9c858-120">gRPC には、これらの問題を抽象化する "均一な水平方向のレイヤー" が用意されています。</span><span class="sxs-lookup"><span data-stu-id="9c858-120">gRPC provides a "uniform horizontal layer" that abstracts these concerns.</span></span> <span data-ttu-id="9c858-121">開発者は、ビジネス機能に重点を置いたネイティブプラットフォームでコードを記述し、gRPC は通信の組み込みを処理します。</span><span class="sxs-lookup"><span data-stu-id="9c858-121">Developers code in their native platform focused on business functionality, while gRPC handles communication plumbing.</span></span>

<span data-ttu-id="9c858-122">gRPC は、Java、JavaScript、C#、ゴー、Swift、NodeJS など、最も人気のある開発スタックで包括的なサポートを提供します。</span><span class="sxs-lookup"><span data-stu-id="9c858-122">gRPC offers comprehensive support across most popular development stacks, including Java, JavaScript, C#, Go, Swift, and NodeJS.</span></span>

## <a name="grpc-benefits"></a><span data-ttu-id="9c858-123">gRPC の特典</span><span class="sxs-lookup"><span data-stu-id="9c858-123">gRPC Benefits</span></span>

<span data-ttu-id="9c858-124">gRPC は、トランスポートプロトコルとして HTTP/2 を使用します。</span><span class="sxs-lookup"><span data-stu-id="9c858-124">gRPC uses HTTP/2 for its transport protocol.</span></span> <span data-ttu-id="9c858-125">Http/2 は HTTP 1.1 と互換性がありますが、多くの高度な機能を備えています。</span><span class="sxs-lookup"><span data-stu-id="9c858-125">While compatible with HTTP 1.1, HTTP/2 features many advanced capabilities:</span></span>

- <span data-ttu-id="9c858-126">データトランスポート用のバイナリプロトコル-データをクリアテキストとして送信する HTTP 1.1 とは異なります。</span><span class="sxs-lookup"><span data-stu-id="9c858-126">A binary protocol for data transport - unlike HTTP 1.1, which sends data as clear text.</span></span>
- <span data-ttu-id="9c858-127">同一の接続で複数の並列要求を送信するための多重化サポート-HTTP 1.1 は、一度に1つの要求/応答メッセージに処理を制限します。</span><span class="sxs-lookup"><span data-stu-id="9c858-127">Multiplexing support for sending multiple parallel requests over the same connection - HTTP 1.1 limits processing to one request/response message at a time.</span></span>
- <span data-ttu-id="9c858-128">クライアント要求とサーバー応答の両方を同時に送信するための双方向の全二重通信。</span><span class="sxs-lookup"><span data-stu-id="9c858-128">Bidirectional full-duplex communication for sending both client requests and server responses simultaneously.</span></span>
- <span data-ttu-id="9c858-129">要求と応答を有効にして、大きなデータセットを非同期的にストリーム配信できる組み込みのストリーミング。</span><span class="sxs-lookup"><span data-stu-id="9c858-129">Built-in streaming enabling requests and responses to asynchronously stream large data sets.</span></span>

<span data-ttu-id="9c858-130">gRPC は軽量で高いパフォーマンスを備えています。</span><span class="sxs-lookup"><span data-stu-id="9c858-130">gRPC is lightweight and highly performant.</span></span> <span data-ttu-id="9c858-131">メッセージ数が60-80% 小さい JSON シリアル化よりも最大8x 倍の速度で実現できます。</span><span class="sxs-lookup"><span data-stu-id="9c858-131">It can be up to 8x faster than JSON serialization with messages 60-80% smaller.</span></span> <span data-ttu-id="9c858-132">Microsoft [Windows Communication Foundation (WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf)用語では、grpc のパフォーマンスは、高度に最適化された[nettcp バインド](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8)の速度と効率を超えています。</span><span class="sxs-lookup"><span data-stu-id="9c858-132">In Microsoft [Windows Communication Foundation (WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf) parlance, gRPC performance exceeds the speed and efficiency of the highly optimized [NetTCP bindings](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8).</span></span> <span data-ttu-id="9c858-133">Microsoft stack を優先する NetTCP とは異なり、gRPC はクロスプラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="9c858-133">Unlike NetTCP, which favors the Microsoft stack, gRPC is cross-platform.</span></span>

## <a name="protocol-buffers"></a><span data-ttu-id="9c858-134">プロトコル バッファー</span><span class="sxs-lookup"><span data-stu-id="9c858-134">Protocol Buffers</span></span>

<span data-ttu-id="9c858-135">gRPC は、[プロトコルバッファー](https://developers.google.com/protocol-buffers/docs/overview)と呼ばれるオープンソーステクノロジを採用しています。</span><span class="sxs-lookup"><span data-stu-id="9c858-135">gRPC embraces an open-source technology called [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview).</span></span> <span data-ttu-id="9c858-136">サービスが相互に送信する構造化メッセージをシリアル化するために、非常に効率的でプラットフォームに依存しないシリアル化形式を提供します。</span><span class="sxs-lookup"><span data-stu-id="9c858-136">They provide a highly efficient and platform-neutral serialization format for serializing structured messages that services send to each other.</span></span> <span data-ttu-id="9c858-137">開発者は、クロスプラットフォームインターフェイス定義言語 (IDL) を使用して、マイクロサービスごとにサービスコントラクトを定義します。</span><span class="sxs-lookup"><span data-stu-id="9c858-137">Using a cross-platform Interface Definition Language (IDL), developers define a service contract for each microservice.</span></span> <span data-ttu-id="9c858-138">コントラクトは、テキストベースのファイルとして実装され、 `.proto` 各サービスのメソッド、入力、および出力を記述します。</span><span class="sxs-lookup"><span data-stu-id="9c858-138">The contract, implemented as a text-based `.proto` file, describes the methods, inputs, and outputs for each service.</span></span> <span data-ttu-id="9c858-139">同じコントラクトファイルは、さまざまな開発プラットフォーム上に構築された gRPC クライアントおよびサービスに使用できます。</span><span class="sxs-lookup"><span data-stu-id="9c858-139">The same contract file can be used for gRPC clients and services built on different development platforms.</span></span>

<span data-ttu-id="9c858-140">Protobuf コンパイラである proto ファイルを使用する `protoc` と、ターゲットプラットフォームのクライアントとサービスコードの両方が生成されます。</span><span class="sxs-lookup"><span data-stu-id="9c858-140">Using the proto file, the Protobuf compiler, `protoc`, generates both client and service code for your target platform.</span></span> <span data-ttu-id="9c858-141">このコードには、次のコンポーネントが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9c858-141">The code includes the following components:</span></span>

- <span data-ttu-id="9c858-142">クライアントとサービスによって共有される、厳密に型指定されたオブジェクト。メッセージのサービス操作とデータ要素を表します。</span><span class="sxs-lookup"><span data-stu-id="9c858-142">Strongly typed objects, shared by the client and service, that represent the service operations and data elements for a message.</span></span>
- <span data-ttu-id="9c858-143">リモート gRPC サービスが継承および拡張できる必要なネットワークの組み込みを持つ、厳密に型指定された基本クラス。</span><span class="sxs-lookup"><span data-stu-id="9c858-143">A strongly typed base class with the required network plumbing that the remote gRPC service can inherit and extend.</span></span>
- <span data-ttu-id="9c858-144">リモート gRPC サービスを呼び出すために必要な構成を含むクライアントスタブ。</span><span class="sxs-lookup"><span data-stu-id="9c858-144">A client stub that contains the required plumbing to invoke the remote gRPC service.</span></span>

<span data-ttu-id="9c858-145">実行時には、各メッセージが標準の Protobuf 表現としてシリアル化され、クライアントとリモートサービスの間で交換されます。</span><span class="sxs-lookup"><span data-stu-id="9c858-145">At runtime, each message is serialized as a standard Protobuf representation and exchanged between the client and remote service.</span></span> <span data-ttu-id="9c858-146">JSON や XML とは異なり、Protobuf メッセージはコンパイル済みバイナリバイトとしてシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="9c858-146">Unlike JSON or XML, Protobuf messages are serialized as compiled binary bytes.</span></span>

<span data-ttu-id="9c858-147">Microsoft アーキテクチャサイトから入手できる「 [grpc FOR WCF 開発者](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/)」という書籍では、grpc とプロトコルバッファーの詳細について説明しています。</span><span class="sxs-lookup"><span data-stu-id="9c858-147">The book, [gRPC for WCF Developers](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/), available from the Microsoft Architecture site, provides in-depth coverage of gRPC and Protocol Buffers.</span></span>

## <a name="grpc-support-in-net"></a><span data-ttu-id="9c858-148">.NET での gRPC のサポート</span><span class="sxs-lookup"><span data-stu-id="9c858-148">gRPC support in .NET</span></span>

<span data-ttu-id="9c858-149">gRPC は .NET Core 3.0 SDK 以降に統合されています。</span><span class="sxs-lookup"><span data-stu-id="9c858-149">gRPC is integrated into .NET Core 3.0 SDK and later.</span></span> <span data-ttu-id="9c858-150">次のツールでサポートされています。</span><span class="sxs-lookup"><span data-stu-id="9c858-150">The following tools support it:</span></span>

- <span data-ttu-id="9c858-151">Web 開発ワークロードがインストールされた Visual Studio 2019、バージョン16.3 以降。</span><span class="sxs-lookup"><span data-stu-id="9c858-151">Visual Studio 2019, version 16.3 or later, with the web development workload installed.</span></span>
- <span data-ttu-id="9c858-152">Visual Studio Code</span><span class="sxs-lookup"><span data-stu-id="9c858-152">Visual Studio Code</span></span>
- <span data-ttu-id="9c858-153">dotnet CLI</span><span class="sxs-lookup"><span data-stu-id="9c858-153">the dotnet CLI</span></span>

<span data-ttu-id="9c858-154">SDK には、エンドポイントルーティング、組み込み IoC、およびログ記録用のツールが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9c858-154">The SDK includes tooling for endpoint routing, built-in IoC, and logging.</span></span> <span data-ttu-id="9c858-155">オープンソースの Kestrel web サーバーは、HTTP/2 接続をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="9c858-155">The open-source Kestrel web server supports HTTP/2 connections.</span></span> <span data-ttu-id="9c858-156">図4-20 は、gRPC サービスのスケルトンプロジェクトをスキャフォールディングする Visual Studio 2019 テンプレートを示しています。</span><span class="sxs-lookup"><span data-stu-id="9c858-156">Figure 4-20 shows a Visual Studio 2019 template that scaffolds a skeleton project for a gRPC service.</span></span> <span data-ttu-id="9c858-157">.NET Core が Windows、Linux、および macOS を完全にサポートしていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="9c858-157">Note how .NET Core fully supports Windows, Linux, and macOS.</span></span>

![Visual Studio 2019 での gRPC のサポート](./media/visual-studio-2019-grpc-template.png)

<span data-ttu-id="9c858-159">**図 4-20**</span><span class="sxs-lookup"><span data-stu-id="9c858-159">**Figure 4-20**.</span></span> <span data-ttu-id="9c858-160">Visual Studio 2019 での gRPC のサポート</span><span class="sxs-lookup"><span data-stu-id="9c858-160">gRPC support in Visual Studio 2019</span></span>
  
<span data-ttu-id="9c858-161">図4-21 は、Visual Studio 2019 に含まれる組み込みスキャフォールディングから生成されたスケルトン gRPC サービスを示しています。</span><span class="sxs-lookup"><span data-stu-id="9c858-161">Figure 4-21 shows the skeleton gRPC service generated from the built-in scaffolding included in Visual Studio 2019.</span></span>  

![Visual Studio 2019 の gRPC プロジェクト](./media/grpc-project.png  )

<span data-ttu-id="9c858-163">**図 4-21**</span><span class="sxs-lookup"><span data-stu-id="9c858-163">**Figure 4-21**.</span></span> <span data-ttu-id="9c858-164">Visual Studio 2019 の gRPC プロジェクト</span><span class="sxs-lookup"><span data-stu-id="9c858-164">gRPC project in Visual Studio 2019</span></span>

<span data-ttu-id="9c858-165">前の図では、proto description ファイルとサービスコードに注意してください。</span><span class="sxs-lookup"><span data-stu-id="9c858-165">In the previous figure, note the proto description file and service code.</span></span> <span data-ttu-id="9c858-166">すぐにわかるように、Visual Studio では、スタートアップクラスと基になるプロジェクトファイルの両方に追加の構成が生成されます。</span><span class="sxs-lookup"><span data-stu-id="9c858-166">As you'll see shortly, Visual Studio generates additional configuration in both the Startup class and underlying project file.</span></span>

## <a name="grpc-usage"></a><span data-ttu-id="9c858-167">gRPC の使用</span><span class="sxs-lookup"><span data-stu-id="9c858-167">gRPC usage</span></span>

<span data-ttu-id="9c858-168">次のシナリオで gRPC を優先します。</span><span class="sxs-lookup"><span data-stu-id="9c858-168">Favor gRPC for the following scenarios:</span></span>

- <span data-ttu-id="9c858-169">同期バックエンドマイクロサービスからマイクロサービスへの通信。処理を続行するために即時応答が必要です。</span><span class="sxs-lookup"><span data-stu-id="9c858-169">Synchronous backend microservice-to-microservice communication where an immediate response is required to continue processing.</span></span>
- <span data-ttu-id="9c858-170">混合プログラミングプラットフォームをサポートする必要がある多言語環境。</span><span class="sxs-lookup"><span data-stu-id="9c858-170">Polyglot environments that need to support mixed programming platforms.</span></span>
- <span data-ttu-id="9c858-171">低待機時間と高スループット通信で、パフォーマンスが重要です。</span><span class="sxs-lookup"><span data-stu-id="9c858-171">Low latency and high throughput communication where performance is critical.</span></span>
- <span data-ttu-id="9c858-172">ポイントツーポイントのリアルタイム通信-gRPC は、ポーリングせずにリアルタイムでメッセージをプッシュでき、双方向ストリーミングが優れたサポートを備えています。</span><span class="sxs-lookup"><span data-stu-id="9c858-172">Point-to-point real-time communication - gRPC can push messages in real time without polling and has excellent support for bi-directional streaming.</span></span>
- <span data-ttu-id="9c858-173">ネットワークの制約付き環境–バイナリ gRPC のメッセージは、常に同等のテキストベースの JSON メッセージよりも小さくなります。</span><span class="sxs-lookup"><span data-stu-id="9c858-173">Network constrained environments – binary gRPC messages are always smaller than an equivalent text-based JSON message.</span></span>

<span data-ttu-id="9c858-174">このドキュメントの執筆時点では、gRPC は主にバックエンドサービスで使用されています。</span><span class="sxs-lookup"><span data-stu-id="9c858-174">At the time, of this writing, gRPC is primarily used with backend services.</span></span> <span data-ttu-id="9c858-175">ほとんどの最新のブラウザーでは、フロントエンドの gRPC クライアントをサポートするために必要な HTTP/2 コントロールのレベルを提供できません。</span><span class="sxs-lookup"><span data-stu-id="9c858-175">Most modern browsers can't provide the level of HTTP/2 control required to support a front-end gRPC client.</span></span> <span data-ttu-id="9c858-176">ただし、JavaScript または Blazor WebAssembly でビルドされたブラウザーベースのアプリから gRPC 通信を可能にする[初期のイニシアチブ](https://devblogs.microsoft.com/aspnet/grpc-web-experiment/)があります。</span><span class="sxs-lookup"><span data-stu-id="9c858-176">That said, there's an [early initiative](https://devblogs.microsoft.com/aspnet/grpc-web-experiment/) that enables gRPC communication from browser-based apps built with JavaScript or Blazor WebAssembly technologies.</span></span> <span data-ttu-id="9c858-177">[Grpc-Web for .net](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md)を使用すると、ASP.NET Core grpc アプリで、ブラウザーアプリで grpc 機能をサポートできます。</span><span class="sxs-lookup"><span data-stu-id="9c858-177">The  [gRPC-Web for .NET](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) enables an ASP.NET Core gRPC app to support gRPC features in browser apps:</span></span>

- <span data-ttu-id="9c858-178">厳密に型指定された、コード生成クライアント</span><span class="sxs-lookup"><span data-stu-id="9c858-178">Strongly typed, code-generated clients</span></span>
- <span data-ttu-id="9c858-179">Compact Protobuf メッセージ</span><span class="sxs-lookup"><span data-stu-id="9c858-179">Compact Protobuf messages</span></span>
- <span data-ttu-id="9c858-180">サーバー ストリーミング。</span><span class="sxs-lookup"><span data-stu-id="9c858-180">Server streaming</span></span>

## <a name="grpc-implementation"></a><span data-ttu-id="9c858-181">gRPC の実装</span><span class="sxs-lookup"><span data-stu-id="9c858-181">gRPC implementation</span></span>

<span data-ttu-id="9c858-182">Microsoft からの[コンテナーである](https://github.com/dotnet-architecture/eShopOnContainers)、マイクロサービス参照アーキテクチャは、.net Core アプリケーションで grpc サービスを実装する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9c858-182">The microservice reference architecture, [eShop on Containers](https://github.com/dotnet-architecture/eShopOnContainers), from Microsoft, shows how to implement gRPC services in .NET Core applications.</span></span> <span data-ttu-id="9c858-183">図4-22 は、バックエンドアーキテクチャを示しています。</span><span class="sxs-lookup"><span data-stu-id="9c858-183">Figure 4-22 presents the back-end architecture.</span></span>

![コンテナーの eShop のバックエンドアーキテクチャ](./media/eshop-with-aggregators.png)

<span data-ttu-id="9c858-185">**図 4-22**</span><span class="sxs-lookup"><span data-stu-id="9c858-185">**Figure 4-22**.</span></span> <span data-ttu-id="9c858-186">コンテナーの eShop のバックエンドアーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="9c858-186">Backend architecture for eShop on Containers</span></span>

<span data-ttu-id="9c858-187">前の図では、eShop が複数の API ゲートウェイを公開することによって、フロントエンド pattern (bff)[のバックエンド](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends)を採用していることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="9c858-187">In the previous figure, note how eShop embraces the [Backend for Frontends pattern](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) (BFF) by exposing multiple API gateways.</span></span> <span data-ttu-id="9c858-188">BFF パターンについては、この章で前に説明しました。</span><span class="sxs-lookup"><span data-stu-id="9c858-188">We discussed the BFF pattern earlier in this chapter.</span></span> <span data-ttu-id="9c858-189">Web ショッピング API ゲートウェイとバックエンドショッピングマイクロサービスの間にあるアグリゲーターマイクロサービス (灰色) に細心の注意を払ってください。</span><span class="sxs-lookup"><span data-stu-id="9c858-189">Pay close attention to the Aggregator microservice (in gray) that sits between the Web-Shopping API Gateway and backend Shopping microservices.</span></span> <span data-ttu-id="9c858-190">アグリゲーターは、クライアントから1つの要求を受信し、それをさまざまなマイクロサービスにディスパッチし、結果を集計して、要求元のクライアントに送信します。</span><span class="sxs-lookup"><span data-stu-id="9c858-190">The Aggregator receives a single request from a client, dispatches it to various microservices, aggregates the results, and sends them back to the requesting client.</span></span> <span data-ttu-id="9c858-191">このような操作では、通常、即時応答を生成するために同期通信が必要です。</span><span class="sxs-lookup"><span data-stu-id="9c858-191">Such operations typically require synchronous communication as to produce an immediate response.</span></span> <span data-ttu-id="9c858-192">EShop では、アグリゲーターからのバックエンド呼び出しは、図4-23 に示すように gRPC を使用して実行されます。</span><span class="sxs-lookup"><span data-stu-id="9c858-192">In eShop, backend calls from the Aggregator are performed using gRPC as shown in Figure 4-23.</span></span>

![コンテナーの eShop にある gRPC](./media/grpc-implementation.png)

<span data-ttu-id="9c858-194">**図 4-23**. </span><span class="sxs-lookup"><span data-stu-id="9c858-194">**Figure 4-23**.</span></span> <span data-ttu-id="9c858-195">コンテナーの eShop にある gRPC</span><span class="sxs-lookup"><span data-stu-id="9c858-195">gRPC in eShop on Containers</span></span>

<span data-ttu-id="9c858-196">gRPC 通信には、クライアントコンポーネントとサーバーコンポーネントの両方が必要です。</span><span class="sxs-lookup"><span data-stu-id="9c858-196">gRPC communication requires both client and server components.</span></span> <span data-ttu-id="9c858-197">前の図で、ショッピングアグリゲーターが gRPC クライアントを実装する方法に注目してください。</span><span class="sxs-lookup"><span data-stu-id="9c858-197">In the previous figure, note how the Shopping Aggregator implements a gRPC client.</span></span> <span data-ttu-id="9c858-198">クライアントは、同期 gRPC 呼び出し (赤) をバックエンドマイクロサービスに対して実行し、それぞれが gRPC サーバーを実装します。</span><span class="sxs-lookup"><span data-stu-id="9c858-198">The client makes synchronous gRPC calls (in red) to backend microservices, each of which implement a gRPC server.</span></span> <span data-ttu-id="9c858-199">クライアントとサーバーの両方で、.NET Core SDK から組み込まれている gRPC の組み込み機能を利用します。</span><span class="sxs-lookup"><span data-stu-id="9c858-199">Both the client and server take advantage of the built-in gRPC plumbing from the .NET Core SDK.</span></span> <span data-ttu-id="9c858-200">クライアント側*スタブ*は、リモート grpc 呼び出しを呼び出すための機構を提供します。</span><span class="sxs-lookup"><span data-stu-id="9c858-200">Client-side *stubs* provide the plumbing to invoke remote gRPC calls.</span></span> <span data-ttu-id="9c858-201">サーバー側コンポーネントは、カスタムサービスクラスが継承して使用できる gRPC の組み込み機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="9c858-201">Server-side components provide gRPC plumbing that custom service classes can inherit and consume.</span></span>

<span data-ttu-id="9c858-202">RESTful API と gRPC 通信の両方を公開するマイクロサービスでは、複数のエンドポイントでトラフィックを管理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9c858-202">Microservices that expose both a RESTful API and gRPC communication require multiple endpoints to manage traffic.</span></span> <span data-ttu-id="9c858-203">RESTful 呼び出しの場合は HTTP トラフィックをリッスンし、gRPC 呼び出しの場合は別のエンドポイントを開きます。</span><span class="sxs-lookup"><span data-stu-id="9c858-203">You would open an endpoint that listens for HTTP traffic for the RESTful calls and another for gRPC calls.</span></span> <span data-ttu-id="9c858-204">Grpc 通信に必要な HTTP/2 プロトコル用に gRPC エンドポイントを構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9c858-204">The gRPC endpoint must be configured for the HTTP/2 protocol that is required for gRPC communication.</span></span>

<span data-ttu-id="9c858-205">マイクロサービスと非同期通信パターンを分離することに努めていますが、一部の操作では直接呼び出しが必要です。</span><span class="sxs-lookup"><span data-stu-id="9c858-205">While we strive to decouple microservices with asynchronous communication patterns, some operations require direct calls.</span></span> <span data-ttu-id="9c858-206">gRPC は、マイクロサービス間の直接同期通信に主な選択肢となります。</span><span class="sxs-lookup"><span data-stu-id="9c858-206">gRPC should be the primary choice for direct synchronous communication between microservices.</span></span> <span data-ttu-id="9c858-207">HTTP/2 とプロトコルバッファーに基づく高パフォーマンスの通信プロトコルによって、最適な選択肢になります。</span><span class="sxs-lookup"><span data-stu-id="9c858-207">Its high-performance communication protocol, based on HTTP/2 and protocol buffers, make it a perfect choice.</span></span>

## <a name="looking-ahead"></a><span data-ttu-id="9c858-208">今後の予定</span><span class="sxs-lookup"><span data-stu-id="9c858-208">Looking ahead</span></span>

<span data-ttu-id="9c858-209">今後、gRPC は引き続きクラウドネイティブシステムの牽引力を獲得します。</span><span class="sxs-lookup"><span data-stu-id="9c858-209">Looking ahead, gRPC will continue to gain traction for cloud-native systems.</span></span> <span data-ttu-id="9c858-210">パフォーマンスの利点と開発の容易さは説得力を持っています。</span><span class="sxs-lookup"><span data-stu-id="9c858-210">The performance benefits and ease of development are compelling.</span></span> <span data-ttu-id="9c858-211">ただし、残りの時間は長くなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9c858-211">However, REST will likely be around for a long time.</span></span> <span data-ttu-id="9c858-212">パブリックに公開されている Api および旧バージョンとの互換性のために適しています。</span><span class="sxs-lookup"><span data-stu-id="9c858-212">It excels for publicly exposed APIs and for backward compatibility reasons.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="9c858-213">[前へ](service-to-service-communication.md)
>[次へ](service-mesh-communication-infrastructure.md)</span><span class="sxs-lookup"><span data-stu-id="9c858-213">[Previous](service-to-service-communication.md)
[Next](service-mesh-communication-infrastructure.md)</span></span>
