---
title: .NET Framework XAML サービスで使用するためのカスタム型の定義
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: 7437add6795c1bb7f8a59807ebfc51dc2d0f987f
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/12/2019
ms.locfileid: "73972021"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="ba7d0-102">.NET Framework XAML サービスで使用するためのカスタム型の定義</span><span class="sxs-lookup"><span data-stu-id="ba7d0-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="ba7d0-103">ビジネスオブジェクトまたは特定のフレームワークに依存しない型のカスタム型を定義する場合は、XAML のベストプラクティスに従うことができます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="ba7d0-104">これらの方法に従うと、.NET Framework XAML サービスとその XAML リーダーおよび XAML ライターは、型の XAML 特性を検出し、xaml 型システムを使用して XAML ノードストリームに適切な表現を与えることができます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="ba7d0-105">このトピックでは、型定義、メンバー定義、および型またはメンバーの CLR 属性のベストプラクティスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="ba7d0-106">XAML のコンストラクターパターンと型定義</span><span class="sxs-lookup"><span data-stu-id="ba7d0-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="ba7d0-107">XAML でオブジェクト要素としてインスタンス化するには、カスタムクラスが次の要件を満たしている必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
- <span data-ttu-id="ba7d0-108">カスタムクラスはパブリックである必要があり、パラメーターなしのパブリックコンストラクターを公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="ba7d0-109">(構造に関する注意事項については、次のセクションを参照してください)。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-109">(See following section for notes regarding structures.)</span></span>  
  
- <span data-ttu-id="ba7d0-110">カスタムクラスを入れ子にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="ba7d0-111">フルネームパスの余分な "ドット" により、クラス名前空間の除算があいまいになり、添付プロパティなどの他の XAML 機能と干渉します。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="ba7d0-112">オブジェクトをオブジェクト要素としてインスタンス化できる場合、作成されたオブジェクトは、基になる型としてオブジェクトを受け取るプロパティのプロパティ要素の形式を満たすことができます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="ba7d0-113">値コンバーターを有効にした場合でも、これらの条件を満たしていない型のオブジェクト値を提供できます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="ba7d0-114">詳細については、「 [XAML の型コンバーターとマークアップ拡張機能](type-converters-and-markup-extensions-for-xaml.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="ba7d0-115">構造体</span><span class="sxs-lookup"><span data-stu-id="ba7d0-115">Structures</span></span>  
 <span data-ttu-id="ba7d0-116">構造体は、常に CLR 定義によって XAML で構築できます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="ba7d0-117">これは、CLR コンパイラが構造体のパラメーターなしのコンストラクターを暗黙的に作成するためです。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="ba7d0-118">このコンストラクターは、すべてのプロパティ値を既定値に初期化します。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="ba7d0-119">場合によっては、構造体の既定の構築動作は望ましくありません。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="ba7d0-120">これは、構造体が値を入力し、概念的に共用体として機能することを意図しているためです。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="ba7d0-121">共用体として、含まれる値は相互に排他的な解釈を持つ場合があります。したがって、プロパティは設定できません。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="ba7d0-122">WPF のボキャブラリにおけるこのような構造の例としては、<xref:System.Windows.GridLength>があります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="ba7d0-123">このような構造体では、構造体の値の異なる解釈やモードを作成する文字列規則を使用して、値を属性形式で表現できるように、型コンバーターを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="ba7d0-124">また、構造体は、パラメーターなしのコンストラクターを使用してコードを構築する場合にも同様の動作を公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="ba7d0-125">インターフェイス</span><span class="sxs-lookup"><span data-stu-id="ba7d0-125">Interfaces</span></span>  
 <span data-ttu-id="ba7d0-126">インターフェイスは、メンバーの基になる型として使用できます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="ba7d0-127">XAML 型システムは、割り当て可能なリストを確認し、値として指定されたオブジェクトをインターフェイスに割り当てることができることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="ba7d0-128">関連する割り当て可能な型が XAML 構築の要件をサポートしている限り、インターフェイスを XAML 型として提示する方法の概念はありません。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="ba7d0-129">ファクトリメソッド</span><span class="sxs-lookup"><span data-stu-id="ba7d0-129">Factory Methods</span></span>  
 <span data-ttu-id="ba7d0-130">ファクトリメソッドは XAML 2009 機能です。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="ba7d0-131">これらは、オブジェクトにパラメーターなしのコンストラクターが必要であることを XAML 原則を変更します。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="ba7d0-132">ファクトリメソッドについては、このトピックでは説明しません。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="ba7d0-133">「 [X:FactoryMethod ディレクティブ](x-factorymethod-directive.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-133">See [x:FactoryMethod Directive](x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="ba7d0-134">列挙</span><span class="sxs-lookup"><span data-stu-id="ba7d0-134">Enumerations</span></span>  
 <span data-ttu-id="ba7d0-135">列挙には、XAML ネイティブ型の変換動作があります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="ba7d0-136">XAML で指定された列挙定数名は、基になる列挙型に対して解決され、その列挙値を XAML オブジェクトライターに返します。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="ba7d0-137">XAML では、<xref:System.FlagsAttribute> 適用された列挙体のフラグ形式の使用をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="ba7d0-138">詳細については、「 [XAML 構文の詳細](../wpf/advanced/xaml-syntax-in-detail.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-138">For more information, see [XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="ba7d0-139">([Xaml 構文の詳細に](../wpf/advanced/xaml-syntax-in-detail.md)ついては、WPF の対象ユーザー向けに記述されていますが、そのトピックのほとんどの情報は、特定の実装フレームワークに固有ではない xaml に関連しています)。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-139">([XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="ba7d0-140">メンバーの定義</span><span class="sxs-lookup"><span data-stu-id="ba7d0-140">Member Definitions</span></span>  
 <span data-ttu-id="ba7d0-141">型は、XAML の使用のためにメンバーを定義できます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="ba7d0-142">特定の型が XAML で使用できない場合でも、XAML で使用できるメンバーを定義する型を使用できます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="ba7d0-143">これは、CLR 継承が原因で発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="ba7d0-144">メンバーを継承する型が XAML の使用を型としてサポートしていて、そのメンバーが基になる型の XAML の使用をサポートしている場合、またはネイティブ XAML 構文を使用できる場合、そのメンバーは XAML で使用できます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="ba7d0-145">プロパティ</span><span class="sxs-lookup"><span data-stu-id="ba7d0-145">Properties</span></span>  
 <span data-ttu-id="ba7d0-146">一般的な CLR `get` および `set` アクセサーパターンと言語に適したキー表現を使用してパブリック CLR プロパティとしてプロパティを定義すると、XAML 型システムは <xref:System.Xaml.XamlMember.IsReadPublic%2A> や <xref:System.Xaml.XamlMember.IsWritePublic%2A>などの <xref:System.Xaml.XamlMember> プロパティに対して提供される適切な情報を持つメンバーとしてプロパティを報告できます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="ba7d0-147">特定のプロパティでは、<xref:System.ComponentModel.TypeConverterAttribute>を適用することによってテキスト構文を有効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="ba7d0-148">詳細については、「 [XAML の型コンバーターとマークアップ拡張機能](type-converters-and-markup-extensions-for-xaml.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="ba7d0-149">テキスト構文またはネイティブ XAML 変換が存在しない場合、また、マークアップ拡張機能の<xref:System.Xaml.XamlMember.TargetType%2A> 使用など、追加の間接参照が存在しない場合は、ターゲット型を CLR 型として扱うことにより、xaml オブジェクトライターにインスタンスを返すことができる必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="ba7d0-150">XAML 2009 を使用している場合、前の考慮事項が満たされていない場合、 [X:Reference マークアップ拡張機能](x-reference-markup-extension.md)を使用して値を指定できます。ただし、これは、型定義の問題よりも使用の問題になります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-150">If using XAML 2009, [x:Reference Markup Extension](x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="ba7d0-151">イベント</span><span class="sxs-lookup"><span data-stu-id="ba7d0-151">Events</span></span>  
 <span data-ttu-id="ba7d0-152">イベントをパブリック CLR イベントとして定義すると、XAML 型システムは、`true`として <xref:System.Xaml.XamlMember.IsEvent%2A> を持つメンバーとしてイベントを報告できます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="ba7d0-153">イベントハンドラーの配線は、.NET Framework XAML サービスの機能の範囲内ではありません。これは、特定のフレームワークと実装に残されています。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="ba7d0-154">メソッド</span><span class="sxs-lookup"><span data-stu-id="ba7d0-154">Methods</span></span>  
 <span data-ttu-id="ba7d0-155">メソッドのインラインコードは、既定の XAML 機能ではありません。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="ba7d0-156">ほとんどの場合、XAML からメソッドメンバーを直接参照するのではなく、XAML のメソッドのロールは特定の XAML パターンのサポートのみを提供します。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="ba7d0-157">[X:FactoryMethod ディレクティブ](x-factorymethod-directive.md)は例外です。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-157">[x:FactoryMethod Directive](x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="ba7d0-158">フィールド</span><span class="sxs-lookup"><span data-stu-id="ba7d0-158">Fields</span></span>  
 <span data-ttu-id="ba7d0-159">CLR デザインガイドラインでは、非静的フィールドを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="ba7d0-160">静的フィールドの場合は、 [X:Static マークアップ拡張機能](x-static-markup-extension.md)を使用してのみ、静的フィールド値にアクセスできます。この場合は、CLR 定義で特別な処理を行わずに、 [x:Static](x-static-markup-extension.md) usage のフィールドを公開しています。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-160">For static fields, you can access static field values only through [x:Static Markup Extension](x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="ba7d0-161">アタッチ可能なメンバー</span><span class="sxs-lookup"><span data-stu-id="ba7d0-161">Attachable Members</span></span>  
 <span data-ttu-id="ba7d0-162">アタッチ可能なメンバーは、定義する型のアクセサーメソッドパターンを通じて XAML に公開されます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="ba7d0-163">定義する型自体は、オブジェクトとして XAML で使用できる必要はありません。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="ba7d0-164">実際、一般的なパターンは、アタッチ可能なメンバーを所有し、関連する動作を実装する役割を持つサービスクラスを宣言することですが、UI 表現などの他の機能は提供しません。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="ba7d0-165">次のセクションでは、プレースホルダー *PropertyName*はアタッチ可能なメンバーの名前を表しています。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="ba7d0-166">この名前は、 [XamlName 文法](xamlname-grammar.md)で有効である必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="ba7d0-167">これらのパターンと型の他のメソッドとの間で名前の競合が発生している場合は注意してください。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="ba7d0-168">いずれかのパターンに一致するメンバーが存在する場合、そのメンバーは、意図していない場合でも、XAML プロセッサによってアタッチ可能なメンバーの使用経路として解釈されます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="ba7d0-169">GetPropertyName アクセサー</span><span class="sxs-lookup"><span data-stu-id="ba7d0-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="ba7d0-170">`Get`*PropertyName* アクセサーのシグネチャは次の形式にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="ba7d0-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span><span class="sxs-lookup"><span data-stu-id="ba7d0-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
- <span data-ttu-id="ba7d0-172">`target` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="ba7d0-173">これを使用して、アタッチ可能なメンバーの使用をスコープすることができます。意図したスコープ外の使用法は、XAML 解析エラーによって表示される無効なキャスト例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="ba7d0-174">パラメーター名 `target` は要件ではありませんが、ほとんどの実装では、規則によって `target` という名前が付けられます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
- <span data-ttu-id="ba7d0-175">戻り値は、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="ba7d0-176">アタッチ可能なメンバーの属性使用に対して <xref:System.ComponentModel.TypeConverter> 有効なテキスト構文をサポートするには、<xref:System.ComponentModel.TypeConverterAttribute> を `Get`*PropertyName*アクセサーに適用します。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="ba7d0-177">`set` ではなく `get` に適用すると、nonintuitive のように見えます。ただし、この規則では、シリアル化可能な読み取り専用のアタッチ可能なメンバーの概念をサポートできます。これは、デザイナーのシナリオで役立ちます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="ba7d0-178">SetPropertyName アクセサー</span><span class="sxs-lookup"><span data-stu-id="ba7d0-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="ba7d0-179">Set*PropertyName*アクセサーのシグネチャは次のようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="ba7d0-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span><span class="sxs-lookup"><span data-stu-id="ba7d0-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
- <span data-ttu-id="ba7d0-181">`target` オブジェクトは、前のセクションで説明したのと同じロジックと結果を使用して、実装でより具体的な型として指定できます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
- <span data-ttu-id="ba7d0-182">`value` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="ba7d0-183">このメソッドの値は、XAML の使用 (通常は属性の形式) からの入力であることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="ba7d0-184">属性形式では、テキスト構文に対して値コンバーターがサポートされている必要があります。また、`Get`*PropertyName*アクセサーに対して属性を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="ba7d0-185">アタッチ可能なメンバーストア</span><span class="sxs-lookup"><span data-stu-id="ba7d0-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="ba7d0-186">アクセサーメソッドは、通常、アタッチ可能なメンバー値をオブジェクトグラフに配置したり、オブジェクトグラフから値を取得して適切にシリアル化したりするための手段を提供するためのものではありません。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="ba7d0-187">この機能を提供するには、前のアクセサーシグネチャの `target` オブジェクトが値を格納できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="ba7d0-188">ストレージメカニズムは、アタッチ可能なメンバーがメンバーリストに含まれていないターゲットにアタッチできるメンバーである、アタッチ可能なメンバープリンシパルと一致している必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="ba7d0-189">.NET Framework XAML サービスは、Api <xref:System.Xaml.IAttachedPropertyStore> と <xref:System.Xaml.AttachablePropertyServices>を通じて、アタッチ可能なメンバーストアの実装手法を提供します。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="ba7d0-190"><xref:System.Xaml.IAttachedPropertyStore> は、ストアの実装を検出するために XAML ライターによって使用され、アクセサーの `target` である型に実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="ba7d0-191">静的 <xref:System.Xaml.AttachablePropertyServices> Api は、アクセサーの本体内で使用され、<xref:System.Xaml.AttachableMemberIdentifier>によってアタッチ可能なメンバーを参照します。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="ba7d0-192">XAML 関連の CLR 属性</span><span class="sxs-lookup"><span data-stu-id="ba7d0-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="ba7d0-193">XAML 型システム情報を XAML サービス .NET Framework に報告するには、型、メンバー、およびアセンブリを正しく属性することが重要です。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="ba7d0-194">これは、.NET Framework XAML サービスの XAML リーダーと XAML ライターに直接基づいている XAML システムで型を使用する場合、または xaml リーダーと XAML ライターに基づく XAML を使用するフレームワークを定義または使用する場合に関連します。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="ba7d0-195">カスタム型の XAML サポートに関連する各 XAML 関連の属性の一覧については、「[カスタム型およびライブラリの Xaml 関連の CLR 属性](xaml-related-clr-attributes-for-custom-types-and-libraries.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="ba7d0-196">使用方法</span><span class="sxs-lookup"><span data-stu-id="ba7d0-196">Usage</span></span>  
 <span data-ttu-id="ba7d0-197">カスタム型を使用するには、マークアップの作成者が、カスタム型を含むアセンブリと CLR 名前空間のプレフィックスをマップする必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="ba7d0-198">この手順については、このトピックでは説明しません。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="ba7d0-199">アクセスレベル</span><span class="sxs-lookup"><span data-stu-id="ba7d0-199">Access Level</span></span>  
 <span data-ttu-id="ba7d0-200">XAML には、`internal` アクセスレベルを持つ型を読み込んでインスタンス化するための手段が用意されています。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="ba7d0-201">この機能は、ユーザーコードが独自の型を定義し、同じユーザーコードスコープの一部でもあるマークアップからそれらのクラスをインスタンス化できるようにするために用意されています。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="ba7d0-202">WPF の例として、ユーザーコードで UI 動作をリファクターする手段として使用する <xref:System.Windows.Controls.UserControl> を定義する場合があります。ただし、サポートクラスを `public` アクセスレベルで宣言することによって暗黙になる可能性のある拡張機能の一部としては使用できません。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="ba7d0-203">バッキングコードを XAML 型として参照される同じアセンブリにコンパイルする場合は、このような <xref:System.Windows.Controls.UserControl> を `internal` アクセスで宣言できます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="ba7d0-204">完全信頼で XAML を読み込み、<xref:System.Xaml.XamlObjectWriter>を使用するアプリケーションの場合、`internal` アクセスレベルを持つクラスの読み込みは常に有効になります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="ba7d0-205">部分信頼で XAML を読み込むアプリケーションの場合は、<xref:System.Xaml.Permissions.XamlAccessLevel> API を使用してアクセスレベルの特性を制御できます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="ba7d0-206">また、遅延メカニズム (WPF テンプレートシステムなど) は、すべてのアクセスレベルのアクセス許可を伝達し、最終的な実行時の評価のためにそれらを保持できる必要があります。これは <xref:System.Xaml.Permissions.XamlAccessLevel> 情報を渡すことによって内部的に処理されます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="ba7d0-207">WPF の実装</span><span class="sxs-lookup"><span data-stu-id="ba7d0-207">WPF Implementation</span></span>  
 <span data-ttu-id="ba7d0-208">WPF XAML では、部分信頼アクセスモデルが使用されます。この場合、BAML が部分信頼で読み込まれると、BAML ソースであるアセンブリのアクセスが <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> に制限されます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="ba7d0-209">遅延の場合、WPF はアクセスレベル情報を渡すためのメカニズムとして <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> を使用します。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="ba7d0-210">WPF XAML 用語では、*内部型*は、参照元の xaml も含む同じアセンブリによって定義される型です。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="ba7d0-211">このような型は、`xmlns:local="clr-namespace:WPFApplication1"`など、割り当てのアセンブリを意図的に省略する XAML 名前空間を使用してマップできます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="ba7d0-212">BAML が内部型を参照し、その型に `internal` アクセスレベルがある場合、アセンブリの `GeneratedInternalTypeHelper` クラスが生成されます。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="ba7d0-213">`GeneratedInternalTypeHelper`を回避するには、`public` アクセスレベルを使用するか、関連するクラスを別のアセンブリに分けて、そのアセンブリを依存させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba7d0-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ba7d0-214">関連項目</span><span class="sxs-lookup"><span data-stu-id="ba7d0-214">See also</span></span>

- [<span data-ttu-id="ba7d0-215">カスタム型およびライブラリの XAML 関連の CLR 属性</span><span class="sxs-lookup"><span data-stu-id="ba7d0-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](xaml-related-clr-attributes-for-custom-types-and-libraries.md)
- [<span data-ttu-id="ba7d0-216">XAML サービス</span><span class="sxs-lookup"><span data-stu-id="ba7d0-216">XAML Services</span></span>](index.md)
