---
title: CLR プロファイラと Windows ストア アプリ
ms.date: 03/30/2017
dev_langs:
- csharp
applies_to:
- Windows 10
- Windows 8
helpviewer_keywords:
- profiling API
- profiling API [.NET Framework]
- profiling managed code
- profiling managed code [Windows Store Apps]
ms.assetid: 1c8eb2e7-f20a-42f9-a795-71503486a0f5
ms.openlocfilehash: da5942f9a2138a536d158f75a6977d20bf31b41c
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/30/2019
ms.locfileid: "73140385"
---
# <a name="clr-profilers-and-windows-store-apps"></a><span data-ttu-id="77994-102">CLR プロファイラと Windows ストア アプリ</span><span class="sxs-lookup"><span data-stu-id="77994-102">CLR Profilers and Windows Store Apps</span></span>

<span data-ttu-id="77994-103">このトピックでは、Windows ストアアプリ内で実行されているマネージコードを分析する診断ツールを記述するときに考慮する必要がある事項について説明します。</span><span class="sxs-lookup"><span data-stu-id="77994-103">This topic discusses what you need to think about when writing diagnostic tools that analyze managed code running inside a Windows Store app.</span></span> <span data-ttu-id="77994-104">また、既存の開発ツールを Windows ストアアプリに対して実行するときに引き続き機能するように変更するためのガイドラインも提供します。</span><span class="sxs-lookup"><span data-stu-id="77994-104">It also provides guidelines to modify your existing development tools so they continue to work when you run them against Windows Store apps.</span></span> <span data-ttu-id="77994-105">この情報を理解するには、共通言語ランタイムプロファイル API を使い慣れていることをお勧めします。 Windows デスクトップアプリケーションに対して正しく実行される診断ツールで既にこの API を使用しているので、ツールを変更することをお勧めします。Windows ストアアプリに対して正常に実行されます。</span><span class="sxs-lookup"><span data-stu-id="77994-105">To understand this information, it’s best if you're  familiar with the Common Language Runtime Profiling API, you’ve already used this API in a diagnostic tool that runs correctly against Windows desktop applications, and you’re now interested in modifying the tool to run correctly against Windows Store apps.</span></span>

## <a name="introduction"></a><span data-ttu-id="77994-106">はじめに</span><span class="sxs-lookup"><span data-stu-id="77994-106">Introduction</span></span>

<span data-ttu-id="77994-107">入門用の段落を過ぎた場合は、CLR プロファイル API について理解している必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-107">If you made it past the introductory paragraph, then you’re familiar with the CLR Profiling API.</span></span> <span data-ttu-id="77994-108">管理対象のデスクトップアプリケーションに対して適切に機能する診断ツールが既に作成されています。</span><span class="sxs-lookup"><span data-stu-id="77994-108">You’ve already written a diagnostic tool that works well against managed desktop applications.</span></span> <span data-ttu-id="77994-109">ここで、ツールが管理対象の Windows ストアアプリで動作するようにするための作業について説明します。</span><span class="sxs-lookup"><span data-stu-id="77994-109">Now you’re curious what to do so that your tool works with a managed Windows Store app.</span></span> <span data-ttu-id="77994-110">既にこの作業を行ったことがあるかもしれませんが、これは簡単な作業ではないことを発見しました。</span><span class="sxs-lookup"><span data-stu-id="77994-110">Perhaps you’ve already tried to make this work, and have discovered that it’s not a straightforward task.</span></span> <span data-ttu-id="77994-111">実際には、すべてのツール開発者にとって明らかでない可能性がある考慮事項がいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="77994-111">Indeed, there are a number of considerations that might not be obvious to all tools developers.</span></span> <span data-ttu-id="77994-112">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="77994-112">For example:</span></span>

- <span data-ttu-id="77994-113">Windows ストアアプリは、大幅に削減されたアクセス許可を持つコンテキストで実行されます。</span><span class="sxs-lookup"><span data-stu-id="77994-113">Windows Store apps run in a context with severely reduced permissions.</span></span>

- <span data-ttu-id="77994-114">Windows メタデータファイルには、従来のマネージモジュールと比較した場合の固有の特性があります。</span><span class="sxs-lookup"><span data-stu-id="77994-114">Windows Metadata files have unique characteristics when compared to traditional managed modules.</span></span>

- <span data-ttu-id="77994-115">Windows ストアアプリは、対話機能が停止したときに自身を中断する習慣を持ちます。</span><span class="sxs-lookup"><span data-stu-id="77994-115">Windows Store apps have a habit of suspending themselves when interactivity goes down.</span></span>

- <span data-ttu-id="77994-116">プロセス間の通信メカニズムは、さまざまな理由で機能しなくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="77994-116">Your inter-process communication mechanisms may no longer work for various reasons.</span></span>

<span data-ttu-id="77994-117">このトピックでは、注意する必要がある事項と、それらを適切に処理する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="77994-117">This topic lists the things you need to be aware of and how to deal with them properly.</span></span>

<span data-ttu-id="77994-118">CLR プロファイル API を初めて使用する場合は、このトピックの最後にあるリソースに進んで、より良い概要情報を確認してください。</span><span class="sxs-lookup"><span data-stu-id="77994-118">If you’re new to the CLR Profiling API, skip down to the Resources at the end of this topic to find better introductory information.</span></span>

<span data-ttu-id="77994-119">特定の Windows Api の詳細とその使用方法についても、このトピックでは説明しません。</span><span class="sxs-lookup"><span data-stu-id="77994-119">Providing detail about specific Windows APIs and how they should be used is also outside the scope of this topic.</span></span> <span data-ttu-id="77994-120">このトピックは出発点として、MSDN を参照して、ここで参照されている Windows Api の詳細を確認してください。</span><span class="sxs-lookup"><span data-stu-id="77994-120">Consider this topic a starting point, and refer to MSDN to learn more about any Windows APIs referenced here.</span></span>

## <a name="architecture-and-terminology"></a><span data-ttu-id="77994-121">アーキテクチャと用語</span><span class="sxs-lookup"><span data-stu-id="77994-121">Architecture and terminology</span></span>

<span data-ttu-id="77994-122">通常、診断ツールには、次の図に示すようなアーキテクチャがあります。</span><span class="sxs-lookup"><span data-stu-id="77994-122">Typically, a diagnostic tool has an architecture like the one shown in the following illustration.</span></span> <span data-ttu-id="77994-123">"Profiler" という用語を使用しますが、このようなツールの多くは、コードカバレッジ、モックオブジェクトフレームワーク、タイムトラベルデバッグ、アプリケーション監視などの領域への一般的なパフォーマンスまたはメモリのプロファイリングよりも優れています。</span><span class="sxs-lookup"><span data-stu-id="77994-123">It uses the term "profiler," but many such tools go well beyond typical performance or memory profiling into areas such as code coverage, mock object frameworks, time-travel debugging, application monitoring, and so on.</span></span> <span data-ttu-id="77994-124">わかりやすくするために、このトピックでは、これらすべてのツールをプロファイラーと呼びます。</span><span class="sxs-lookup"><span data-stu-id="77994-124">For simplicity, this topic will continue to refer to all these tools as profilers.</span></span>

<span data-ttu-id="77994-125">このトピックでは、次の用語を使用します。</span><span class="sxs-lookup"><span data-stu-id="77994-125">The following terminology is used throughout this topic:</span></span>

<span data-ttu-id="77994-126">**アプリケーション**</span><span class="sxs-lookup"><span data-stu-id="77994-126">**Application**</span></span>

<span data-ttu-id="77994-127">これは、プロファイラーが分析しているアプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="77994-127">This is the application that the profiler is analyzing.</span></span> <span data-ttu-id="77994-128">通常、このアプリケーションの開発者は、アプリケーションの問題を診断するためにプロファイラーを使用しています。</span><span class="sxs-lookup"><span data-stu-id="77994-128">Typically, the developer of this application is now using the profiler to help diagnose issues with the application.</span></span> <span data-ttu-id="77994-129">従来、このアプリケーションは Windows デスクトップアプリケーションですが、このトピックでは Windows ストアアプリについて見ていきます。</span><span class="sxs-lookup"><span data-stu-id="77994-129">Traditionally, this application would be a Windows desktop application, but in this topic, we’re looking at Windows Store apps.</span></span>

<span data-ttu-id="77994-130">**プロファイラー DLL**</span><span class="sxs-lookup"><span data-stu-id="77994-130">**Profiler DLL**</span></span>

<span data-ttu-id="77994-131">これは、分析対象のアプリケーションのプロセス空間に読み込まれるコンポーネントです。</span><span class="sxs-lookup"><span data-stu-id="77994-131">This is the component that loads into the process space of the application being analyzed.</span></span> <span data-ttu-id="77994-132">このコンポーネントは、"エージェント" とも呼ばれ、 [ICorProfilerCallback](icorprofilercallback-interface.md)[ICorProfilerCallback Interface](icorprofilercallback-interface.md)(2, 3) インターフェイスを実装し、 [ICorProfilerInfo](icorprofilerinfo-interface.md)(2, 3 など) インターフェイスを使用してデータを収集します。アプリケーションを分析し、アプリケーションの動作の側面を変更する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="77994-132">This component, also known as the profiler "agent," implements the [ICorProfilerCallback](icorprofilercallback-interface.md)[ICorProfilerCallback Interface](icorprofilercallback-interface.md)(2,3,etc.) interfaces and consumes the [ICorProfilerInfo](icorprofilerinfo-interface.md)(2,3,etc.) interfaces to collect data about the analyzed application and potentially modify aspects of the application’s behavior.</span></span>

<span data-ttu-id="77994-133">**プロファイラー UI**</span><span class="sxs-lookup"><span data-stu-id="77994-133">**Profiler UI**</span></span>

<span data-ttu-id="77994-134">これは、プロファイラーユーザーが操作するデスクトップアプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="77994-134">This is a desktop application that the profiler user interacts with.</span></span> <span data-ttu-id="77994-135">アプリケーションの状態をユーザーに表示し、分析されたアプリケーションの動作を制御する手段をユーザーに与える必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-135">It’s responsible for displaying application status to the user and giving the user the means to control the behavior of the analyzed application.</span></span> <span data-ttu-id="77994-136">このコンポーネントは、プロファイル対象のアプリケーションのプロセス空間とは別に、常に独自のプロセス空間で実行されます。</span><span class="sxs-lookup"><span data-stu-id="77994-136">This component always runs in its own process space, separate from the process space of the application being profiled.</span></span> <span data-ttu-id="77994-137">プロファイラー UI は、 [ICLRProfiling:: AttachProfiler](iclrprofiling-attachprofiler-method.md)メソッドを呼び出すプロセスである "アタッチトリガー" として機能することもあります。これは、プロファイラー dll が起動時に読み込まれなかった場合に、分析されたアプリケーションがプロファイラー dll を読み込むために使用します。</span><span class="sxs-lookup"><span data-stu-id="77994-137">The Profiler UI can also act as the "attach trigger," which is the process that calls the [ICLRProfiling::AttachProfiler](iclrprofiling-attachprofiler-method.md) method, to cause the analyzed application to load the Profiler DLL in those cases where the profiler DLL did not load on startup.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="77994-138">プロファイラーの UI は、windows ストアアプリの制御とレポートに使用されている場合でも、Windows デスクトップアプリケーションのままにしておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-138">Your Profiler UI should remain a Windows desktop application, even when it is used to control and report on a Windows Store app.</span></span> <span data-ttu-id="77994-139">Windows ストアに診断ツールをパッケージ化して出荷できるとは思わないでください。</span><span class="sxs-lookup"><span data-stu-id="77994-139">Don’t expect to be able to package and ship your diagnostics tool in the Windows Store.</span></span> <span data-ttu-id="77994-140">ツールでは、Windows ストアアプリが実行できない処理を実行する必要があり、その多くはプロファイラー UI 内に存在します。</span><span class="sxs-lookup"><span data-stu-id="77994-140">Your tool needs to do things that Windows Store apps cannot do, and many of those things reside inside your Profiler UI.</span></span>

<span data-ttu-id="77994-141">このドキュメント全体で、サンプルコードでは次のことを前提としています。</span><span class="sxs-lookup"><span data-stu-id="77994-141">Throughout this document, the sample code assumes that:</span></span>

- <span data-ttu-id="77994-142">プロファイラー DLL は、CLR プロファイルC++API の要件に従って、ネイティブ dll である必要があるため、で記述されています。</span><span class="sxs-lookup"><span data-stu-id="77994-142">Your Profiler DLL is written in C++, because it must be a native DLL, as per the requirements of the CLR Profiling API.</span></span>

- <span data-ttu-id="77994-143">プロファイラーの UI は、でC#記述されています。</span><span class="sxs-lookup"><span data-stu-id="77994-143">Your Profiler UI is written in C#.</span></span> <span data-ttu-id="77994-144">これは必要ありませんが、プロファイラー UI のプロセスの言語には要件がないため、簡潔で単純な言語を選択できないのはなぜですか。</span><span class="sxs-lookup"><span data-stu-id="77994-144">This isn’t necessary, but because there are no requirements on the language for your Profiler UI’s process, why not pick a language that’s concise and simple?</span></span>

### <a name="windows-rt-devices"></a><span data-ttu-id="77994-145">Windows RT デバイス</span><span class="sxs-lookup"><span data-stu-id="77994-145">Windows RT devices</span></span>

<span data-ttu-id="77994-146">Windows RT デバイスは非常にロックダウンされています。</span><span class="sxs-lookup"><span data-stu-id="77994-146">Windows RT devices are quite locked down.</span></span> <span data-ttu-id="77994-147">サードパーティのプロファイラーは、単純にそのようなデバイスに読み込むことができません。</span><span class="sxs-lookup"><span data-stu-id="77994-147">Third-party profilers simply cannot be loaded on such devices.</span></span> <span data-ttu-id="77994-148">このドキュメントでは、Windows 8 Pc に焦点を当てています。</span><span class="sxs-lookup"><span data-stu-id="77994-148">This document focuses on Windows 8 PCs.</span></span>

## <a name="consuming-windows-runtime-apis"></a><span data-ttu-id="77994-149">Windows ランタイム Api の使用</span><span class="sxs-lookup"><span data-stu-id="77994-149">Consuming Windows Runtime APIs</span></span>

<span data-ttu-id="77994-150">以下のセクションで説明するいくつかのシナリオでは、Profiler UI デスクトップアプリケーションは、いくつかの新しい Windows ランタイム Api を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-150">In a number of scenarios discussed in the following sections, your Profiler UI desktop application needs to consume some new Windows Runtime APIs.</span></span> <span data-ttu-id="77994-151">このドキュメントを参照して、デスクトップアプリケーションから使用できる Windows ランタイム Api と、デスクトップアプリケーションや Windows ストアアプリから呼び出されたときの動作が異なるかどうかを理解します。</span><span class="sxs-lookup"><span data-stu-id="77994-151">You’ll want to consult the documentation to understand which Windows Runtime APIs can be used from desktop applications, and whether their behavior is different when called from desktop applications and Windows Store apps.</span></span>

<span data-ttu-id="77994-152">プロファイラーの UI がマネージコードで記述されている場合は、これらの Windows ランタイム Api を簡単に使用できるようにするために必要な手順がいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="77994-152">If your Profiler UI is written in managed code, there will be a few steps you’ll need to do to make consuming those Windows Runtime APIs easy.</span></span> <span data-ttu-id="77994-153">詳細については、「[マネージデスクトップアプリと Windows ランタイム](https://go.microsoft.com/fwlink/?LinkID=271858)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="77994-153">See the [Managed desktop apps and Windows Runtime](https://go.microsoft.com/fwlink/?LinkID=271858) article for more information.</span></span>

## <a name="loading-the-profiler-dll"></a><span data-ttu-id="77994-154">プロファイラー DLL を読み込んでいます</span><span class="sxs-lookup"><span data-stu-id="77994-154">Loading the Profiler DLL</span></span>

<span data-ttu-id="77994-155">このセクションでは、プロファイラーの UI によって、Windows ストアアプリがプロファイラー DLL を読み込む方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="77994-155">This section describes how your Profiler UI causes the Windows Store app to load your Profiler DLL.</span></span> <span data-ttu-id="77994-156">このセクションで説明するコードは、Profiler UI デスクトップアプリに属しているため、デスクトップアプリには安全な Windows Api を使用しますが、Windows ストアアプリでは安全であるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="77994-156">The code discussed in this section belongs in your Profiler UI desktop app, and therefore involves using Windows APIs that are safe for desktop apps but not necessarily safe for Windows Store apps.</span></span>

<span data-ttu-id="77994-157">プロファイラーの UI を使用すると、次の2つの方法でプロファイラー DLL をアプリケーションのプロセス領域に読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="77994-157">Your Profiler UI can cause your Profiler DLL to be loaded into the application’s process space in two ways:</span></span>

- <span data-ttu-id="77994-158">アプリケーションの起動時に、環境変数によって制御されます。</span><span class="sxs-lookup"><span data-stu-id="77994-158">At application startup, as controlled by environment variables.</span></span>

- <span data-ttu-id="77994-159">[ICLRProfiling:: AttachProfiler](iclrprofiling-attachprofiler-method.md)メソッドを呼び出すことによって、スタートアップの完了後にアプリケーションにアタッチします。</span><span class="sxs-lookup"><span data-stu-id="77994-159">By attaching to the application after startup is complete by calling the [ICLRProfiling::AttachProfiler](iclrprofiling-attachprofiler-method.md) method.</span></span>

<span data-ttu-id="77994-160">最初の問題点の1つは、Windows ストアアプリで正常に動作するように、プロファイラー DLL のスタートアップ読み込みとアタッチ-読み込みを取得することです。</span><span class="sxs-lookup"><span data-stu-id="77994-160">One of your first roadblocks will be getting startup-load and attach-load of your Profiler DLL to work properly with Windows Store apps.</span></span> <span data-ttu-id="77994-161">どちらの形式の読み込みでも、一般的ないくつかの特別な考慮事項が共有されるので、ここから始めましょう。</span><span class="sxs-lookup"><span data-stu-id="77994-161">Both forms of loading share some special considerations in common, so let’s start with them.</span></span>

### <a name="common-considerations-for-startup-and-attach-loads"></a><span data-ttu-id="77994-162">スタートアップとアタッチの読み込みに関する一般的な考慮事項</span><span class="sxs-lookup"><span data-stu-id="77994-162">Common considerations for startup and attach loads</span></span>

<span data-ttu-id="77994-163">**プロファイラー DLL に署名しています**</span><span class="sxs-lookup"><span data-stu-id="77994-163">**Signing your Profiler DLL**</span></span>

<span data-ttu-id="77994-164">Windows がプロファイラー DLL を読み込もうとすると、プロファイラー DLL が正しく署名されているかどうかが検証されます。</span><span class="sxs-lookup"><span data-stu-id="77994-164">When Windows attempts to load your Profiler DLL, it verifies that your Profiler DLL is properly signed.</span></span> <span data-ttu-id="77994-165">それ以外の場合、既定では読み込みに失敗します。</span><span class="sxs-lookup"><span data-stu-id="77994-165">If not, the load fails by default.</span></span> <span data-ttu-id="77994-166">これには、2 つの方法があります。</span><span class="sxs-lookup"><span data-stu-id="77994-166">There are two ways to do this:</span></span>

- <span data-ttu-id="77994-167">プロファイラー DLL が署名されていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="77994-167">Ensure that your Profiler DLL is signed.</span></span>

- <span data-ttu-id="77994-168">ツールを使用する前に、Windows 8 コンピューターに開発者ライセンスをインストールする必要があることをユーザーに通知します。</span><span class="sxs-lookup"><span data-stu-id="77994-168">Tell your user that they must install a developer license on their Windows 8 machine before using your tool.</span></span> <span data-ttu-id="77994-169">これは、Visual Studio から自動的に実行することも、コマンドプロンプトから手動で行うこともできます。</span><span class="sxs-lookup"><span data-stu-id="77994-169">This can be done automatically from Visual Studio or manually from a command prompt.</span></span> <span data-ttu-id="77994-170">詳細については、「[開発者ライセンスを取得する](https://docs.microsoft.com/previous-versions/windows/apps/hh974578(v=win.10))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="77994-170">For more information, see [Get a developer license](https://docs.microsoft.com/previous-versions/windows/apps/hh974578(v=win.10)).</span></span>

<span data-ttu-id="77994-171">**ファイルシステムのアクセス許可**</span><span class="sxs-lookup"><span data-stu-id="77994-171">**File system permissions**</span></span>

<span data-ttu-id="77994-172">Windows ストアアプリには、residesBy が既定のファイルシステム上の場所からプロファイラー DLL を読み込んで実行するためのアクセス許可が必要です。また、Windows ストアアプリには、ほとんどのディレクトリに対するこのようなアクセス許可がありません。また、プロファイラー DLL の読み込みに失敗しました。では、Windows アプリケーションイベントログに次のようなエントリが生成されます。</span><span class="sxs-lookup"><span data-stu-id="77994-172">The Windows Store app must have permission to load and execute your Profiler DLL from the location on the file system in which it residesBy default, the Windows Store app doesn’t have such permission on most directories, and any failed attempt to load your Profiler DLL will produce an entry in the Windows Application event log that looks something like this:</span></span>

```output
NET Runtime version 4.0.30319.17929 - Loading profiler failed during CoCreateInstance.  Profiler CLSID: '{xxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}'.  HRESULT: 0x80070005.  Process ID (decimal): 4688.  Message ID: [0x2504].
```

<span data-ttu-id="77994-173">一般に、Windows ストアアプリでは、ディスク上の限られた場所にのみアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="77994-173">Generally, Windows Store apps are only allowed to access a limited set of locations on the disk.</span></span> <span data-ttu-id="77994-174">各 Windows ストアアプリは、独自のアプリケーションデータフォルダーにアクセスできます。また、ファイルシステム内の他のいくつかの領域を使用して、すべての Windows ストアアプリがアクセスを許可されるようにすることもできます。</span><span class="sxs-lookup"><span data-stu-id="77994-174">Each Windows Store app can access its own application data folders, as well as a few other areas in the file system for which all Windows Store apps are granted access.</span></span> <span data-ttu-id="77994-175">すべての Windows ストアアプリに既定で読み取りと実行のアクセス許可が付与されているので、プロファイラー DLL とその依存関係を Program Files または Program Files (x86) のどこかにインストールすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="77994-175">It's best to install your Profiler DLL and its dependencies somewhere under Program Files or Program Files (x86), because all Windows Store apps have read and execute permissions there by default.</span></span>

### <a name="startup-load"></a><span data-ttu-id="77994-176">スタートアップ読み込み</span><span class="sxs-lookup"><span data-stu-id="77994-176">Startup load</span></span>

<span data-ttu-id="77994-177">通常、デスクトップアプリでは、プロファイラーの UI は、必要な CLR プロファイリング API 環境変数 (つまり、`COR_PROFILER`、`COR_ENABLE_PROFILING`、および `COR_PROFILER_PATH`) を含む環境ブロックを初期化し、新しいを作成することによって、プロファイラー DLL のスタートアップ読み込みを要求します。その環境ブロックを使用して処理します。</span><span class="sxs-lookup"><span data-stu-id="77994-177">Typically, in a desktop app, your Profiler UI prompts a startup load of your Profiler DLL by initializing an environment block that contains the required CLR Profiling API environment variables (i.e., `COR_PROFILER`, `COR_ENABLE_PROFILING`, and `COR_PROFILER_PATH`), and then creating a new process with that environment block.</span></span> <span data-ttu-id="77994-178">Windows ストアアプリでも同じことが当てはまりますが、メカニズムは異なります。</span><span class="sxs-lookup"><span data-stu-id="77994-178">The same holds true for Windows Store apps, but the mechanisms are different.</span></span>

<span data-ttu-id="77994-179">**管理者特権で実行しない**</span><span class="sxs-lookup"><span data-stu-id="77994-179">**Don’t run elevated**</span></span>

<span data-ttu-id="77994-180">プロセス A が Windows ストアアプリのプロセス B を生成しようとした場合、プロセス A は高整合性レベル (つまり、昇格されていない) ではなく、中程度の整合性レベルで実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-180">If Process A attempts to spawn Windows Store app Process B, Process A should be run at medium integrity level, not at high integrity level (that is, not elevated).</span></span> <span data-ttu-id="77994-181">これは、Profiler UI が中程度の整合性レベルで実行されている必要があるか、または Windows ストアアプリの起動を処理するために、中程度の整合性レベルで別のデスクトッププロセスを生成する必要があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="77994-181">This means that either your Profiler UI should be running at medium integrity level, or it must spawn another desktop process at medium integrity level to take care of launching the Windows Store app.</span></span>

<span data-ttu-id="77994-182">**プロファイリングする Windows ストアアプリの選択**</span><span class="sxs-lookup"><span data-stu-id="77994-182">**Choosing a Windows Store App to profile**</span></span>

<span data-ttu-id="77994-183">最初に、起動する Windows ストアアプリをプロファイラーユーザーに要求します。</span><span class="sxs-lookup"><span data-stu-id="77994-183">First, you’ll want to ask your profiler user which Windows Store app to launch.</span></span> <span data-ttu-id="77994-184">デスクトップアプリの場合、ファイル参照ダイアログが表示され、ユーザーは .exe ファイルを見つけて選択します。</span><span class="sxs-lookup"><span data-stu-id="77994-184">For desktop apps, perhaps you’d show a file Browse dialog, and the user would find and select an .exe file.</span></span> <span data-ttu-id="77994-185">ただし、Windows ストアアプリは異なります。 [参照] ダイアログボックスを使用することは意味がありません。</span><span class="sxs-lookup"><span data-stu-id="77994-185">But Windows Store apps are different, and using a Browse dialog doesn’t make sense.</span></span> <span data-ttu-id="77994-186">代わりに、ユーザーが選択できるように、インストールされている Windows ストアアプリの一覧をユーザーに表示することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="77994-186">Instead, it’s better to show the user a list of Windows Store apps installed for that user to select from.</span></span>

<span data-ttu-id="77994-187"><xref:Windows.Management.Deployment.PackageManager> クラスを使用して、このリストを生成できます。</span><span class="sxs-lookup"><span data-stu-id="77994-187">You can use the <xref:Windows.Management.Deployment.PackageManager> class to generate this list.</span></span> <span data-ttu-id="77994-188">`PackageManager` はデスクトップアプリで使用できる Windows ランタイムクラスであり、実際にはデスクトップアプリで*のみ*使用できます。</span><span class="sxs-lookup"><span data-stu-id="77994-188">`PackageManager` is a Windows Runtime class that is available to desktop apps, and in fact it is *only* available to desktop apps.</span></span>

<span data-ttu-id="77994-189">次のコード例では、でC#デスクトップアプリとして記述された仮定のプロファイラー UI から、`PackageManager` を使用して Windows アプリの一覧を生成します。</span><span class="sxs-lookup"><span data-stu-id="77994-189">The following code example from a hypothetical Profiler UI written as a desktop app in C# uses the `PackageManager` to generate a list of Windows apps:</span></span>

```csharp
string currentUserSID = WindowsIdentity.GetCurrent().User.ToString();
IAppxFactory appxFactory = (IAppxFactory) new AppxFactory();
PackageManager packageManager = new PackageManager();
IEnumerable<Package> packages = packageManager.FindPackagesForUser(currentUserSID);
```

<span data-ttu-id="77994-190">**カスタム環境ブロックの指定**</span><span class="sxs-lookup"><span data-stu-id="77994-190">**Specifying the custom environment block**</span></span>

<span data-ttu-id="77994-191">新しい COM インターフェイス[Ipackagedebugsettings](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipackagedebugsettings)を使用すると、Windows ストアアプリの実行動作をカスタマイズして、何らかの形式の診断を簡単に行うことができます。</span><span class="sxs-lookup"><span data-stu-id="77994-191">A new COM interface, [IPackageDebugSettings](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipackagedebugsettings), allows you to customize the execution behavior of a Windows Store app to make some forms of diagnostics easier.</span></span> <span data-ttu-id="77994-192">[Enabledebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-enabledebugging)のメソッドの1つは、起動時に環境ブロックを Windows ストアアプリに渡すことができるほか、自動プロセス中断を無効にするなどの便利な効果があります。</span><span class="sxs-lookup"><span data-stu-id="77994-192">One of its methods, [EnableDebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-enabledebugging), lets you pass an environment block to the Windows Store app when it’s launched, along with other useful effects like disabling automatic process suspension.</span></span> <span data-ttu-id="77994-193">CLR がプロファイラー DLL を読み込むために使用する環境変数 (`COR_PROFILER`、`COR_ENABLE_PROFILING`、および `COR_PROFILER_PATH)`) を指定する必要があるため、環境ブロックは重要です。</span><span class="sxs-lookup"><span data-stu-id="77994-193">The environment block is important because that’s where you need to specify the environment variables (`COR_PROFILER`, `COR_ENABLE_PROFILING`, and `COR_PROFILER_PATH)`) used by the CLR to load your Profiler DLL .</span></span>

<span data-ttu-id="77994-194">次のコード スニペットを考えてみます。</span><span class="sxs-lookup"><span data-stu-id="77994-194">Consider the following code snippet:</span></span>

```csharp
IPackageDebugSettings pkgDebugSettings = new PackageDebugSettings();
pkgDebugSettings.EnableDebugging(packageFullName, debuggerCommandLine,
                                                                 (IntPtr)fixedEnvironmentPzz);
```

<span data-ttu-id="77994-195">次の2つの項目を取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-195">There are a couple of items you'll need to get right:</span></span>

- <span data-ttu-id="77994-196">`packageFullName` は、パッケージを繰り返し処理して `package.Id.FullName` を取得しているときに確認できます。</span><span class="sxs-lookup"><span data-stu-id="77994-196">`packageFullName` can be determined while iterating over the packages and grabbing `package.Id.FullName`.</span></span>

- <span data-ttu-id="77994-197">`debuggerCommandLine` はもう少し興味深いものです。</span><span class="sxs-lookup"><span data-stu-id="77994-197">`debuggerCommandLine` is a bit more interesting.</span></span> <span data-ttu-id="77994-198">カスタム環境ブロックを Windows ストアアプリに渡すために、独自の単純なダミーデバッガーを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-198">In order to pass the custom environment block to the Windows Store app, you need to write your own, simplistic dummy debugger.</span></span> <span data-ttu-id="77994-199">Windows ストアアプリが中断された後、次の例のようなコマンドラインを使用してデバッガーを起動すると、デバッガーがアタッチされます。</span><span class="sxs-lookup"><span data-stu-id="77994-199">Windows spawns the Windows Store app suspended and then attaches your debugger by launching your debugger with a command line like in this example:</span></span>

    ```console
    MyDummyDebugger.exe -p 1336 -tid 1424
    ```

     <span data-ttu-id="77994-200">`-p 1336` は、Windows ストアアプリにプロセス ID 1336 があることを意味し、`-tid 1424` はスレッド ID 1424 が中断されているスレッドであることを意味します。</span><span class="sxs-lookup"><span data-stu-id="77994-200">where `-p 1336` means the Windows Store app has Process ID 1336, and `-tid 1424` means Thread ID 1424 is the thread that is suspended.</span></span> <span data-ttu-id="77994-201">ダミーデバッガーは、コマンドラインから ThreadID を解析し、そのスレッドを再開してから終了します。</span><span class="sxs-lookup"><span data-stu-id="77994-201">Your dummy debugger would parse the ThreadID from the command-line, resume that thread, and then exit.</span></span>

     <span data-ttu-id="77994-202">これを行うコードC++例を次に示します (エラーチェックを必ず追加してください)。</span><span class="sxs-lookup"><span data-stu-id="77994-202">Here’s some example C++ code to do this (be sure to add error checking!):</span></span>

    ```cpp
    int wmain(int argc, wchar_t* argv[])
    {
        // …
        // Parse command line here
        // …

        HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME,
                                                                  FALSE /* bInheritHandle */, nThreadID);
        ResumeThread(hThread);
        CloseHandle(hThread);
        return 0;
    }
    ```

     <span data-ttu-id="77994-203">このダミーデバッガーを診断ツールのインストールの一部としてデプロイし、`debuggerCommandLine` パラメーターでこのデバッガーへのパスを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-203">You’ll need to deploy this dummy debugger as part of your diagnostics tool installation, and then specify the path to this debugger in the `debuggerCommandLine` parameter.</span></span>

<span data-ttu-id="77994-204">**Windows ストアアプリを起動しています**</span><span class="sxs-lookup"><span data-stu-id="77994-204">**Launching the Windows Store app**</span></span>

<span data-ttu-id="77994-205">Windows ストアアプリを起動すると、最後に到着します。</span><span class="sxs-lookup"><span data-stu-id="77994-205">The moment to launch the Windows Store app has finally arrived.</span></span> <span data-ttu-id="77994-206">これを既に試している場合は、 [CreateProcess](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa)が Windows ストアアプリプロセスを作成する方法ではないことに気が付きます。</span><span class="sxs-lookup"><span data-stu-id="77994-206">If you’ve already tried doing this yourself, you may have noticed that [CreateProcess](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa) is not how you create a Windows Store app process.</span></span> <span data-ttu-id="77994-207">代わりに、 [IApplicationActivationManager::::](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-iapplicationactivationmanager-activateapplication)を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-207">Instead, you’ll need to use the [IApplicationActivationManager::ActivateApplication](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-iapplicationactivationmanager-activateapplication) method.</span></span> <span data-ttu-id="77994-208">これを行うには、起動している Windows ストアアプリのアプリユーザーモデル ID を取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-208">To do that, you’ll need to get the App User Model ID of the Windows Store app that you’re launching.</span></span> <span data-ttu-id="77994-209">これは、マニフェストを少し掘り下げていく必要があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="77994-209">And that means you’ll need to do a little digging through the manifest.</span></span>

<span data-ttu-id="77994-210">パッケージを繰り返し処理しているとき (前の「[スタートアップロード](#startup-load)」セクションの「プロファイルする Windows ストアアプリを選択する」を参照してください)、現在のパッケージのマニフェストに含まれているアプリケーションのセットを取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-210">While iterating over your packages (see "Choosing a Windows Store App to Profile" in the [Startup load](#startup-load) section earlier), you’ll want to grab the set of applications contained in the current package’s manifest:</span></span>

```csharp
string manifestPath = package.InstalledLocation.Path + "\\AppxManifest.xml";

AppxPackaging.IStream manifestStream;
SHCreateStreamOnFileEx(
                    manifestPath,
                    0x00000040,     // STGM_READ | STGM_SHARE_DENY_NONE
                    0,              // file creation attributes
                    false,          // fCreate
                    null,           // reserved
                    out manifestStream);

IAppxManifestReader manifestReader = appxFactory.CreateManifestReader(manifestStream);

IAppxManifestApplicationsEnumerator appsEnum = manifestReader.GetApplications();
```

<span data-ttu-id="77994-211">はい。1つのパッケージに複数のアプリケーションを含めることができ、各アプリケーションには独自のアプリケーションユーザーモデル ID があります。</span><span class="sxs-lookup"><span data-stu-id="77994-211">Yes, one package can have multiple applications, and each application has its own Application User Model ID.</span></span> <span data-ttu-id="77994-212">そのため、プロファイルするアプリケーションをユーザーに要求し、その特定のアプリケーションからアプリケーションユーザーモデル ID を取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-212">So you’ll want to ask your user which application to profile, and grab the Application User Model ID from that particular application:</span></span>

```csharp
while (appsEnum.GetHasCurrent() != 0)
{
    IAppxManifestApplication app = appsEnum.GetCurrent();
    string appUserModelId = app.GetAppUserModelId();
    //...
}
```

<span data-ttu-id="77994-213">最後に、Windows ストアアプリを起動するために必要なものが完成しました。</span><span class="sxs-lookup"><span data-stu-id="77994-213">Finally, you now have what you need to launch the Windows Store app:</span></span>

```csharp
IApplicationActivationManager appActivationMgr = new ApplicationActivationManager();
appActivationMgr.ActivateApplication(appUserModelId, appArgs, ACTIVATEOPTIONS.AO_NONE, out pid);
```

<span data-ttu-id="77994-214">**DisableDebugging を必ず呼び出してください**</span><span class="sxs-lookup"><span data-stu-id="77994-214">**Remember to call DisableDebugging**</span></span>

<span data-ttu-id="77994-215">[Ipackagedebugsettings:: EnableDebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-enabledebugging)を呼び出したときに、 [ipackagedebugsettings::D isabledebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-disabledebugging)メソッドを呼び出して自分でクリーンアップすることを約束しました。そのため、プロファイルセッションが終了しているときは、このことを確認してください。</span><span class="sxs-lookup"><span data-stu-id="77994-215">When you called [IPackageDebugSettings::EnableDebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-enabledebugging), you made a promise that you would clean up after yourself by calling the [IPackageDebugSettings::DisableDebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-disabledebugging) method, so be sure to do that when the profiling session is over.</span></span>

### <a name="attach-load"></a><span data-ttu-id="77994-216">読み込みのアタッチ</span><span class="sxs-lookup"><span data-stu-id="77994-216">Attach load</span></span>

<span data-ttu-id="77994-217">プロファイラーの UI が、既に実行を開始しているアプリケーションにプロファイラー DLL をアタッチする場合、 [ICLRProfiling:: AttachProfiler](iclrprofiling-attachprofiler-method.md)を使用します。</span><span class="sxs-lookup"><span data-stu-id="77994-217">When your Profiler UI wants to attach its Profiler DLL to an application that has already started running, it uses [ICLRProfiling::AttachProfiler](iclrprofiling-attachprofiler-method.md).</span></span> <span data-ttu-id="77994-218">Windows ストアアプリでも同じことが当てはまります。</span><span class="sxs-lookup"><span data-stu-id="77994-218">The same holds true with Windows Store apps.</span></span> <span data-ttu-id="77994-219">ただし、前に示した一般的な考慮事項に加えて、ターゲットの Windows ストアアプリが中断されていないことを確認してください。</span><span class="sxs-lookup"><span data-stu-id="77994-219">But in addition to the common considerations listed earlier, make sure the that the target Windows Store app is not suspended.</span></span>

<span data-ttu-id="77994-220">**EnableDebugging**</span><span class="sxs-lookup"><span data-stu-id="77994-220">**EnableDebugging**</span></span>

<span data-ttu-id="77994-221">スタートアップロードと同様に、 [Ipackagedebugsettings:: EnableDebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-enabledebugging)メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="77994-221">As with startup load, call the [IPackageDebugSettings::EnableDebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-enabledebugging) method.</span></span> <span data-ttu-id="77994-222">環境ブロックを渡すためには必要ありませんが、その他の機能の1つ (自動プロセス中断の無効化) が必要です。</span><span class="sxs-lookup"><span data-stu-id="77994-222">You don’t need it for passing an environment block, but you need one of its other features: disabling automatic process suspension.</span></span> <span data-ttu-id="77994-223">それ以外の場合、プロファイラーの UI が[Attachprofiler](iclrprofiling-attachprofiler-method.md)を呼び出すと、ターゲットの Windows ストアアプリが中断される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="77994-223">Otherwise, when your Profiler UI calls [AttachProfiler](iclrprofiling-attachprofiler-method.md), the target Windows Store app may be suspended.</span></span> <span data-ttu-id="77994-224">実際には、ユーザーがプロファイラー UI を操作していて、Windows ストアアプリがユーザーの画面でアクティブになっていない場合があります。</span><span class="sxs-lookup"><span data-stu-id="77994-224">In fact, this is likely if the user is now interacting with your Profiler UI, and the Windows Store app is not active on any of the user’s screens.</span></span> <span data-ttu-id="77994-225">また、Windows ストアアプリが中断されている場合は、CLR がプロファイラー DLL をアタッチするために送信するシグナルに応答できません。</span><span class="sxs-lookup"><span data-stu-id="77994-225">And if the Windows Store app is suspended, it won’t be able to respond to any signal that the CLR sends to it to attach your Profiler DLL.</span></span>

<span data-ttu-id="77994-226">次のようにします。</span><span class="sxs-lookup"><span data-stu-id="77994-226">So you’ll want to do something like this:</span></span>

```csharp
IPackageDebugSettings pkgDebugSettings = new PackageDebugSettings();
pkgDebugSettings.EnableDebugging(packageFullName, null /* debuggerCommandLine */,
                                                                 IntPtr.Zero /* environment */);
```

<span data-ttu-id="77994-227">この呼び出しは起動時の読み込み時と同じですが、デバッガーのコマンドラインや環境ブロックを指定しない点が異なります。</span><span class="sxs-lookup"><span data-stu-id="77994-227">This is the same call you’d make for the startup load case, except you don’t specify a debugger command line or an environment block.</span></span>

<span data-ttu-id="77994-228">**DisableDebugging**</span><span class="sxs-lookup"><span data-stu-id="77994-228">**DisableDebugging**</span></span>

<span data-ttu-id="77994-229">常に、プロファイルセッションが完了したときに[Ipackagedebugsettings::D isableDebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-disabledebugging)を呼び出すことを忘れないでください。</span><span class="sxs-lookup"><span data-stu-id="77994-229">As always, don’t forget to call [IPackageDebugSettings::DisableDebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-disabledebugging) when your profiling session is completed.</span></span>

## <a name="running-inside-the-windows-store-app"></a><span data-ttu-id="77994-230">Windows ストアアプリ内での実行</span><span class="sxs-lookup"><span data-stu-id="77994-230">Running inside the Windows Store app</span></span>

<span data-ttu-id="77994-231">Windows ストアアプリは最後にプロファイラー DLL を読み込みました。</span><span class="sxs-lookup"><span data-stu-id="77994-231">So the Windows Store app has finally loaded your Profiler DLL.</span></span> <span data-ttu-id="77994-232">ここで、プロファイラー DLL は、許可されている Api やアクセス許可の制限を使用した実行方法など、Windows ストアアプリで必要とされるさまざまな規則によって再生する方法を教える必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-232">Now your Profiler DLL must be taught how to play by the different rules required by Windows Store apps, including which APIs are allowable and how to run with reduced permissions.</span></span>

### <a name="stick-to-the-windows-store-app-apis"></a><span data-ttu-id="77994-233">Windows ストアアプリ Api に従う</span><span class="sxs-lookup"><span data-stu-id="77994-233">Stick to the Windows Store app APIs</span></span>

<span data-ttu-id="77994-234">Windows API を参照すると、すべての API がデスクトップアプリ、Windows ストアアプリ、またはその両方に適用されることがわかります。</span><span class="sxs-lookup"><span data-stu-id="77994-234">As you browse the Windows API, you’ll notice that every API is documented as being applicable to desktop apps, Windows Store apps, or both.</span></span> <span data-ttu-id="77994-235">たとえば、 [InitializeCriticalSectionAndSpinCount](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionandspincount)関数のドキュメントの「**要件**」セクションでは、関数がデスクトップアプリにのみ適用されることを示しています。</span><span class="sxs-lookup"><span data-stu-id="77994-235">For example, the **Requirements** section of the documentation for the [InitializeCriticalSectionAndSpinCount](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) function indicates that the function applies to desktop apps only.</span></span> <span data-ttu-id="77994-236">これに対し、 [InitializeCriticalSectionEx](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionex)関数は、デスクトップアプリと Windows ストアアプリの両方で使用できます。</span><span class="sxs-lookup"><span data-stu-id="77994-236">In contrast, the [InitializeCriticalSectionEx](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionex) function is available for both desktop apps and Windows Store apps.</span></span>

<span data-ttu-id="77994-237">プロファイラー DLL を開発するときは、それを Windows ストアアプリであるかのように扱い、Windows ストアアプリで使用可能なものとしてドキュメント化されている Api のみを使用します。</span><span class="sxs-lookup"><span data-stu-id="77994-237">When developing your Profiler DLL, treat it as if it’s a Windows Store app and only use APIs that are documented as available to Windows Store apps.</span></span> <span data-ttu-id="77994-238">依存関係を分析します (たとえば、プロファイラー DLL に対して `link /dump /imports` を実行して監査します)。その後、ドキュメントを検索して、どの依存関係に問題がないかを確認します。</span><span class="sxs-lookup"><span data-stu-id="77994-238">Analyze your dependencies (for example, you can run `link /dump /imports` against your Profiler DLL to audit), and then search the docs to see which of your dependencies are ok and which aren’t.</span></span> <span data-ttu-id="77994-239">ほとんどの場合、違反を修正するには、安全として記述されている API の新しい形式を使用します (たとえば、 [InitializeCriticalSectionAndSpinCount](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionandspincount)を[InitializeCriticalSectionEx](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionex)に置き換えます)。</span><span class="sxs-lookup"><span data-stu-id="77994-239">In most cases, your violations can be fixed by simply replacing them with a newer form of the API that is documented as safe (for example, replacing [InitializeCriticalSectionAndSpinCount](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) with [InitializeCriticalSectionEx](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionex)).</span></span>

<span data-ttu-id="77994-240">プロファイラー DLL は、デスクトップアプリにのみ適用されるいくつかの Api を呼び出しますが、プロファイラー DLL が Windows ストアアプリ内に読み込まれていても動作しているようです。</span><span class="sxs-lookup"><span data-stu-id="77994-240">You might notice that your Profiler DLL calls some APIs that apply to desktop apps only, and yet they seem to work even when your Profiler DLL is loaded inside a Windows Store app.</span></span> <span data-ttu-id="77994-241">Windows ストアアプリプロセスに読み込まれるときに、プロファイラー DLL の Windows ストアアプリで使用するためのドキュメントに記載されていない API を使用する危険性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="77994-241">Be aware that it’s risky to use any API not documented for use with Windows Store apps in your Profiler DLL when loaded into a Windows Store app process:</span></span>

- <span data-ttu-id="77994-242">このような Api は、Windows ストアアプリが実行される一意のコンテキストで呼び出された場合に動作することは保証されていません。</span><span class="sxs-lookup"><span data-stu-id="77994-242">Such APIs are not guaranteed to work when called in the unique context that Windows Store apps run in.</span></span>

- <span data-ttu-id="77994-243">このような Api は、さまざまな Windows ストアアプリプロセス内から呼び出された場合、一貫して動作しない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="77994-243">Such APIs might not work consistently when called from within different Windows Store app processes.</span></span>

- <span data-ttu-id="77994-244">このような Api は、現在のバージョンの Windows では Windows ストアアプリから正常に動作しているように見えますが、Windows の将来のリリースでは壊れたり無効になったりする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="77994-244">Such APIs might seem to work fine from Windows Store apps in the current version of Windows, but may break or be disabled in future releases of Windows.</span></span>

<span data-ttu-id="77994-245">すべての違反を修正し、リスクを回避することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="77994-245">The best advice is to fix all your violations and avoid the risk.</span></span>

<span data-ttu-id="77994-246">特定の API を使用しなくても、Windows ストアアプリに適した置換を見つけることができないことがわかります。</span><span class="sxs-lookup"><span data-stu-id="77994-246">You might find that you absolutely cannot do without a particular API and cannot find a replacement suitable for Windows Store apps.</span></span> <span data-ttu-id="77994-247">このような場合は、少なくとも次のようにします。</span><span class="sxs-lookup"><span data-stu-id="77994-247">In such a case, at a minimum:</span></span>

- <span data-ttu-id="77994-248">その API の使用をテスト、テスト、テストします。</span><span class="sxs-lookup"><span data-stu-id="77994-248">Test, test, test the living daylights out of your usage of that API.</span></span>

- <span data-ttu-id="77994-249">Windows の今後のリリースで Windows ストアアプリの内部から呼び出された場合、API が突然中断または非表示になる可能性があることを理解してください。</span><span class="sxs-lookup"><span data-stu-id="77994-249">Understand that the API might suddenly break or disappear if called from inside Windows Store apps in future releases of Windows.</span></span> <span data-ttu-id="77994-250">これは、Microsoft による互換性の問題とは見なされません。また、の使用をサポートすることは、優先されません。</span><span class="sxs-lookup"><span data-stu-id="77994-250">This won’t be considered a compatibility concern by Microsoft, and supporting your usage of it will not be a priority.</span></span>

### <a name="reduced-permissions"></a><span data-ttu-id="77994-251">制限されたアクセス許可</span><span class="sxs-lookup"><span data-stu-id="77994-251">Reduced permissions</span></span>

<span data-ttu-id="77994-252">Windows ストアアプリのアクセス許可とデスクトップアプリの違いについては、このトピックでは説明しません。</span><span class="sxs-lookup"><span data-stu-id="77994-252">It’s outside the scope of this topic to list all the ways that Windows Store app permissions differ from desktop apps.</span></span> <span data-ttu-id="77994-253">ただし、この動作は、プロファイラー DLL (デスクトップアプリと比較して Windows ストアアプリに読み込まれた場合) がリソースにアクセスしようとするたびに異なります。</span><span class="sxs-lookup"><span data-stu-id="77994-253">But certainly the behavior will be different every time your Profiler DLL (when loaded into a Windows Store app as compared to a desktop app) tries to access any resources.</span></span> <span data-ttu-id="77994-254">ファイルシステムは、最も一般的な例です。</span><span class="sxs-lookup"><span data-stu-id="77994-254">The file system is the most common example.</span></span> <span data-ttu-id="77994-255">指定された Windows ストアアプリがアクセスできるようにするディスク上の場所はいくつかあります (「[ファイルのアクセスとアクセス許可 (Windows ランタイムアプリ](https://docs.microsoft.com/previous-versions/windows/apps/hh967755(v=win.10)))」を参照してください。また、プロファイラー DLL は同じ制限を受けます。</span><span class="sxs-lookup"><span data-stu-id="77994-255">There are but a few places on disk that a given Windows Store app is allowed to access (see [File access and permissions (Windows Runtime apps](https://docs.microsoft.com/previous-versions/windows/apps/hh967755(v=win.10))), and your Profiler DLL will be under the same restrictions.</span></span> <span data-ttu-id="77994-256">コードを十分にテストします。</span><span class="sxs-lookup"><span data-stu-id="77994-256">Test your code thoroughly.</span></span>

### <a name="inter-process-communication"></a><span data-ttu-id="77994-257">プロセス間通信</span><span class="sxs-lookup"><span data-stu-id="77994-257">Inter-process communication</span></span>

<span data-ttu-id="77994-258">このホワイトペーパーの冒頭にある図に示すように、Profiler DLL (Windows ストアアプリのプロセス領域に読み込まれます) は、独自のカスタムプロセスを通じて (別のデスクトップアプリケーションプロセス空間で実行されている) Profiler UI と通信する必要があります。通信 (IPC) チャネル。</span><span class="sxs-lookup"><span data-stu-id="77994-258">As shown in the diagram at the beginning of this paper, your Profiler DLL (loaded into the Windows Store app process space) will likely need to communicate with your Profiler UI (running in a separate desktop app process space) through your own custom inter-process communication (IPC) channel.</span></span> <span data-ttu-id="77994-259">プロファイラーの UI は、プロファイラー DLL にシグナルを送信して動作を変更します。プロファイラー DLL は、分析された Windows ストアアプリからプロファイラーの UI にデータを送信して後処理し、プロファイラーユーザーに表示します。</span><span class="sxs-lookup"><span data-stu-id="77994-259">The Profiler UI sends signals to the Profiler DLL to modify its behavior, and the Profiler DLL sends data from the analyzed Windows Store app back to the Profiler UI for post-processing and displaying to the profiler user.</span></span>

<span data-ttu-id="77994-260">ほとんどのプロファイラーはこの方法で動作する必要がありますが、プロファイラー DLL が Windows ストアアプリに読み込まれるときに、IPC メカニズムの選択肢が制限されます。</span><span class="sxs-lookup"><span data-stu-id="77994-260">Most profilers need to work this way, but your choices for IPC mechanisms are more limited when your Profiler DLL is loaded into a Windows Store app.</span></span> <span data-ttu-id="77994-261">たとえば、名前付きパイプは Windows ストアアプリ SDK の一部ではないため、使用できません。</span><span class="sxs-lookup"><span data-stu-id="77994-261">For example, named pipes are not part of the Windows Store app SDK, so you cannot use them.</span></span>

<span data-ttu-id="77994-262">しかしもちろん、ファイルは依然として存在しますが、より制限されています。</span><span class="sxs-lookup"><span data-stu-id="77994-262">But of course, files are still in, albeit in a more limited fashion.</span></span> <span data-ttu-id="77994-263">イベントも使用できます。</span><span class="sxs-lookup"><span data-stu-id="77994-263">Events are also available.</span></span>

<span data-ttu-id="77994-264">**ファイルを使用した通信**</span><span class="sxs-lookup"><span data-stu-id="77994-264">**Communicating via files**</span></span>

<span data-ttu-id="77994-265">ほとんどのデータは、Profiler DLL と Profiler UI の間でファイルを介して渡される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="77994-265">Most of your data will likely pass between the Profiler DLL and Profiler UI via files.</span></span> <span data-ttu-id="77994-266">キーとして、プロファイラー DLL (Windows ストアアプリのコンテキスト内) とプロファイラー UI の両方がに対する読み取りと書き込みのアクセス権を持つファイルの場所を選択します。</span><span class="sxs-lookup"><span data-stu-id="77994-266">The key is to pick a file location that both your Profiler DLL (in the context of a Windows Store app) and Profiler UI have read and write access to.</span></span> <span data-ttu-id="77994-267">たとえば、一時フォルダーのパスは、プロファイラー DLL とプロファイラー UI の両方がアクセスできますが、他の Windows ストアアプリパッケージがアクセスできない場所です (したがって、他の Windows ストアアプリパッケージからログに記録される情報はシールドされます)。</span><span class="sxs-lookup"><span data-stu-id="77994-267">For example, the Temporary Folder path is a location that both your Profiler DLL and Profiler UI can access, but no other Windows Store app package can access (thus shielding any information you log from other Windows Store app packages).</span></span>

<span data-ttu-id="77994-268">プロファイラー UI とプロファイラー DLL は、どちらもこのパスを個別に判別できます。</span><span class="sxs-lookup"><span data-stu-id="77994-268">Both your Profiler UI and Profiler DLL can determine this path independently.</span></span> <span data-ttu-id="77994-269">プロファイラーの UI は、現在のユーザーに対してインストールされているすべてのパッケージを反復処理する (前のサンプルコードを参照) と、`PackageId` クラスへのアクセス権を取得します。このクラスから、このスニペットと同様のコードを使用して、一時フォルダーのパスを取得できます。</span><span class="sxs-lookup"><span data-stu-id="77994-269">Your Profiler UI, when it iterates through all packages installed for the current user (see the sample code earlier), gets access to the `PackageId` class, from which the Temporary Folder path can be derived with code similar to this snippet.</span></span> <span data-ttu-id="77994-270">(簡潔にするために、エラーチェックは省略されています)。</span><span class="sxs-lookup"><span data-stu-id="77994-270">(As always, error checking is omitted for brevity.)</span></span>

```csharp
// C# code for the Profiler UI.
ApplicationData appData =
    ApplicationDataManager.CreateForPackageFamily(
        packageId.FamilyName);

tempDir = appData.TemporaryFolder.Path;
```

<span data-ttu-id="77994-271">一方、プロファイラー DLL は基本的に同じことを行うことができますが、 [Applicationdata. Current](xref:Windows.Storage.ApplicationData.Current%2A)プロパティを使用して <xref:Windows.Storage.ApplicationData> クラスに簡単にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="77994-271">Meanwhile, your Profiler DLL can do basically the same thing, though it can more easily get to the <xref:Windows.Storage.ApplicationData> class by using the [ApplicationData.Current](xref:Windows.Storage.ApplicationData.Current%2A) property.</span></span>

<span data-ttu-id="77994-272">**イベントによる通信**</span><span class="sxs-lookup"><span data-stu-id="77994-272">**Communicating via events**</span></span>

<span data-ttu-id="77994-273">プロファイラーの UI とプロファイラーの DLL の間に単純なシグナル化のセマンティクスが必要な場合は、デスクトップアプリだけでなく Windows ストアアプリ内でもイベントを使用できます。</span><span class="sxs-lookup"><span data-stu-id="77994-273">If you want simple signaling semantics between your Profiler UI and Profiler DLL, you can use events inside Windows Store apps as well as desktop apps.</span></span>

<span data-ttu-id="77994-274">プロファイラー DLL から[Createeventex](/windows/desktop/api/synchapi/nf-synchapi-createeventexa)関数を呼び出して、任意の名前の名前付きイベントを作成できます。</span><span class="sxs-lookup"><span data-stu-id="77994-274">From your Profiler DLL, you can simply call the [CreateEventEx](/windows/desktop/api/synchapi/nf-synchapi-createeventexa) function to create a named event with any name you like.</span></span> <span data-ttu-id="77994-275">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="77994-275">For example:</span></span>

```cpp
// Profiler DLL in Windows Store app (C++).
CreateEventEx(
    NULL,  // Not inherited
    "MyNamedEvent"
    CREATE_EVENT_MANUAL_RESET, /* explicit ResetEvent() required; leave initial state unsignaled */
    EVENT_ALL_ACCESS);
```

<span data-ttu-id="77994-276">その後、プロファイラーの UI は、Windows ストアアプリの名前空間の下で、その名前付きイベントを見つける必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-276">Your Profiler UI then needs to find that named event under the Windows Store app’s namespace.</span></span> <span data-ttu-id="77994-277">たとえば、プロファイラーの UI で[Createeventex](/windows/desktop/api/synchapi/nf-synchapi-createeventexa)を呼び出して、イベント名を</span><span class="sxs-lookup"><span data-stu-id="77994-277">For example, your Profiler UI could call [CreateEventEx](/windows/desktop/api/synchapi/nf-synchapi-createeventexa), specifying the event name as</span></span>

`AppContainerNamedObjects\<acSid>\MyNamedEvent`

<span data-ttu-id="77994-278">`<acSid>` は、Windows ストアアプリの AppContainer SID です。</span><span class="sxs-lookup"><span data-stu-id="77994-278">`<acSid>` is the Windows Store app’s AppContainer SID.</span></span> <span data-ttu-id="77994-279">このトピックの前のセクションでは、現在のユーザーに対してインストールされているパッケージを反復処理する方法を示しました。</span><span class="sxs-lookup"><span data-stu-id="77994-279">An earlier section of this topic showed how to iterate over the packages installed for the current user.</span></span> <span data-ttu-id="77994-280">このサンプルコードから、packageId を取得できます。</span><span class="sxs-lookup"><span data-stu-id="77994-280">From that sample code, you can obtain the packageId.</span></span> <span data-ttu-id="77994-281">また、packageId から、次のようなコードを使用して `<acSid>` を取得できます。</span><span class="sxs-lookup"><span data-stu-id="77994-281">And from the packageId, you can obtain the `<acSid>` with code similar to the following:</span></span>

```csharp
IntPtr acPSID;
DeriveAppContainerSidFromAppContainerName(packageId.FamilyName, out acPSID);

string acSid;
ConvertSidToStringSid(acPSID, out acSid);

string acDir;
GetAppContainerFolderPath(acSid, out acDir);
```

### <a name="no-shutdown-notifications"></a><span data-ttu-id="77994-282">シャットダウン通知がありません</span><span class="sxs-lookup"><span data-stu-id="77994-282">No shutdown notifications</span></span>

<span data-ttu-id="77994-283">Windows ストアアプリ内で実行する場合、プロファイラー dll は、windows ストアアプリが終了していることをプロファイラー dll `DLL_PROCESS_DETACH`に通知するために、 [ICorProfilerCallback:: Shutdown](icorprofilercallback-shutdown-method.md)または [DllMain](/windows/desktop/Dlls/dllmain) (を含む) のいずれにも依存しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-283">When running inside a Windows Store app, your Profiler DLL should not rely on either [ICorProfilerCallback::Shutdown](icorprofilercallback-shutdown-method.md) or even [DllMain](/windows/desktop/Dlls/dllmain) (with `DLL_PROCESS_DETACH`) being called to notify your Profiler DLL that the Windows Store app is exiting.</span></span> <span data-ttu-id="77994-284">実際には、これらが呼び出されることはありません。</span><span class="sxs-lookup"><span data-stu-id="77994-284">In fact, you should expect they will never be called.</span></span> <span data-ttu-id="77994-285">これまで、多くのプロファイラー Dll は、ディスクへのキャッシュのフラッシュ、ファイルの終了、プロファイラーの UI への通知の送信などの便利な場所として、これらの通知を使用していました。ただし、現在はプロファイラー DLL を少し異なる方法で整理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-285">Historically, many Profiler DLLs have used those notifications as convenient places to flush caches to disk, close files, send notifications back to the Profiler UI, etc. But now your Profiler DLL needs to be organized a little differently.</span></span>

<span data-ttu-id="77994-286">プロファイラー DLL は、記録された情報をログに記録する必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-286">Your Profiler DLL should be logging information as it goes.</span></span> <span data-ttu-id="77994-287">パフォーマンス上の理由から、バッチのサイズがしきい値を超えて増加したときに、メモリ内の情報をバッチ処理してディスクにフラッシュすることが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="77994-287">For performance reasons, you may want to batch information in memory and flush it to disk as the batch grows in size past some threshold.</span></span> <span data-ttu-id="77994-288">しかし、ディスクにフラッシュされていない情報は失われる可能性があると仮定します。</span><span class="sxs-lookup"><span data-stu-id="77994-288">But assume that any information not yet flushed to disk can be lost.</span></span> <span data-ttu-id="77994-289">これは、しきい値を適切に選択し、プロファイラーの DLL によって書き込まれた不完全な情報を処理するためにプロファイラー UI を強化する必要があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="77994-289">This means you’ll want to pick your threshold wisely, and that your Profiler UI needs to be hardened to deal with incomplete information written by the Profiler DLL.</span></span>

## <a name="windows-runtime-metadata-files"></a><span data-ttu-id="77994-290">メタデータファイルの Windows ランタイム</span><span class="sxs-lookup"><span data-stu-id="77994-290">Windows Runtime metadata files</span></span>

<span data-ttu-id="77994-291">Windows ランタイムメタデータ (WinMD) ファイルの詳細については、このドキュメントでは説明しません。</span><span class="sxs-lookup"><span data-stu-id="77994-291">It is outside the scope of this document to go into detail on what Windows Runtime metadata (WinMD) files are.</span></span> <span data-ttu-id="77994-292">このセクションでは、プロファイラー DLL が分析している Windows ストアアプリによって WinMD ファイルが読み込まれるときに、CLR プロファイル API がどのように反応するかについて説明します。</span><span class="sxs-lookup"><span data-stu-id="77994-292">This section is limited to how the CLR Profiling API reacts when WinMD files are loaded by the Windows Store app your Profiler DLL is analyzing.</span></span>

### <a name="managed-and-non-managed-winmds"></a><span data-ttu-id="77994-293">マネージドと管理されていない WinMDs</span><span class="sxs-lookup"><span data-stu-id="77994-293">Managed and non-managed WinMDs</span></span>

<span data-ttu-id="77994-294">開発者が Visual Studio を使用して新しい Windows ランタイムコンポーネントプロジェクトを作成する場合、そのプロジェクトのビルドによって、開発者によって作成されたメタデータ (クラスやインターフェイスなどの型の説明) を記述する WinMD ファイルが生成されます。</span><span class="sxs-lookup"><span data-stu-id="77994-294">If a developer uses Visual Studio to create a new Windows Runtime Component project, a build of that project produces a WinMD file that describes the metadata (the type descriptions of classes, interfaces, etc.) authored by the developer.</span></span> <span data-ttu-id="77994-295">このプロジェクトがまたは VB でC#記述されたマネージ言語プロジェクトである場合、同じ WinMD ファイルにこれらの型の実装も含まれます (つまり、開発者のソースコードからコンパイルされたすべての IL が含まれます)。</span><span class="sxs-lookup"><span data-stu-id="77994-295">If this project is a managed language project written in C# or VB, that same WinMD file also contains the implementation of those types (meaning that it contains all the IL compiled from the developer’s source code).</span></span> <span data-ttu-id="77994-296">このようなファイルは、マネージ WinMD ファイルと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="77994-296">Such files are known as managed WinMD files.</span></span> <span data-ttu-id="77994-297">Windows ランタイムメタデータと基になる実装の両方が含まれていることに注目してください。</span><span class="sxs-lookup"><span data-stu-id="77994-297">They're interesting in that they contain both Windows Runtime metadata and the underlying implementation.</span></span>

<span data-ttu-id="77994-298">これに対し、開発者が用にC++Windows ランタイムコンポーネントプロジェクトを作成した場合、そのプロジェクトのビルドでは、メタデータのみを含む WinMD ファイルが生成され、実装は別のネイティブ DLL にコンパイルされます。</span><span class="sxs-lookup"><span data-stu-id="77994-298">In contrast, if a developer creates a Windows Runtime Component project for C++, a build of that project produces a WinMD file that contains only metadata, and the implementation is compiled into a separate native DLL.</span></span> <span data-ttu-id="77994-299">同様に、Windows SDK に出荷される WinMD ファイルにはメタデータのみが含まれており、実装は Windows の一部として出荷される個別のネイティブ Dll にコンパイルされます。</span><span class="sxs-lookup"><span data-stu-id="77994-299">Similarly, the WinMD files that ship in the Windows SDK contain only metadata, with the implementation compiled into separate native DLLs that ship as part of Windows.</span></span>

<span data-ttu-id="77994-300">次の情報は、メタデータと実装を含むマネージド WinMDs と、メタデータのみを含む、管理されていない WinMDs に適用されます。</span><span class="sxs-lookup"><span data-stu-id="77994-300">The information below applies to both managed WinMDs, which contain metadata and implementation, and to non-managed WinMDs, which contain only metadata.</span></span>

### <a name="winmd-files-look-like-clr-modules"></a><span data-ttu-id="77994-301">WinMD ファイルは CLR モジュールのように見えます。</span><span class="sxs-lookup"><span data-stu-id="77994-301">WinMD files look like CLR modules</span></span>

<span data-ttu-id="77994-302">CLR に関する限り、すべての WinMD ファイルはモジュールです。</span><span class="sxs-lookup"><span data-stu-id="77994-302">As far as the CLR is concerned, all WinMD files are modules.</span></span> <span data-ttu-id="77994-303">そのため、CLR プロファイル API は、他のマネージモジュールと同じように、WinMD ファイルが読み込まれたときと、その ModuleIDs どのようなものであるかをプロファイラー DLL に伝えます。</span><span class="sxs-lookup"><span data-stu-id="77994-303">The CLR Profiling API therefore tells your Profiler DLL when WinMD files load and what their ModuleIDs are, in the same way as for other managed modules.</span></span>

<span data-ttu-id="77994-304">プロファイラー DLL は、 [ICorProfilerInfo3:: GetModuleInfo2](icorprofilerinfo3-getmoduleinfo2-method.md)メソッドを呼び出し、 [COR_PRF_MODULE_WINDOWS_RUNTIME](cor-prf-module-flags-enumeration.md)フラグの `pdwModuleFlags` 出力パラメーターを調べることによって、他のモジュールとの WinMD ファイルを区別できます。</span><span class="sxs-lookup"><span data-stu-id="77994-304">Your Profiler DLL can distinguish WinMD files from other modules by calling the [ICorProfilerInfo3::GetModuleInfo2](icorprofilerinfo3-getmoduleinfo2-method.md) method and inspecting the `pdwModuleFlags` output parameter for the [COR_PRF_MODULE_WINDOWS_RUNTIME](cor-prf-module-flags-enumeration.md) flag.</span></span> <span data-ttu-id="77994-305">(ModuleID が WinMD を表している場合にのみ設定されます)。</span><span class="sxs-lookup"><span data-stu-id="77994-305">(It’s set if and only if the ModuleID represents a WinMD.)</span></span>

### <a name="reading-metadata-from-winmds"></a><span data-ttu-id="77994-306">WinMDs からのメタデータの読み取り</span><span class="sxs-lookup"><span data-stu-id="77994-306">Reading metadata from WinMDs</span></span>

<span data-ttu-id="77994-307">WinMD ファイル (通常のモジュールなど) には、[メタデータ api](../../../../docs/framework/unmanaged-api/metadata/index.md)を使用して読み取ることができるメタデータが含まれています。</span><span class="sxs-lookup"><span data-stu-id="77994-307">WinMD files, like regular modules, contain metadata that can be read via the [Metadata APIs](../../../../docs/framework/unmanaged-api/metadata/index.md).</span></span> <span data-ttu-id="77994-308">ただし、CLR は、WinMD ファイルを読み取るときに、Windows ランタイム型を .NET Framework 型にマップします。これにより、マネージコードをプログラミングして WinMD ファイルを使用する開発者は、より自然なプログラミングエクスペリエンスを実現できます。</span><span class="sxs-lookup"><span data-stu-id="77994-308">However, the CLR maps Windows Runtime types to .NET Framework types when it reads WinMD files so that developers who program in managed code and consume the WinMD file can have a more natural programming experience.</span></span> <span data-ttu-id="77994-309">これらのマッピングの例については、「 [Windows ストアアプリおよび Windows ランタイムの .NET Framework サポート](../../../standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="77994-309">For some examples of these mappings, see [.NET Framework Support for Windows Store Apps and Windows Runtime](../../../standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md).</span></span>

<span data-ttu-id="77994-310">これにより、プロファイラーがメタデータ Api を使用したときに取得するビュー (未加工の Windows ランタイムビュー、またはマップされた .NET Framework ビュー) を確認できます。</span><span class="sxs-lookup"><span data-stu-id="77994-310">So which view will your profiler get when it uses the metadata APIs: the raw Windows Runtime view, or the mapped .NET Framework view?</span></span>  <span data-ttu-id="77994-311">答えは、ユーザーによって異なります。</span><span class="sxs-lookup"><span data-stu-id="77994-311">The answer: it’s up to you.</span></span>

<span data-ttu-id="77994-312">WinMD で[ICorProfilerInfo:: GetModuleMetaData](icorprofilerinfo-getmodulemetadata-method.md)メソッドを呼び出して、 [IMetaDataImport](../../../../docs/framework/unmanaged-api/metadata/imetadataimport-interface.md)などのメタデータインターフェイスを取得する場合は、`dwOpenFlags` パラメーターで[ofnotransform](../../../../docs/framework/unmanaged-api/metadata/coropenflags-enumeration.md)を設定して、このマッピングを無効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="77994-312">When you call the [ICorProfilerInfo::GetModuleMetaData](icorprofilerinfo-getmodulemetadata-method.md) method on a WinMD to obtain a metadata interface, such as [IMetaDataImport](../../../../docs/framework/unmanaged-api/metadata/imetadataimport-interface.md),  you can choose to set [ofNoTransform](../../../../docs/framework/unmanaged-api/metadata/coropenflags-enumeration.md) in the `dwOpenFlags` parameter to turn off this mapping.</span></span> <span data-ttu-id="77994-313">それ以外の場合、既定ではマッピングが有効になります。</span><span class="sxs-lookup"><span data-stu-id="77994-313">Otherwise, by default, the mapping will be enabled.</span></span> <span data-ttu-id="77994-314">通常、プロファイラーはマッピングを有効なままにします。これにより、プロファイラー DLL が WinMD メタデータから取得する文字列 (たとえば、型の名前) がわかりやすく、自然にプロファイラーユーザーに表示されます。</span><span class="sxs-lookup"><span data-stu-id="77994-314">Typically, a profiler will keep the mapping enabled, so that the strings that the Profiler DLL obtains from the WinMD metadata (for example, names of types) will look familiar and natural to the profiler user.</span></span>

### <a name="modifying-metadata-from-winmds"></a><span data-ttu-id="77994-315">WinMDs からのメタデータの変更</span><span class="sxs-lookup"><span data-stu-id="77994-315">Modifying metadata from WinMDs</span></span>

<span data-ttu-id="77994-316">WinMDs でのメタデータの変更はサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="77994-316">Modifying metadata in WinMDs is not supported.</span></span> <span data-ttu-id="77994-317">WinMD ファイルに対して[ICorProfilerInfo:: GetModuleMetaData](icorprofilerinfo-getmodulemetadata-method.md)メソッドを呼び出し、`dwOpenFlags` パラメーターで[ofwrite](../../../../docs/framework/unmanaged-api/metadata/coropenflags-enumeration.md)を指定した場合、または[IMetaDataEmit](../../../../docs/framework/unmanaged-api/metadata/imetadataemit-interface.md)などの書き込み可能なメタデータインターフェイスを要求した場合、 [GetModuleMetaData](icorprofilerinfo-getmodulemetadata-method.md)は失敗します。</span><span class="sxs-lookup"><span data-stu-id="77994-317">If you call the [ICorProfilerInfo::GetModuleMetaData](icorprofilerinfo-getmodulemetadata-method.md) method for a WinMD file and specify [ofWrite](../../../../docs/framework/unmanaged-api/metadata/coropenflags-enumeration.md) in the `dwOpenFlags` parameter or ask for a writeable metadata interface such as [IMetaDataEmit](../../../../docs/framework/unmanaged-api/metadata/imetadataemit-interface.md), [GetModuleMetaData](icorprofilerinfo-getmodulemetadata-method.md) will fail.</span></span> <span data-ttu-id="77994-318">これは、インストルメンテーションをサポートするためにメタデータを変更する必要がある (たとえば、AssemblyRefs や新しいメソッドを追加する) 必要がある、プロファイラーの IL 書き換えに特に重要です。</span><span class="sxs-lookup"><span data-stu-id="77994-318">This is of particular importance to IL-rewriting profilers, which need to modify metadata to support their instrumentation (for example, to add AssemblyRefs or new methods).</span></span> <span data-ttu-id="77994-319">そのため、(前のセクションで説明したように) 最初に[COR_PRF_MODULE_WINDOWS_RUNTIME](cor-prf-module-flags-enumeration.md)を確認し、そのようなモジュールで書き込み可能なメタデータインターフェイスを要求しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-319">So you should check for [COR_PRF_MODULE_WINDOWS_RUNTIME](cor-prf-module-flags-enumeration.md) first (as discussed in the previous section) and refrain from asking for writeable metadata interfaces on such modules.</span></span>

### <a name="resolving-assembly-references-with-winmds"></a><span data-ttu-id="77994-320">WinMDs を使用したアセンブリ参照の解決</span><span class="sxs-lookup"><span data-stu-id="77994-320">Resolving assembly references with WinMDs</span></span>

<span data-ttu-id="77994-321">多くのプロファイラーは、インストルメンテーションまたは型検査を支援するために、メタデータ参照を手動で解決する必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-321">Many profilers need to resolve metadata references manually to aid with instrumentation or type inspection.</span></span> <span data-ttu-id="77994-322">このようなプロファイラーは、CLR が WinMDs を指すアセンブリ参照を解決する方法を認識している必要があります。これは、これらの参照が標準アセンブリ参照とはまったく異なる方法で解決されるためです。</span><span class="sxs-lookup"><span data-stu-id="77994-322">Such profilers need to be aware of how the CLR resolves assembly references that point to WinMDs, because those references are resolved in a completely different way than standard assembly references.</span></span>

## <a name="memory-profilers"></a><span data-ttu-id="77994-323">メモリプロファイラー</span><span class="sxs-lookup"><span data-stu-id="77994-323">Memory profilers</span></span>

<span data-ttu-id="77994-324">ガベージコレクターとマネージヒープは、Windows ストアアプリとデスクトップアプリで根本的に異なります。</span><span class="sxs-lookup"><span data-stu-id="77994-324">The garbage collector and managed heap are not fundamentally different in a Windows Store app and a desktop app.</span></span> <span data-ttu-id="77994-325">ただし、プロファイラーの作成者が知っておく必要がある微妙な違いがいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="77994-325">However, there are some subtle differences that profiler authors need to be aware of.</span></span>

### <a name="forcegc-creates-a-managed-thread"></a><span data-ttu-id="77994-326">ForceGC によってマネージスレッドが作成されます。</span><span class="sxs-lookup"><span data-stu-id="77994-326">ForceGC creates a managed thread</span></span>

<span data-ttu-id="77994-327">メモリプロファイルを実行する場合、通常、プロファイラー DLL は、 [Forcegc メソッド](icorprofilerinfo-forcegc-method.md)メソッドの呼び出し元となる別のスレッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="77994-327">When doing memory profiling, your Profiler DLL typically creates a separate thread from which to call the [ForceGC Method](icorprofilerinfo-forcegc-method.md) method.</span></span> <span data-ttu-id="77994-328">これは新しいものではありません。</span><span class="sxs-lookup"><span data-stu-id="77994-328">This is nothing new.</span></span> <span data-ttu-id="77994-329">しかし、当然のことですが、Windows ストアアプリ内でガベージコレクションを実行すると、スレッドがマネージスレッドに変換される可能性があります (たとえば、そのスレッドに対してプロファイル API ThreadID が作成されます)。</span><span class="sxs-lookup"><span data-stu-id="77994-329">But what might be surprising is that the act of doing a garbage collection inside a Windows Store app may transform your thread into a managed thread (for example, a Profiling API ThreadID will be created for that thread).</span></span>

<span data-ttu-id="77994-330">この結果を理解するには、CLR プロファイル API で定義されている同期呼び出しと非同期呼び出しの違いを理解しておくことが重要です。</span><span class="sxs-lookup"><span data-stu-id="77994-330">To understand the consequences of this, it’s important to understand the differences between synchronous and asynchronous calls as defined by the CLR Profiling API.</span></span> <span data-ttu-id="77994-331">これは、Windows ストアアプリの非同期呼び出しの概念とは大きく異なることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="77994-331">Note that this is very different from the concept of asynchronous calls in Windows Store apps.</span></span> <span data-ttu-id="77994-332">詳細については、ブログ記事「 [CORPROF_E_UNSUPPORTED_CALL_SEQUENCE の理由](https://blogs.msdn.microsoft.com/davbr/2008/12/23/why-we-have-corprof_e_unsupported_call_sequence/)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="77994-332">See the blog post [Why we have CORPROF_E_UNSUPPORTED_CALL_SEQUENCE](https://blogs.msdn.microsoft.com/davbr/2008/12/23/why-we-have-corprof_e_unsupported_call_sequence/) for more information.</span></span>

<span data-ttu-id="77994-333">関連するポイントは、プロファイラーによって作成されたスレッドに対して行われた呼び出しが、プロファイラー DLL の[ICorProfilerCallback](icorprofilercallback-interface.md)メソッドのいずれかの実装の外部から行われた場合でも、常に同期と見なされることです。</span><span class="sxs-lookup"><span data-stu-id="77994-333">The relevant point is that calls made on threads created by your profiler are always considered synchronous, even if those calls are made from outside an implementation of one of your Profiler DLL’s [ICorProfilerCallback](icorprofilercallback-interface.md) methods.</span></span> <span data-ttu-id="77994-334">少なくとも、の場合はとして使用されます。</span><span class="sxs-lookup"><span data-stu-id="77994-334">At least, that used to be the case.</span></span> <span data-ttu-id="77994-335">これで、 [Forcegc メソッド](icorprofilerinfo-forcegc-method.md)の呼び出しにより、CLR がプロファイラーのスレッドをマネージスレッドに変換したので、そのスレッドはプロファイラーのスレッドと見なされなくなりました。</span><span class="sxs-lookup"><span data-stu-id="77994-335">Now that the CLR has turned your profiler’s thread into a managed thread because of your call to [ForceGC Method](icorprofilerinfo-forcegc-method.md), that thread is no longer considered your profiler’s thread.</span></span> <span data-ttu-id="77994-336">そのため、CLR では、そのスレッドに対して同期として機能する対象をより厳密に定義しています。つまり、呼び出しは、同期として限定するために、いずれかのプロファイラー DLL の[ICorProfilerCallback](icorprofilercallback-interface.md)メソッドの内部から生成される必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-336">As such, the CLR enforces a more stringent definition of what qualifies as synchronous for that thread—namely that a call must originate from inside one of your Profiler DLL’s [ICorProfilerCallback](icorprofilercallback-interface.md) methods to qualify as synchronous.</span></span>

<span data-ttu-id="77994-337">これは実際に何を意味するのでしょうか。</span><span class="sxs-lookup"><span data-stu-id="77994-337">What does this mean in practice?</span></span> <span data-ttu-id="77994-338">ほとんどの[ICorProfilerInfo](icorprofilerinfo-interface.md)メソッドは、同期的に呼び出すだけで安全です。それ以外の場合は、すぐに失敗します。</span><span class="sxs-lookup"><span data-stu-id="77994-338">Most [ICorProfilerInfo](icorprofilerinfo-interface.md) methods are only safe to be called synchronously, and will immediately fail otherwise.</span></span> <span data-ttu-id="77994-339">そのため、プロファイラーによって作成されたスレッド (たとえば、 [RequestProfilerDetach](icorprofilerinfo3-requestprofilerdetach-method.md)、 [RequestReJIT](icorprofilerinfo4-requestrejit-method.md)、または[RequestRevert](icorprofilerinfo4-requestrevert-method.md)) で通常行われる他の呼び出しに対して、profiler DLL が[forcegc メソッド](icorprofilerinfo-forcegc-method.md)スレッドを再利用すると、問題が発生します.</span><span class="sxs-lookup"><span data-stu-id="77994-339">So if your Profiler DLL reuses your [ForceGC Method](icorprofilerinfo-forcegc-method.md) thread for other calls typically made on profiler-created threads (for example, to [RequestProfilerDetach](icorprofilerinfo3-requestprofilerdetach-method.md), [RequestReJIT](icorprofilerinfo4-requestrejit-method.md), or [RequestRevert](icorprofilerinfo4-requestrevert-method.md)), you’re going to have trouble.</span></span> <span data-ttu-id="77994-340">[DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md)などの非同期セーフ関数でも、マネージスレッドから呼び出された場合、特別なルールがあります。</span><span class="sxs-lookup"><span data-stu-id="77994-340">Even an asynchronous-safe function such as [DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) has special rules when called from managed threads.</span></span> <span data-ttu-id="77994-341">(詳細については、ブログの投稿 [Profiler スタックウォーク:詳細については](https://blogs.msdn.microsoft.com/davbr/2005/10/06/profiler-stack-walking-basics-and-beyond/) を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="77994-341">(See the blog post [Profiler stack walking: Basics and beyond](https://blogs.msdn.microsoft.com/davbr/2005/10/06/profiler-stack-walking-basics-and-beyond/) for more information.)</span></span>

<span data-ttu-id="77994-342">したがって、 [Forcegc メソッド](icorprofilerinfo-forcegc-method.md)を呼び出すためにプロファイラー DLL によって作成されるすべてのスレッドは、gc をトリガーしてから gc コールバックに応答する目的で*のみ*使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="77994-342">Therefore, we recommend that any thread your Profiler DLL creates to call [ForceGC Method](icorprofilerinfo-forcegc-method.md) should be used *only* for the purpose of triggering GCs and then responding to the GC callbacks.</span></span> <span data-ttu-id="77994-343">スタックサンプリングやデタッチなどの他のタスクを実行するために、プロファイル API を呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="77994-343">It should not call into the Profiling API to perform other tasks like stack sampling or detaching.</span></span>

### <a name="conditionalweaktablereferences"></a><span data-ttu-id="77994-344">ConditionalWeakTableReferences</span><span class="sxs-lookup"><span data-stu-id="77994-344">ConditionalWeakTableReferences</span></span>

<span data-ttu-id="77994-345">.NET Framework 4.5 以降では、新しい GC コールバックである[Conditional/Tableelementreferences](icorprofilercallback5-conditionalweaktableelementreferences-method.md)が使用されます。これにより、プロファイラーは*依存ハンドル*に関するより詳細な情報を得ることができます。</span><span class="sxs-lookup"><span data-stu-id="77994-345">Starting with the .NET Framework 4.5, there is a new GC callback, [ConditionalWeakTableElementReferences](icorprofilercallback5-conditionalweaktableelementreferences-method.md), which gives the profiler more complete information about *dependent handles*.</span></span> <span data-ttu-id="77994-346">これらのハンドルは、GC 有効期間管理の目的で、ソースオブジェクトからターゲットオブジェクトへの参照を効果的に追加します。</span><span class="sxs-lookup"><span data-stu-id="77994-346">These handles effectively add a reference from a source object to a target object for the purpose of GC lifetime management.</span></span> <span data-ttu-id="77994-347">依存ハンドルはまったく新しいものではなく、マネージコードをプログラミングする開発者は、Windows 8 および .NET Framework 4.5 より前でも、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602?displayProperty=nameWithType> クラスを使用して独自の依存ハンドルを作成できます。</span><span class="sxs-lookup"><span data-stu-id="77994-347">Dependent handles are nothing new, and developers who program in managed code have been able to create their own dependent handles by using the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602?displayProperty=nameWithType> class even before Windows 8 and the .NET Framework 4.5.</span></span>

<span data-ttu-id="77994-348">ただし、マネージ XAML Windows ストアアプリでは、依存ハンドルが頻繁に使用されるようになりました。</span><span class="sxs-lookup"><span data-stu-id="77994-348">However, managed XAML Windows Store apps now make heavy use of dependent handles.</span></span> <span data-ttu-id="77994-349">特に、CLR では、マネージオブジェクトとアンマネージ Windows ランタイムオブジェクトの間の参照サイクルの管理を支援するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="77994-349">In particular, the CLR uses them to aid with managing reference cycles between managed objects and unmanaged Windows Runtime objects.</span></span> <span data-ttu-id="77994-350">これは、メモリプロファイラーがこれらの依存ハンドルを通知して、ヒープグラフの残りの部分と共に視覚化できるようにするために、これまでよりも重要であることを意味します。</span><span class="sxs-lookup"><span data-stu-id="77994-350">This means that it’s more important now than ever for memory profilers to be informed of these dependent handles so that they can be visualized along with the rest of the edges in the heap graph.</span></span> <span data-ttu-id="77994-351">プロファイラー DLL は、[RootReferences2](icorprofilercallback2-rootreferences2-method.md)、 [ObjectReferences](icorprofilercallback-objectreferences-method.md)、および[Conditional tableelementreferences](icorprofilercallback5-conditionalweaktableelementreferences-method.md)を一緒に使用して、ヒープグラフの完全なビューを形成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-351">Your Profiler DLL should use [RootReferences2](icorprofilercallback2-rootreferences2-method.md), [ObjectReferences](icorprofilercallback-objectreferences-method.md), and [ConditionalWeakTableElementReferences](icorprofilercallback5-conditionalweaktableelementreferences-method.md) together to form a complete view of the heap graph.</span></span>

## <a name="conclusion"></a><span data-ttu-id="77994-352">まとめ</span><span class="sxs-lookup"><span data-stu-id="77994-352">Conclusion</span></span>

<span data-ttu-id="77994-353">CLR プロファイル API を使用して、Windows ストアアプリ内で実行されているマネージコードを分析することができます。</span><span class="sxs-lookup"><span data-stu-id="77994-353">It is possible to use the CLR Profiling API to analyze managed code running inside Windows Store apps.</span></span> <span data-ttu-id="77994-354">実際には、開発中の既存のプロファイラーを使用して、Windows ストアアプリを対象とするように特定の変更を加えることができます。</span><span class="sxs-lookup"><span data-stu-id="77994-354">In fact, you can take an existing profiler that you’re developing and make some specific changes so that it can target Windows Store apps.</span></span> <span data-ttu-id="77994-355">プロファイラーの UI は、デバッグモードで Windows ストアアプリをアクティブ化するために新しい Api を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-355">Your Profiler UI should use the new APIs for activating the Windows Store app in debugging mode.</span></span> <span data-ttu-id="77994-356">プロファイラー DLL が、Windows ストアアプリに適用可能な Api のみを使用していることを確認してください。</span><span class="sxs-lookup"><span data-stu-id="77994-356">Make sure that your Profiler DLL consumes only those APIs applicable for Windows Store apps.</span></span> <span data-ttu-id="77994-357">プロファイラー DLL とプロファイラー UI の間の通信機構は、Windows ストアアプリの API 制限を考慮して記述し、Windows ストアアプリに適用される制限付きアクセス許可を認識しておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-357">The communication mechanism between your Profiler DLL and Profiler UI should be written with the Windows Store app API restrictions in mind and with awareness of the restricted permissions in place for Windows Store apps.</span></span> <span data-ttu-id="77994-358">プロファイラー DLL は、CLR がどのように WinMDs を処理するか、およびマネージスレッドに関してガベージコレクターの動作がどのように異なるかを認識している必要があります。</span><span class="sxs-lookup"><span data-stu-id="77994-358">Your Profiler DLL should be aware of how the CLR treats WinMDs, and how the Garbage Collector’s behavior is different with respect to managed threads.</span></span>

## <a name="resources"></a><span data-ttu-id="77994-359">リソース</span><span class="sxs-lookup"><span data-stu-id="77994-359">Resources</span></span>

<span data-ttu-id="77994-360">**共通言語ランタイム**</span><span class="sxs-lookup"><span data-stu-id="77994-360">**The Common Language Runtime**</span></span>

- [<span data-ttu-id="77994-361">プロファイリング (アンマネージ API リファレンス)</span><span class="sxs-lookup"><span data-stu-id="77994-361">Profiling (Unmanaged API Reference)</span></span>](index.md)

- [<span data-ttu-id="77994-362">メタデータ (アンマネージ API リファレンス)</span><span class="sxs-lookup"><span data-stu-id="77994-362">Metadata (Unmanaged API Reference)</span></span>](../metadata/index.md)

<span data-ttu-id="77994-363">**CLR と Windows ランタイムの相互作用**</span><span class="sxs-lookup"><span data-stu-id="77994-363">**The CLR's interaction with the Windows Runtime**</span></span>

- [<span data-ttu-id="77994-364">Windows ストア アプリおよび Windows ランタイムのための .NET Framework サポート</span><span class="sxs-lookup"><span data-stu-id="77994-364">.NET Framework Support for Windows Store Apps and Windows Runtime</span></span>](../../../standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)

<span data-ttu-id="77994-365">**Windows ストア アプリ**</span><span class="sxs-lookup"><span data-stu-id="77994-365">**Windows Store apps**</span></span>

- [<span data-ttu-id="77994-366">ファイルアクセスとアクセス許可 (Windows ランタイムアプリ</span><span class="sxs-lookup"><span data-stu-id="77994-366">File access and permissions (Windows Runtime apps</span></span>](https://docs.microsoft.com/previous-versions/windows/apps/hh967755%28v=win.10%29)

- [<span data-ttu-id="77994-367">開発者ライセンスを取得</span><span class="sxs-lookup"><span data-stu-id="77994-367">Get a developer license</span></span>](https://docs.microsoft.com/previous-versions/windows/apps/hh974578%28v=win.10%29)

- [<span data-ttu-id="77994-368">IPackageDebugSettings インターフェイス</span><span class="sxs-lookup"><span data-stu-id="77994-368">IPackageDebugSettings Interface</span></span>](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipackagedebugsettings)
