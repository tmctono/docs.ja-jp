---
title: インターネット インフォメーション サービス ホスティングのベスト プラクティス
ms.date: 03/30/2017
ms.assetid: 0834768e-9665-46bf-86eb-d4b09ab91af5
ms.openlocfilehash: 092e6ab675cf807db44c2085f8b0e7bbf67d7b28
ms.sourcegitcommit: 09b4090b78f52fd09b0e430cd4b26576f1fdf96e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/17/2020
ms.locfileid: "76211917"
---
# <a name="internet-information-services-hosting-best-practices"></a><span data-ttu-id="fa3d6-102">インターネット インフォメーション サービス ホスティングのベスト プラクティス</span><span class="sxs-lookup"><span data-stu-id="fa3d6-102">Internet Information Services Hosting Best Practices</span></span>
<span data-ttu-id="fa3d6-103">このトピックでは、Windows Communication Foundation (WCF) サービスをホストするためのいくつかのベストプラクティスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-103">This topic outlines some best practices for hosting Windows Communication Foundation (WCF) services.</span></span>  
  
## <a name="implementing-wcf-services-as-dlls"></a><span data-ttu-id="fa3d6-104">WCF サービスの DLL としての実装</span><span class="sxs-lookup"><span data-stu-id="fa3d6-104">Implementing WCF Services as DLLs</span></span>  
 <span data-ttu-id="fa3d6-105">WCF サービスを Web アプリケーションの \bin ディレクトリに配置されている DLL として実装すると、Web アプリケーションモデルの外部でサービスを再利用できます。たとえば、インターネットインフォメーションサービス (IIS) が配置されていない可能性のあるテスト環境などです。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-105">Implementing a WCF service as a DLL that is deployed to the \bin directory of a Web application allows you reuse the service outside of the Web application model, for example, in a test environment that may not have Internet Information Services (IIS) deployed.</span></span>  
  
## <a name="service-hosts-in-iis-hosted-applications"></a><span data-ttu-id="fa3d6-106">IIS でホストされるアプリケーションでのサービス ホスト</span><span class="sxs-lookup"><span data-stu-id="fa3d6-106">Service Hosts in IIS-Hosted Applications</span></span>  
 <span data-ttu-id="fa3d6-107">強制的な自己ホスト Api を使用して、iis ホスト環境でネイティブにサポートされていないネットワークトランスポートをリッスンする新しいサービスホストを作成しないでください (TCP 通信は IIS 6.0 ではネイティブにサポートされていないため、iis 6.0 では TCP サービスをホストします)。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-107">Do not use the imperative self-host APIs to create new service hosts that listen on network transports not natively supported by the IIS hosting environment (For example, IIS 6.0 to host TCP services, because TCP communication is not natively supported on IIS 6.0).</span></span> <span data-ttu-id="fa3d6-108">この方法はお勧めしません。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-108">This approach is not recommended.</span></span> <span data-ttu-id="fa3d6-109">強制的に作成されたサービス ホストは、IIS ホスト環境内で認識されないからです。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-109">Service hosts created imperatively are not known within the IIS hosting environment.</span></span> <span data-ttu-id="fa3d6-110">重要な点は、IIS がホスト アプリケーション プールがアイドル状態であるかどうかを判断するときに、強制的に作成されたサービスによって実行される処理が IIS によって考慮されないことです。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-110">The critical point is that processing done by imperatively created services is not accounted for by IIS when it determines whether the hosting application pool is idle.</span></span> <span data-ttu-id="fa3d6-111">この結果、強制的に作成されたサービス ホストを持つアプリケーションは、IIS ホスト プロセスを積極的に廃棄する IIS ホスト環境を持つことになります。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-111">The result is that applications that have such imperatively created service hosts have an IIS hosting environment that aggressively disposes of IIS host processes.</span></span>  
  
## <a name="uris-and-iis-hosted-endpoints"></a><span data-ttu-id="fa3d6-112">URI と IIS でホストされるエンドポイント</span><span class="sxs-lookup"><span data-stu-id="fa3d6-112">URIs and IIS-Hosted Endpoints</span></span>  
 <span data-ttu-id="fa3d6-113">IIS でホストされるサービスのエンドポイントは、絶対アドレスではなく、相対 URI (Uniform Resource Identifier) を使用して構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-113">Endpoints for an IIS-hosted service should be configured using relative Uniform Resource Identifiers (URIs), not absolute addresses.</span></span> <span data-ttu-id="fa3d6-114">これにより、エンドポイント アドレスが、ホスト アプリケーションに属する URI アドレスのセット内に確実に含まれ、メッセージに基づくアクティベーションが正常に行われるようになります。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-114">This guarantees that the endpoint address falls within the set of URI addresses that belong to the hosting application and ensures that message-based activation happens as expected.</span></span>  
  
## <a name="state-management-and-process-recycling"></a><span data-ttu-id="fa3d6-115">状態管理とプロセスのリサイクル</span><span class="sxs-lookup"><span data-stu-id="fa3d6-115">State Management and Process Recycling</span></span>  
 <span data-ttu-id="fa3d6-116">IIS ホスト環境は、メモリにローカル状態を保持しないサービスに最適化されています。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-116">The IIS hosting environment is optimized for services that do not maintain local state in memory.</span></span> <span data-ttu-id="fa3d6-117">IIS は、さまざまな外部および内部イベントに応答してホスト プロセスをリサイクルするため、メモリのみに格納される揮発性の状態はすべて失われます。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-117">IIS recycles the host process in response to a variety of external and internal events, causing any volatile state stored exclusively in memory to be lost.</span></span> <span data-ttu-id="fa3d6-118">IIS でホストされるサービスは、それぞれの状態をプロセスの外部 (データベースなど)、またはアプリケーションのリサイクル イベントが発生した場合に簡単に再作成できるメモリ内キャッシュに格納する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-118">Services hosted in IIS should store their state external to the process (for example, in a database) or in an in-memory cache that can easily be re-created if an application recycle event occurs.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="fa3d6-119">WCF がメッセージ層の信頼性とセキュリティのために使用するプロトコルによって、揮発性のメモリ内状態が使用されます。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-119">The protocols WCF uses for message-layer reliability and security make use of the volatile in-memory state.</span></span> <span data-ttu-id="fa3d6-120">WCF の信頼できるセッションとセキュリティセッションは、アプリケーションのリサイクルによって予期せず終了することがあります。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-120">WCF reliable sessions and security sessions may terminate unexpectedly due to application recycles.</span></span> <span data-ttu-id="fa3d6-121">これらのプロトコルを使用する IIS でホストされるアプリケーションは、アプリケーション層の状態を関連付けるために WCF によって提供されるセッションキー以外のもの (アプリケーションレイヤーコンストラクトやカスタム関連付けヘッダーなど) に依存するか、無効にする必要があります。ホストされるアプリケーションの IIS プロセスのリサイクル。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-121">IIS-hosted applications that make use of these protocols should either depend on something other than the WCF-provided session key for correlating application-layer state (for example, an application-layer construct or custom correlation header) or disable IIS process recycling for the hosted application.</span></span>  
  
## <a name="optimizing-performance-in-middle-tier-scenarios"></a><span data-ttu-id="fa3d6-122">中間層シナリオでのパフォーマンスの最適化</span><span class="sxs-lookup"><span data-stu-id="fa3d6-122">Optimizing Performance in Middle-Tier Scenarios</span></span>  
 <span data-ttu-id="fa3d6-123">*中間層シナリオ*で最適なパフォーマンスを実現するために、受信メッセージへの応答として他のサービスを呼び出すサービスは、WCF サービスクライアントをリモートサービスに1回インスタンス化して、複数の受信要求にわたって再利用します。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-123">For optimal performance in a *middle-tier scenario*—a service that calls out to other services in response to incoming messages—instantiate the WCF service client to the remote service once and reuse it across multiple incoming requests.</span></span> <span data-ttu-id="fa3d6-124">WCF サービスクライアントのインスタンス化は、既存のクライアントインスタンスでのサービス呼び出しを行う場合に比べてコストのかかる操作であり、中間層シナリオでは、複数の要求にわたってリモートクライアントをキャッシュすることによって、パフォーマンスが個別に向上します。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-124">Instantiating WCF service clients is an expensive operation relative to making a service call on a pre-existing client instance, and middle-tier scenarios produce distinct performance gains by caching remote clients across requests.</span></span> <span data-ttu-id="fa3d6-125">WCF サービスクライアントはスレッドセーフであるため、複数のスレッドにわたってクライアントへのアクセスを同期する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-125">WCF service clients are thread-safe, so it is not necessary to synchronize access to a client across multiple threads.</span></span>  
  
 <span data-ttu-id="fa3d6-126">また、中間層シナリオでは、`svcutil /a` オプションによって生成された非同期 API を使用してパフォーマンスを向上させます。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-126">Middle-tier scenarios also produce performance gains by using the asynchronous APIs generated by the `svcutil /a` option.</span></span> <span data-ttu-id="fa3d6-127">`/a` オプションを指定すると、 [ServiceModel メタデータユーティリティツール (svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)によって各サービス操作の `BeginXXX/EndXXX` メソッドが生成されます。これにより、バックグラウンドスレッドでリモートサービスへの実行に時間のかかる可能性がある呼び出しを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-127">The `/a` option causes the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) to generate `BeginXXX/EndXXX` methods for each service operation, which allows potentially long-running calls to remote services to be made on background threads.</span></span>  
  
## <a name="wcf-in-multi-homed-or-multi-named-scenarios"></a><span data-ttu-id="fa3d6-128">マルチホーム シナリオまたはマルチネーム シナリオでの WCF</span><span class="sxs-lookup"><span data-stu-id="fa3d6-128">WCF in Multi-Homed or Multi-named scenarios</span></span>  
 <span data-ttu-id="fa3d6-129">IIS Web ファーム内に WCF サービスを展開することができます。この場合、一連のコンピューターが共通の外部名 (`http://www.contoso.com`など) を共有していても、異なるホスト名で個別にアドレス指定されます (たとえば、`http://www.contoso.com` は `http://machine1.internal.contoso.com` `http://machine2.internal.contoso.com`とという名前の2つの異なるコンピューターにトラフィックを転送する場合があります)。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-129">You can deploy WCF services inside of an IIS Web farm, where a set of computers share a common external name (such as `http://www.contoso.com`) but are individually addressed by different hostnames (for example, `http://www.contoso.com` might direct traffic to two different machines named `http://machine1.internal.contoso.com` and `http://machine2.internal.contoso.com`).</span></span> <span data-ttu-id="fa3d6-130">この展開シナリオは WCF で完全にサポートされていますが、サービスのメタデータ (Web サービス記述言語) に正しい (外部の) ホスト名を表示するには、WCF サービスをホストする IIS Web サイトの特別な構成が必要です。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-130">This deployment scenario is fully supported by WCF, but requires special configuration of the IIS Web site hosting WCF services to display the correct (external) hostname in the service's metadata (Web Services Description Language).</span></span>  
  
 <span data-ttu-id="fa3d6-131">WCF によって生成されるサービスメタデータに正しいホスト名が表示されるようにするには、明示的なホスト名を使用するように WCF サービスをホストする IIS Web サイトの既定の id を構成します。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-131">To ensure that the correct hostname appears in the service metadata WCF generates, configure the default identity for the IIS Web site that hosts WCF services to use an explicit hostname.</span></span> <span data-ttu-id="fa3d6-132">たとえば、`www.contoso.com` ファーム内に存在するコンピューターでは、HTTP に対して \*:80: www. contoso .com の IIS サイトバインドを使用し、\*: 443: www. contoso .com を HTTPS に使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-132">For example, computers that reside inside of the `www.contoso.com` farm should use an IIS site binding of \*:80:www.contoso.com for HTTP and \*:443:www.contoso.com for HTTPS.</span></span>  
  
 <span data-ttu-id="fa3d6-133">Microsoft 管理コンソール (MMC) スナップインを使用して、IIS Web サイト バインディングを構成できます。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-133">You can configure IIS Web site bindings by using the IIS Microsoft Management Console (MMC) snap-in.</span></span>  
  
## <a name="application-pools-running-in-different-user-contexts-overwrite-assemblies-from-other-accounts-in-the-temporary-folder"></a><span data-ttu-id="fa3d6-134">異なるユーザー コンテキストで実行されるアプリケーション プールが、一時フォルダー内の他のアカウントのアセンブリを上書きする</span><span class="sxs-lookup"><span data-stu-id="fa3d6-134">Application Pools Running in Different User Contexts Overwrite Assemblies from Other Accounts in the Temporary Folder</span></span>  
 <span data-ttu-id="fa3d6-135">異なるユーザーコンテキストで実行されているアプリケーションプールが、一時的な ASP.NET files フォルダー内の他のアカウントのアセンブリを上書きできないようにするには、アプリケーションごとに異なる id と一時フォルダーを使用します。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-135">To ensure that application pools running in different user contexts cannot overwrite assemblies from other accounts in the temporary ASP.NET files folder, use different identities and temporary folders for different applications.</span></span> <span data-ttu-id="fa3d6-136">たとえば、/Application1 と /Application2 という 2 つの仮想アプリケーションがある場合は、2 つの異なる ID を使用して、A と B の 2 つのアプリケーション プールを作成できます。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-136">For example, if you have two virtual applications /Application1 and / Application2, you can create two Application pools, A and B, with two different identities.</span></span> <span data-ttu-id="fa3d6-137">アプリケーション プール A は、一方のユーザー ID (user1) の下で、アプリケーション プール B は、もう一方のユーザー ID (user2) の下で実行でき、/Application1 が A を、/Application2 が B を使用するように構成します。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-137">Application pool A can run under one user identity (user1) while application pool B can run under another user identity (user2), and configure /Application1 to use A and /Application2 to use B.</span></span>  
  
 <span data-ttu-id="fa3d6-138">Web.config では、\<system.web/compilation/@tempFolder> を使用して一時フォルダーを構成できます。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-138">In Web.config, you can configure the temporary folder using \<system.web/compilation/@tempFolder>.</span></span> <span data-ttu-id="fa3d6-139">/Application1 の場合、"c:\tempForUser1" にすることができ、アプリケーション2起動には "c:\tempForUser2" を指定できます。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-139">For /Application1, it can be "c:\tempForUser1" and for application2 it can be "c:\tempForUser2".</span></span> <span data-ttu-id="fa3d6-140">これらのフォルダーに対応する書き込みアクセス許可を 2 つの ID に与えます。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-140">Grant corresponding write permission to these folders for the two identities.</span></span>  
  
 <span data-ttu-id="fa3d6-141">これで、user2 は、(c:\tempForUser1 の下にある) /Application2 のコード生成フォルダーを変更できなくなります。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-141">Then user2 cannot change the code-generation folder for /application2 (under c:\tempForUser1).</span></span>  
  
## <a name="enabling-asynchronous-processing"></a><span data-ttu-id="fa3d6-142">非同期処理の有効化</span><span class="sxs-lookup"><span data-stu-id="fa3d6-142">Enabling asynchronous processing</span></span>  
 <span data-ttu-id="fa3d6-143">既定では、IIS 6.0 以前でホストされている WCF サービスに送信されるメッセージは、同期方式で処理されます。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-143">By default messages sent to a WCF service hosted under IIS 6.0 and earlier are processed in a synchronous manner.</span></span> <span data-ttu-id="fa3d6-144">ASP.NET は、独自のスレッド (ASP.NET ワーカースレッド) で WCF を呼び出し、WCF は別のスレッドを使用して要求を処理します。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-144">ASP.NET calls into WCF on its own thread (the ASP.NET worker thread) and WCF uses another thread to process the request.</span></span> <span data-ttu-id="fa3d6-145">WCF は、その処理が完了するまで ASP.NET のワーカー スレッドに保持されます。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-145">WCF holds onto the ASP.NET worker thread until it completes its processing.</span></span> <span data-ttu-id="fa3d6-146">このため、要求は同期的に処理されます。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-146">This leads to synchronous processing of requests.</span></span> <span data-ttu-id="fa3d6-147">要求を非同期で処理することで、要求の処理に必要なスレッド数を減らすことができるため、スケーラビリティが向上します。 WCF は、要求の処理中に ASP.NET スレッドに対してを保持しません。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-147">Processing requests asynchronously enables greater scalability because it reduces the number of threads required to process a request –WCF does not hold on to the ASP.NET thread while processing the request.</span></span> <span data-ttu-id="fa3d6-148">IIS 6.0 を実行しているコンピューターでは、非同期動作の使用は推奨されません。これは、サーバーが*サービス拒否*(DOS) 攻撃を仕掛けてくる受信要求を調整する方法がないためです。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-148">Use of asynchronous behavior is not recommended for machines running IIS 6.0 because there is no way to throttle incoming requests that open up the server to *Denial Of Service* (DOS) attacks.</span></span> <span data-ttu-id="fa3d6-149">IIS 7.0 以降では、同時要求スロットルが導入されています`[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ASP.NET\2.0.50727.0]"MaxConcurrentRequestsPerCpu`。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-149">Starting with IIS 7.0, a concurrent request throttle has been introduced: `[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ASP.NET\2.0.50727.0]"MaxConcurrentRequestsPerCpu`.</span></span> <span data-ttu-id="fa3d6-150">この新しいスロットルにより、非同期処理を安全に使用することができます。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-150">With this new throttle it is safe to use the asynchronous processing.</span></span>  <span data-ttu-id="fa3d6-151">IIS 7.0 の既定では、非同期のハンドラーとモジュールが登録されます。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-151">By default in IIS 7.0, the asynchronous handler and module are registered.</span></span> <span data-ttu-id="fa3d6-152">この機能が無効になっている場合は、アプリケーションの Web.config ファイルで要求の非同期処理を手動で有効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-152">If this has been turned off, you can manually enable asynchronous processing of requests in your application's Web.config file.</span></span> <span data-ttu-id="fa3d6-153">使用する設定は、`aspNetCompatibilityEnabled` 設定によって異なります。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-153">The settings you use depend on your `aspNetCompatibilityEnabled` setting.</span></span> <span data-ttu-id="fa3d6-154">`aspNetCompatibilityEnabled` を `false` に設定している場合は、次の構成スニペットに示すように、`System.ServiceModel.Activation.ServiceHttpModule` を構成します。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-154">If you have `aspNetCompatibilityEnabled` set to `false`, configure the `System.ServiceModel.Activation.ServiceHttpModule` as shown in the following configuration snippet.</span></span>  
  
```xml  
<system.serviceModel>  
    <serviceHostingEnvironment aspNetCompatibilityEnabled="false" />      
  </system.serviceModel>  
  <system.webServer>  
    <modules>  
      <remove name="ServiceModel"/>  
      <add name="ServiceModel"   
           preCondition="integratedMode,runtimeVersionv2.0"   
           type="System.ServiceModel.Activation.ServiceHttpModule, System.ServiceModel,Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>  
    </modules>  
    </system.webServer>  
```  
  
 <span data-ttu-id="fa3d6-155">`aspNetCompatibilityEnabled` を `true` に設定している場合は、次の構成スニペットに示すように、`System.ServiceModel.Activation.ServiceHttpHandlerFactory` を構成します。</span><span class="sxs-lookup"><span data-stu-id="fa3d6-155">If you have `aspNetCompatibilityEnabled` set to `true`, configure the `System.ServiceModel.Activation.ServiceHttpHandlerFactory` as shown in the following config snippet.</span></span>  
  
```xml  
<system.serviceModel>  
    <serviceHostingEnvironment aspNetCompatibilityEnabled="true" />      
  </system.serviceModel>  
  <system.webServer>  
    <handlers>  
          <clear/>  
          <add name="TestAsyncHttpHandler"   
               path="*.svc"   
               verb="*"   
               type="System.ServiceModel.Activation.ServiceHttpHandlerFactory, System.ServiceModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"           
               />  
    </handlers>      
  </system.webServer>  
```  
  
## <a name="see-also"></a><span data-ttu-id="fa3d6-156">関連項目</span><span class="sxs-lookup"><span data-stu-id="fa3d6-156">See also</span></span>

- [<span data-ttu-id="fa3d6-157">サービスホスティングのサンプル</span><span class="sxs-lookup"><span data-stu-id="fa3d6-157">Service Hosting Samples</span></span>](../samples/hosting.md)
- <span data-ttu-id="fa3d6-158">[AppFabric のホスティング機能](https://docs.microsoft.com/previous-versions/appfabric/ee677189(v=azure.10))</span><span class="sxs-lookup"><span data-stu-id="fa3d6-158">[Windows Server App Fabric Hosting Features](https://docs.microsoft.com/previous-versions/appfabric/ee677189(v=azure.10))</span></span>
