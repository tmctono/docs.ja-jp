---
title: SQL Server でのスナップショット分離
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176
ms.openlocfilehash: 8313ffc8eef70c1e5efc24b09a160edb7cec1595
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/12/2020
ms.locfileid: "79174265"
---
# <a name="snapshot-isolation-in-sql-server"></a><span data-ttu-id="42367-102">SQL Server でのスナップショット分離</span><span class="sxs-lookup"><span data-stu-id="42367-102">Snapshot Isolation in SQL Server</span></span>
<span data-ttu-id="42367-103">スナップショット分離では、OLTP アプリケーションの同時実行性が向上します。</span><span class="sxs-lookup"><span data-stu-id="42367-103">Snapshot isolation enhances concurrency for OLTP applications.</span></span>  
  
## <a name="understanding-snapshot-isolation-and-row-versioning"></a><span data-ttu-id="42367-104">スナップショット分離と行バージョン管理について</span><span class="sxs-lookup"><span data-stu-id="42367-104">Understanding Snapshot Isolation and Row Versioning</span></span>  
 <span data-ttu-id="42367-105">スナップショット分離を有効にした後、各トランザクションの更新された行バージョンを維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="42367-105">Once snapshot isolation is enabled, updated row versions for each transaction must be maintained.</span></span>  <span data-ttu-id="42367-106">SQL Server 2019 より前のバージョンは**tempdb**に格納されていました。</span><span class="sxs-lookup"><span data-stu-id="42367-106">Prior to SQL Server 2019, these versions were stored in **tempdb**.</span></span> <span data-ttu-id="42367-107">SQL Server 2019 では、独自の行バージョンのセットを必要とする新しい機能である高速データベース回復 (ADR) が導入されました。</span><span class="sxs-lookup"><span data-stu-id="42367-107">SQL Server 2019 introduces a new feature, Accelerated Database Recovery (ADR) which requires its own set of row versions.</span></span>  <span data-ttu-id="42367-108">したがって、SQL Server 2019 の時点では、ADR が有効になっていない場合、行のバージョンは**tempdb**に常に保持されます。</span><span class="sxs-lookup"><span data-stu-id="42367-108">So, as of SQL Server 2019, if ADR is not enabled, row versions are kept in **tempdb** as always.</span></span>  <span data-ttu-id="42367-109">ADR が有効な場合、スナップショット分離と ADR に関連するすべての行バージョンは、ユーザーが指定したファイル グループ内のユーザー データベースにある ADR の永続的バージョン ストア (PVS) に保持されます。</span><span class="sxs-lookup"><span data-stu-id="42367-109">If ADR is enabled, then all row versions, both related to snapshot isolation and ADR, are kept in ADR's Persistent Version Store (PVS), which is located in the user database in a filegroup which the user specifies.</span></span> <span data-ttu-id="42367-110">一意のトランザクション シーケンス番号によって、各トランザクションが識別されます。これらの一意の番号は、行バージョンごとに記録されます。</span><span class="sxs-lookup"><span data-stu-id="42367-110">A unique transaction sequence number identifies each transaction, and these unique numbers are recorded for each row version.</span></span> <span data-ttu-id="42367-111">トランザクションは、トランザクションのシーケンス番号の前にシーケンス番号が付いた最新の行バージョンで動作します。</span><span class="sxs-lookup"><span data-stu-id="42367-111">The transaction works with the most recent row versions having a sequence number before the sequence number of the transaction.</span></span> <span data-ttu-id="42367-112">トランザクションの開始後に作成された新しい行バージョンは、トランザクションによって無視されます。</span><span class="sxs-lookup"><span data-stu-id="42367-112">Newer row versions created after the transaction has begun are ignored by the transaction.</span></span>  
  
 <span data-ttu-id="42367-113">"スナップショット" という用語は、トランザクションの開始時点のデータベースの状態に基づいて、トランザクション内のすべてのクエリが、データベースの同じバージョン (つまりスナップショット) を参照するということを表しています。</span><span class="sxs-lookup"><span data-stu-id="42367-113">The term "snapshot" reflects the fact that all queries in the transaction see the same version, or snapshot, of the database, based on the state of the database at the moment in time when the transaction begins.</span></span> <span data-ttu-id="42367-114">ロックは、スナップショット トランザクション内の基になるデータ行やデータ ページでは取得されません。スナップショット トランザクションでは、先に開始されてまだ完了していないトランザクションによりブロックされることなく、他のトランザクションを実行できます。</span><span class="sxs-lookup"><span data-stu-id="42367-114">No locks are acquired on the underlying data rows or data pages in a snapshot transaction, which permits other transactions to execute without being blocked by a prior uncompleted transaction.</span></span> <span data-ttu-id="42367-115">トランザクションは通常、SQL Server で既定の READ COMMITTED 分離レベルにあるため、データを変更するトランザクションは、データを読み取るトランザクションをブロックしません。また、データを読み取るトランザクションは、データを書き込むトランザクションをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="42367-115">Transactions that modify data do not block transactions that read data, and transactions that read data do not block transactions that write data, as they normally would under the default READ COMMITTED isolation level in SQL Server.</span></span> <span data-ttu-id="42367-116">この非ブロッキング動作によって、複雑なトランザクションがデッドロックする可能性も大幅に減少します。</span><span class="sxs-lookup"><span data-stu-id="42367-116">This non-blocking behavior also significantly reduces the likelihood of deadlocks for complex transactions.</span></span>  
  
 <span data-ttu-id="42367-117">スナップショット分離では、オプティミスティック同時実行制御モデルが使用されます。</span><span class="sxs-lookup"><span data-stu-id="42367-117">Snapshot isolation uses an optimistic concurrency model.</span></span> <span data-ttu-id="42367-118">スナップショット トランザクションで、トランザクションの開始後に変更されたデータに対して変更をコミットしようとすると、トランザクションがロールバックされ、エラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="42367-118">If a snapshot transaction attempts to commit modifications to data that has changed since the transaction began, the transaction will roll back and an error will be raised.</span></span> <span data-ttu-id="42367-119">これを回避するには、変更するデータにアクセスする SELECT ステートメントに UPDLOCK ヒントを使用します。</span><span class="sxs-lookup"><span data-stu-id="42367-119">You can avoid this by using UPDLOCK hints for SELECT statements that access data to be modified.</span></span> <span data-ttu-id="42367-120">詳細については、SQL Server オンラインブックの「ロック ヒント」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42367-120">See "Locking Hints" in SQL Server Books Online for more information.</span></span>  
  
 <span data-ttu-id="42367-121">スナップショット分離を有効にするには、トランザクションで使用する前に、ALLOW_SNAPSHOT_ISOLATION ON データベース オプションを設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="42367-121">Snapshot isolation must be enabled by setting the ALLOW_SNAPSHOT_ISOLATION ON database option before it is used in transactions.</span></span> <span data-ttu-id="42367-122">これにより、行バージョンを一時データベース (**tempdb**) 内に保存するためのメカニズムがアクティブになります。</span><span class="sxs-lookup"><span data-stu-id="42367-122">This activates the mechanism for storing row versions in the temporary database (**tempdb**).</span></span> <span data-ttu-id="42367-123">Transact-SQL の ALTER DATABASE ステートメントで使用するスナップショット分離を、各データベースで有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="42367-123">You must enable snapshot isolation in each database that uses it with the Transact-SQL ALTER DATABASE statement.</span></span> <span data-ttu-id="42367-124">この点で、スナップショット分離は、構成を必要としない、READ COMMITTED、REPEATABLE READ、SERIALIZABLE、および READ UNCOMMITTED という従来の分離レベルとは異なります。</span><span class="sxs-lookup"><span data-stu-id="42367-124">In this respect, snapshot isolation differs from the traditional isolation levels of READ COMMITTED, REPEATABLE READ, SERIALIZABLE, and READ UNCOMMITTED, which require no configuration.</span></span> <span data-ttu-id="42367-125">次のステートメントでは、スナップショット分離をアクティブ化し、既定の READ COMMITTED 動作を SNAPSHOT に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="42367-125">The following statements activate snapshot isolation and replace the default READ COMMITTED behavior with SNAPSHOT:</span></span>  
  
```sql  
ALTER DATABASE MyDatabase  
SET ALLOW_SNAPSHOT_ISOLATION ON  
  
ALTER DATABASE MyDatabase  
SET READ_COMMITTED_SNAPSHOT ON  
```  
  
 <span data-ttu-id="42367-126">READ_COMMITTED_SNAPSHOT ON オプションを設定すると、既定の READ COMMITTED 分離レベルでバージョン管理された行にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="42367-126">Setting the READ_COMMITTED_SNAPSHOT ON option allows access to versioned rows under the default READ COMMITTED isolation level.</span></span> <span data-ttu-id="42367-127">READ_COMMITTED_SNAPSHOT オプションが OFF に設定されている場合、バージョン管理された行にアクセスするには、セッションごとにスナップショット分離レベルを明示的に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="42367-127">If the READ_COMMITTED_SNAPSHOT option is set to OFF, you must explicitly set the Snapshot isolation level for each session in order to access versioned rows.</span></span>  
  
## <a name="managing-concurrency-with-isolation-levels"></a><span data-ttu-id="42367-128">分離レベルによるコンカレンシーの管理</span><span class="sxs-lookup"><span data-stu-id="42367-128">Managing Concurrency with Isolation Levels</span></span>  
 <span data-ttu-id="42367-129">Transact-SQL ステートメントが実行される分離レベルによって、ロックおよび行のバージョン管理の動作が決定します。</span><span class="sxs-lookup"><span data-stu-id="42367-129">The isolation level under which a Transact-SQL statement executes determines its locking and row versioning behavior.</span></span> <span data-ttu-id="42367-130">分離レベルには接続全体のスコープがあり、SET TRANSACTION ISOLATION LEVEL ステートメントを使用して接続に設定すると、接続が閉じられるか別の分離レベルが設定されるまで、有効なままになります。</span><span class="sxs-lookup"><span data-stu-id="42367-130">An isolation level has connection-wide scope, and once set for a connection with the SET TRANSACTION ISOLATION LEVEL statement, it remains in effect until the connection is closed or another isolation level is set.</span></span> <span data-ttu-id="42367-131">接続が閉じられ、プールに返されると、最後の SET TRANSACTION ISOLATION LEVEL ステートメントの分離レベルが保持されます。</span><span class="sxs-lookup"><span data-stu-id="42367-131">When a connection is closed and returned to the pool, the isolation level from the last SET TRANSACTION ISOLATION LEVEL statement is retained.</span></span> <span data-ttu-id="42367-132">プールされた接続を再利用する後続の接続では、接続がプールされたときに有効であった分離レベルが使用されます。</span><span class="sxs-lookup"><span data-stu-id="42367-132">Subsequent connections reusing a pooled connection use the isolation level that was in effect at the time the connection is pooled.</span></span>  
  
 <span data-ttu-id="42367-133">接続内で発行される個々のクエリには、1 つのステートメントまたはトランザクションの分離を変更しても、接続の分離レベルには影響しないロック ヒントを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="42367-133">Individual queries issued within a connection can contain lock hints that modify the isolation for a single statement or transaction but do not affect the isolation level of the connection.</span></span> <span data-ttu-id="42367-134">ストアド プロシージャまたは関数で設定された分離レベルまたはロック ヒントでは、それらを呼び出す接続の分離レベルは変更されず、ストアド プロシージャまたは関数呼び出しの実行中にのみ有効にされます。</span><span class="sxs-lookup"><span data-stu-id="42367-134">Isolation levels or lock hints set in stored procedures or functions do not change the isolation level of the connection that calls them and are in effect only for the duration of the stored procedure or function call.</span></span>  
  
 <span data-ttu-id="42367-135">以前のバージョンの SQL Server では、SQL-92 標準に定義されている 4 つの分離レベルがサポートされていました。</span><span class="sxs-lookup"><span data-stu-id="42367-135">Four isolation levels defined in the SQL-92 standard were supported in early versions of SQL Server:</span></span>  
  
- <span data-ttu-id="42367-136">READ UNCOMMITTED は、他のトランザクションによって設定されたロックを無視するため、最も制限の緩い分離レベルです。</span><span class="sxs-lookup"><span data-stu-id="42367-136">READ UNCOMMITTED is the least restrictive isolation level because it ignores locks placed by other transactions.</span></span> <span data-ttu-id="42367-137">READ UNCOMMITTED で実行されているトランザクションは、他のトランザクションによってまだコミットされていない変更されたデータ値を読み取ることができます。これらは "ダーティ" リードと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="42367-137">Transactions executing under READ UNCOMMITTED can read modified data values that have not yet been committed by other transactions; these are called "dirty" reads.</span></span>  
  
- <span data-ttu-id="42367-138">READ COMMITTED は、SQL Server の既定の分離レベルです。</span><span class="sxs-lookup"><span data-stu-id="42367-138">READ COMMITTED is the default isolation level for SQL Server.</span></span> <span data-ttu-id="42367-139">これにより、ステートメントで他のトランザクションによって変更されていてもまだコミットされていないデータ値を読み取ることができないように指定することで、ダーティ リードを防止できます。</span><span class="sxs-lookup"><span data-stu-id="42367-139">It prevents dirty reads by specifying that statements cannot read data values that have been modified but not yet committed by other transactions.</span></span> <span data-ttu-id="42367-140">その他のトランザクションでは、現在のトランザクション内の個々のステートメントの実行で、引き続きデータの変更、挿入、削除が可能であるため、反復不可能な読み取りや "ファントム" データが発生します。</span><span class="sxs-lookup"><span data-stu-id="42367-140">Other transactions can still modify, insert, or delete data between executions of individual statements within the current transaction, resulting in non-repeatable reads, or "phantom" data.</span></span>  
  
- <span data-ttu-id="42367-141">REPEATABLE READ は、READ COMMITTED よりも制限の厳しい分離レベルです。</span><span class="sxs-lookup"><span data-stu-id="42367-141">REPEATABLE READ is a more restrictive isolation level than READ COMMITTED.</span></span> <span data-ttu-id="42367-142">これは READ COMMITTED を含み、加えて現在のトランザクションがコミットされるまで、現在のトランザクションによって読み取られたデータを他のトランザクションが変更または削除できないことを指定します。</span><span class="sxs-lookup"><span data-stu-id="42367-142">It encompasses READ COMMITTED and additionally specifies that no other transactions can modify or delete data that has been read by the current transaction until the current transaction commits.</span></span> <span data-ttu-id="42367-143">読み取りデータに対する共有ロックは、各ステートメントの最後に解放されるのではなく、トランザクションの実行中に保持されるため、コンカレンシーは READ COMMITTED よりも低くなります。</span><span class="sxs-lookup"><span data-stu-id="42367-143">Concurrency is lower than for READ COMMITTED because shared locks on read data are held for the duration of the transaction instead of being released at the end of each statement.</span></span>  
  
- <span data-ttu-id="42367-144">キー範囲全体がロックされ、トランザクションが完了するまでその状態が保持されるので、SERIALIZABLE は最も制限の厳しい分離レベルといえます。</span><span class="sxs-lookup"><span data-stu-id="42367-144">SERIALIZABLE is the most restrictive isolation level, because it locks entire ranges of keys and holds the locks until the transaction is complete.</span></span> <span data-ttu-id="42367-145">これは REPEATABLE READ を含み、トランザクションが完了するまで、トランザクションによって読み取られた範囲に新しい行を挿入できないという制限を追加します。</span><span class="sxs-lookup"><span data-stu-id="42367-145">It encompasses REPEATABLE READ and adds the restriction that other transactions cannot insert new rows into ranges that have been read by the transaction until the transaction is complete.</span></span>  
  
 <span data-ttu-id="42367-146">詳細については、「[トランザクションのロックおよび行のバージョン管理ガイド](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42367-146">For more information, refer to the [Transaction Locking and Row Versioning Guide](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide).</span></span>  
  
### <a name="snapshot-isolation-level-extensions"></a><span data-ttu-id="42367-147">スナップショット分離レベルの拡張機能</span><span class="sxs-lookup"><span data-stu-id="42367-147">Snapshot Isolation Level Extensions</span></span>  
 <span data-ttu-id="42367-148">SQL Server では、SNAPSHOT 分離レベルの導入および READ COMMITTED の追加実装と共に、SQL-92 分離レベルの機能を強化しています。</span><span class="sxs-lookup"><span data-stu-id="42367-148">SQL Server introduced extensions to the SQL-92 isolation levels with the introduction of the SNAPSHOT isolation level and an additional implementation of READ COMMITTED.</span></span> <span data-ttu-id="42367-149">READ_COMMITTED_SNAPSHOT 分離レベルは、すべてのトランザクションの READ COMMITTED を自動的に置き換えることができます。</span><span class="sxs-lookup"><span data-stu-id="42367-149">The READ_COMMITTED_SNAPSHOT isolation level can transparently replace READ COMMITTED for all transactions.</span></span>  
  
- <span data-ttu-id="42367-150">SNAPSHOT 分離は、トランザクション内で読み取られるデータには、他の同時実行トランザクションによる変更が反映されないことを指定します。</span><span class="sxs-lookup"><span data-stu-id="42367-150">SNAPSHOT isolation specifies that data read within a transaction will never reflect changes made by other simultaneous transactions.</span></span> <span data-ttu-id="42367-151">このトランザクションでは、トランザクションの開始時に存在していたデータ行のバージョンが使用されます。</span><span class="sxs-lookup"><span data-stu-id="42367-151">The transaction uses the data row versions that exist when the transaction begins.</span></span> <span data-ttu-id="42367-152">データが読み取られるときにロックが設定されないため、SNAPSHOT トランザクションは、他のトランザクションによるデータの書き込みをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="42367-152">No locks are placed on the data when it is read, so SNAPSHOT transactions do not block other transactions from writing data.</span></span> <span data-ttu-id="42367-153">トランザクションでデータが書き込まれている間も、SNAPSHOT トランザクションではデータを読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="42367-153">Transactions that write data do not block snapshot transactions from reading data.</span></span> <span data-ttu-id="42367-154">スナップショット分離を使用するには ALLOW_SNAPSHOT_ISOLATION データベース オプションを設定して、それを有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="42367-154">You need to enable snapshot isolation by setting the ALLOW_SNAPSHOT_ISOLATION database option in order to use it.</span></span>  
  
- <span data-ttu-id="42367-155">データベースでスナップショット分離が有効になっている場合、READ_COMMITTED_SNAPSHOT データベース オプションによって、既定の READ COMMITTED 分離レベルの動作が決定されます。</span><span class="sxs-lookup"><span data-stu-id="42367-155">The READ_COMMITTED_SNAPSHOT database option determines the behavior of the default READ COMMITTED isolation level when snapshot isolation is enabled in a database.</span></span> <span data-ttu-id="42367-156">READ_COMMITTED_SNAPSHOT ON を明示的に指定しない場合、すべての暗黙のトランザクションに READ COMMITTED が適用されます。</span><span class="sxs-lookup"><span data-stu-id="42367-156">If you do not explicitly specify READ_COMMITTED_SNAPSHOT ON, READ COMMITTED is applied to all implicit transactions.</span></span> <span data-ttu-id="42367-157">これにより、READ_COMMITTED_SNAPSHOT OFF (既定) を設定する場合と同じ動作が生成されます。</span><span class="sxs-lookup"><span data-stu-id="42367-157">This produces the same behavior as setting READ_COMMITTED_SNAPSHOT OFF (the default).</span></span> <span data-ttu-id="42367-158">READ_COMMITTED_SNAPSHOT OFF が有効な場合、データベース エンジンでは、共有ロックを使用して既定の分離レベルが適用されます。</span><span class="sxs-lookup"><span data-stu-id="42367-158">When READ_COMMITTED_SNAPSHOT OFF is in effect, the Database Engine uses shared locks to enforce the default isolation level.</span></span> <span data-ttu-id="42367-159">READ_COMMITTED_SNAPSHOT データベース オプションを ON に設定した場合、データベース エンジンでは、データを保護するためにロックを使用するのではなく、行のバージョン管理とスナップショット分離が既定として使用されます。</span><span class="sxs-lookup"><span data-stu-id="42367-159">If you set the READ_COMMITTED_SNAPSHOT database option to ON, the database engine uses row versioning and snapshot isolation as the default, instead of using locks to protect the data.</span></span>  
  
## <a name="how-snapshot-isolation-and-row-versioning-work"></a><span data-ttu-id="42367-160">スナップショット分離と行バージョン管理の機能について</span><span class="sxs-lookup"><span data-stu-id="42367-160">How Snapshot Isolation and Row Versioning Work</span></span>  
 <span data-ttu-id="42367-161">SNAPSHOT 分離レベルが有効になっている場合、行が更新されるたびに、SQL Server データベース エンジンは **tempdb** 内の元の行のコピーを保存し、行にトランザクション シーケンス番号を追加します。</span><span class="sxs-lookup"><span data-stu-id="42367-161">When the SNAPSHOT isolation level is enabled, each time a row is updated, the SQL Server Database Engine stores a copy of the original row in **tempdb**, and adds a transaction sequence number to the row.</span></span> <span data-ttu-id="42367-162">次に一連のイベントの発生を示します。</span><span class="sxs-lookup"><span data-stu-id="42367-162">The following is the sequence of events that occurs:</span></span>  
  
- <span data-ttu-id="42367-163">新しいトランザクションが開始され、トランザクション シーケンス番号が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="42367-163">A new transaction is initiated, and it is assigned a transaction sequence number.</span></span>  
  
- <span data-ttu-id="42367-164">データベース エンジンは、トランザクション内の行を読み取り、トランザクション シーケンス番号より小さくて、トランザクション シーケンス番号に最も近いシーケンス番号の行バージョンを、**tempdb** から取得します。</span><span class="sxs-lookup"><span data-stu-id="42367-164">The Database Engine reads a row within the transaction and retrieves the row version from **tempdb** whose sequence number is closest to, and lower than, the transaction sequence number.</span></span>  
  
- <span data-ttu-id="42367-165">データベース エンジンでは、スナップショット トランザクションが開始されたときにアクティブになっており、コミットされていないトランザクションのトランザクション シーケンス番号の一覧に、トランザクション シーケンス番号が含まれているかどうかがチェックされます。</span><span class="sxs-lookup"><span data-stu-id="42367-165">The Database Engine checks to see if the transaction sequence number is not in the list of transaction sequence numbers of the uncommitted transactions active when the snapshot transaction started.</span></span>  
  
- <span data-ttu-id="42367-166">トランザクションは、トランザクションの開始時点で最新だった **tempdb** から、行のバージョンを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="42367-166">The transaction reads the version of the row from **tempdb** that was current as of the start of the transaction.</span></span> <span data-ttu-id="42367-167">トランザクションの開始後に挿入された新しい行は、それらのシーケンス番号値がトランザクション シーケンス番号値よりも大きくなるため、確認されません。</span><span class="sxs-lookup"><span data-stu-id="42367-167">It will not see new rows inserted after the transaction was started because those sequence number values will be higher than the value of the transaction sequence number.</span></span>  
  
- <span data-ttu-id="42367-168">現在のトランザクションは、トランザクションの開始後に削除された行を確認します。この理由は、トランザクション シーケンス番号より小さいシーケンス番号の値を持つ行バージョンが **tempdb** 内に存在する可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="42367-168">The current transaction will see rows that were deleted after the transaction began, because there will be a row version in **tempdb** with a lower sequence number value.</span></span>  
  
 <span data-ttu-id="42367-169">スナップショット分離の実質的な効果として、トランザクションでは、基になるテーブルへのロックの適用や配置を行うことなく、すべてのデータがトランザクションの開始時に存在していたものと見なされます。</span><span class="sxs-lookup"><span data-stu-id="42367-169">The net effect of snapshot isolation is that the transaction sees all of the data as it existed at the start of the transaction, without honoring or placing any locks on the underlying tables.</span></span> <span data-ttu-id="42367-170">これにより、競合が発生している状況でパフォーマンスが向上することができます。</span><span class="sxs-lookup"><span data-stu-id="42367-170">This can result in performance improvements in situations where there is contention.</span></span>  
  
 <span data-ttu-id="42367-171">スナップショット トランザクションでは常にオプティミスティック同時実行制御が使用され、他のトランザクションによる行の更新を妨げるようなロックが行われません。</span><span class="sxs-lookup"><span data-stu-id="42367-171">A snapshot transaction always uses optimistic concurrency control, withholding any locks that would prevent other transactions from updating rows.</span></span> <span data-ttu-id="42367-172">スナップショット トランザクションでは、トランザクションの開始後に変更された行に対する更新をコミットしようとすると、トランザクションがロールバックされ、エラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="42367-172">If a snapshot transaction attempts to commit an update to a row that was changed after the transaction began, the transaction is rolled back, and an error is raised.</span></span>  
  
## <a name="working-with-snapshot-isolation-in-adonet"></a><span data-ttu-id="42367-173">ADO.NET でのスナップショット分離の使用</span><span class="sxs-lookup"><span data-stu-id="42367-173">Working with Snapshot Isolation in ADO.NET</span></span>  
 <span data-ttu-id="42367-174">スナップショット分離は、ADO.NET で <xref:System.Data.SqlClient.SqlTransaction> クラスによってサポートされています。</span><span class="sxs-lookup"><span data-stu-id="42367-174">Snapshot isolation is supported in ADO.NET by the <xref:System.Data.SqlClient.SqlTransaction> class.</span></span> <span data-ttu-id="42367-175">データベースでスナップショット分離が有効になっているが、READ_COMMITTED_SNAPSHOT ON に構成されていない場合、<xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> メソッドの呼び出し時に **IsolationLevel.Snapshot** 列挙値を使って、<xref:System.Data.SqlClient.SqlTransaction> を開始する必要があります。</span><span class="sxs-lookup"><span data-stu-id="42367-175">If a database has been enabled for snapshot isolation but is not configured for READ_COMMITTED_SNAPSHOT ON, you must initiate a <xref:System.Data.SqlClient.SqlTransaction> using the **IsolationLevel.Snapshot** enumeration value when calling the <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> method.</span></span> <span data-ttu-id="42367-176">このコード フラグメントでは、接続が開いている <xref:System.Data.SqlClient.SqlConnection> オブジェクトであることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="42367-176">This code fragment assumes that connection is an open <xref:System.Data.SqlClient.SqlConnection> object.</span></span>  
  
```vb  
Dim sqlTran As SqlTransaction = _  
  connection.BeginTransaction(IsolationLevel.Snapshot)  
```  
  
```csharp  
SqlTransaction sqlTran =
  connection.BeginTransaction(IsolationLevel.Snapshot);  
```  
  
### <a name="example"></a><span data-ttu-id="42367-177">例</span><span class="sxs-lookup"><span data-stu-id="42367-177">Example</span></span>  
 <span data-ttu-id="42367-178">次の例では、ロックされたデータにアクセスを試みて、さまざまな分離レベルがどのように動作するかを示すものですが、運用環境コードでの使用を意図するものではありません。</span><span class="sxs-lookup"><span data-stu-id="42367-178">The following example demonstrates how the different isolation levels behave by attempting to access locked data, and it is not intended to be used in production code.</span></span>  
  
 <span data-ttu-id="42367-179">このコードは、SQL Server の **AdventureWorks** サンプル データベースに接続し、**TestSnapshot** というテーブルを作成し、1 行のデータを挿入します。</span><span class="sxs-lookup"><span data-stu-id="42367-179">The code connects to the **AdventureWorks** sample database in SQL Server and creates a table named **TestSnapshot** and inserts one row of data.</span></span> <span data-ttu-id="42367-180">このコードでは、ALTER DATABASE Transact-SQL ステートメントを使用して、データベースのスナップショット分離を有効にしていますが、READ_COMMITTED_SNAPSHOT オプションは設定せず、既定の READ COMMITTED 分離レベルの動作を有効なままにしています。</span><span class="sxs-lookup"><span data-stu-id="42367-180">The code uses the ALTER DATABASE Transact-SQL statement to turn on snapshot isolation for the database, but it does not set the READ_COMMITTED_SNAPSHOT option, leaving the default READ COMMITTED isolation-level behavior in effect.</span></span> <span data-ttu-id="42367-181">次に、このコードでは次のアクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="42367-181">The code then performs the following actions:</span></span>  
  
- <span data-ttu-id="42367-182">これは sqlTransaction1 を開始しますが、完了するのではなく、SERIALIZABLE 分離レベルを使用して更新トランザクションを開始します。</span><span class="sxs-lookup"><span data-stu-id="42367-182">It begins, but does not complete, sqlTransaction1, which uses the SERIALIZABLE isolation level to start an update transaction.</span></span> <span data-ttu-id="42367-183">これには、テーブルをロックする効果があります。</span><span class="sxs-lookup"><span data-stu-id="42367-183">This has the effect of locking the table.</span></span>  
  
- <span data-ttu-id="42367-184">2 つ目の接続を開き、SNAPSHOT 分離レベルを使って 2 つ目のトランザクションを開始し、**TestSnapshot** テーブル内のデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="42367-184">It opens a second connection and initiates a second transaction using the SNAPSHOT isolation level to read the data in the **TestSnapshot** table.</span></span> <span data-ttu-id="42367-185">スナップショット分離が有効になっているため、このトランザクションでは、sqlTransaction1 が開始される前に存在していたデータを読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="42367-185">Because snapshot isolation is enabled, this transaction can read the data that existed before sqlTransaction1 started.</span></span>  
  
- <span data-ttu-id="42367-186">これは 3 番目の接続を開き、READ COMMITTED 分離レベルを使用してトランザクションを開始し、テーブル内のデータの読み取りを試みます。</span><span class="sxs-lookup"><span data-stu-id="42367-186">It opens a third connection and initiates a transaction using the READ COMMITTED isolation level to attempt to read the data in the table.</span></span> <span data-ttu-id="42367-187">この場合、コードは、最初のトランザクションでテーブルに設定されたロックを超えて読み取ることができず、タイムアウトを返すことができないため、データを読み取ることができません。反復可能な READ および SERIALIZABLE 分離レベルが使用された場合、これらの分離レベルも最初のトランザクションに入れられたロックを超えて読み取ることができないため、同じ結果が生じます。</span><span class="sxs-lookup"><span data-stu-id="42367-187">In this case, the code cannot read the data because it cannot read past the locks placed on the table in the first transaction and times out. The same result would occur if the REPEATABLE READ and SERIALIZABLE isolation levels were used because these isolation levels also cannot read past the locks placed in the first transaction.</span></span>  
  
- <span data-ttu-id="42367-188">これは 4 番目の接続を開き、READ UNCOMMITTED 分離レベルを使用してトランザクションを開始し、sqlTransaction1 でコミットされていない値のダーティ リードを実行します。</span><span class="sxs-lookup"><span data-stu-id="42367-188">It opens a fourth connection and initiates a transaction using the READ UNCOMMITTED isolation level, which performs a dirty read of the uncommitted value in sqlTransaction1.</span></span> <span data-ttu-id="42367-189">最初のトランザクションがコミットされていない場合、この値は実際にはデータベースに存在しない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="42367-189">This value may never actually exist in the database if the first transaction is not committed.</span></span>  
  
- <span data-ttu-id="42367-190">**TestSnapshot** テーブルを削除し、**AdventureWorks** データベースのスナップショット分離をオフにすることにより、最初のトランザクションをロールバックおよびクリーンアップします。</span><span class="sxs-lookup"><span data-stu-id="42367-190">It rolls back the first transaction and cleans up by deleting the **TestSnapshot** table and turning off snapshot isolation for the **AdventureWorks** database.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="42367-191">次の例では、接続プールを無効にして、同じ接続文字列を使用します。</span><span class="sxs-lookup"><span data-stu-id="42367-191">The following examples use the same connection string with connection pooling turned off.</span></span> <span data-ttu-id="42367-192">接続がプールされている場合、その分離レベルをリセットしても、サーバーの分離レベルはリセットされません。</span><span class="sxs-lookup"><span data-stu-id="42367-192">If a connection is pooled, resetting its isolation level does not reset the isolation level at the server.</span></span> <span data-ttu-id="42367-193">その結果、プールされている同じ内部接続を使用する後続の接続は、その分離レベルをプールされている接続の分離レベルに設定して開始されます。</span><span class="sxs-lookup"><span data-stu-id="42367-193">As a result, subsequent connections that use the same pooled inner connection start with their isolation levels set to that of the pooled connection.</span></span> <span data-ttu-id="42367-194">接続プールを無効にする代わりに、各接続の分離レベルを明示的に設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="42367-194">An alternative to turning off connection pooling is to set the isolation level explicitly for each connection.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/VB/source.vb#1)]  
  
### <a name="example"></a><span data-ttu-id="42367-195">例</span><span class="sxs-lookup"><span data-stu-id="42367-195">Example</span></span>  
 <span data-ttu-id="42367-196">次の例では、データの変更中のスナップショット分離の動作を示しています。</span><span class="sxs-lookup"><span data-stu-id="42367-196">The following example demonstrates the behavior of snapshot isolation when data is being modified.</span></span> <span data-ttu-id="42367-197">このコードで次のアクションが実行されます。</span><span class="sxs-lookup"><span data-stu-id="42367-197">The code performs the following actions:</span></span>  
  
- <span data-ttu-id="42367-198">**AdventureWorks** サンプル データベースに接続し、SNAPSHOT 分離を有効にします。</span><span class="sxs-lookup"><span data-stu-id="42367-198">Connects to the **AdventureWorks** sample database and enables SNAPSHOT isolation.</span></span>  
  
- <span data-ttu-id="42367-199">**TestSnapshotUpdate** という名前のテーブルを作成し、3 行のサンプル データを挿入します。</span><span class="sxs-lookup"><span data-stu-id="42367-199">Creates a table named **TestSnapshotUpdate** and inserts three rows of sample data.</span></span>  
  
- <span data-ttu-id="42367-200">SNAPSHOT 分離を使用して sqlTransaction1 を開始しますが、完了はしません。</span><span class="sxs-lookup"><span data-stu-id="42367-200">Begins, but does not complete, sqlTransaction1 using SNAPSHOT isolation.</span></span> <span data-ttu-id="42367-201">トランザクションでは、3 行のデータが選択されます。</span><span class="sxs-lookup"><span data-stu-id="42367-201">Three rows of data are selected in the transaction.</span></span>  
  
- <span data-ttu-id="42367-202">2 つ目の **SqlConnection** を **AdventureWorks** に対して作成し、sqlTransaction1 内で選択された行のうち 1 行の値を更新する READ COMMITTED 分離レベルを使用して、2 つ目のトランザクションを作成します。</span><span class="sxs-lookup"><span data-stu-id="42367-202">Creates a second **SqlConnection** to **AdventureWorks** and creates a second transaction using the READ COMMITTED isolation level that updates a value in one of the rows selected in sqlTransaction1.</span></span>  
  
- <span data-ttu-id="42367-203">sqlTransaction2 をコミットします。</span><span class="sxs-lookup"><span data-stu-id="42367-203">Commits sqlTransaction2.</span></span>  
  
- <span data-ttu-id="42367-204">sqlTransaction1 に戻り、sqlTransaction1 がすでにコミットした同じ行を更新しようとします。</span><span class="sxs-lookup"><span data-stu-id="42367-204">Returns to sqlTransaction1 and attempts to update the same row that sqlTransaction1 already committed.</span></span> <span data-ttu-id="42367-205">エラー 3960 が発生し、sqlTransaction1 が自動的にロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="42367-205">Error 3960 is raised, and sqlTransaction1 is rolled back automatically.</span></span> <span data-ttu-id="42367-206">**SqlException.Number** と **SqlException.Message** がコンソール ウィンドウに表示されます。</span><span class="sxs-lookup"><span data-stu-id="42367-206">The **SqlException.Number** and **SqlException.Message** are displayed in the Console window.</span></span>  
  
- <span data-ttu-id="42367-207">クリーンアップ コードを実行して **AdventureWorks** 内のスナップショット分離をオフにし、**TestSnapshotUpdate** テーブルを削除します。</span><span class="sxs-lookup"><span data-stu-id="42367-207">Executes clean-up code to turn off snapshot isolation in **AdventureWorks** and delete the **TestSnapshotUpdate** table.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/VB/source.vb#1)]  
  
### <a name="using-lock-hints-with-snapshot-isolation"></a><span data-ttu-id="42367-208">スナップショット分離でのロック ヒントの使用</span><span class="sxs-lookup"><span data-stu-id="42367-208">Using Lock Hints with Snapshot Isolation</span></span>  
 <span data-ttu-id="42367-209">前の例では、最初のトランザクションでデータが選択され、最初のトランザクションが完了する前に 2 番目のトランザクションによってデータが更新されるため、最初のトランザクションで同じ行を更新しようとしたときに更新の競合が発生します。</span><span class="sxs-lookup"><span data-stu-id="42367-209">In the previous example, the first transaction selects data, and a second transaction updates the data before the first transaction is able to complete, causing an update conflict when the first transaction tries to update the same row.</span></span> <span data-ttu-id="42367-210">トランザクションの開始時にロック ヒントを指定することで、実行時間の長いスナップショット トランザクションで更新の競合が発生する機会を削減できます。</span><span class="sxs-lookup"><span data-stu-id="42367-210">You can reduce the chance of update conflicts in long-running snapshot transactions by supplying lock hints at the beginning of the transaction.</span></span> <span data-ttu-id="42367-211">次の SELECT ステートメントでは、UPDLOCK ヒントを使用して、選択した行をロックします。</span><span class="sxs-lookup"><span data-stu-id="42367-211">The following SELECT statement uses the UPDLOCK hint to lock the selected rows:</span></span>  
  
```sql  
SELECT * FROM TestSnapshotUpdate WITH (UPDLOCK)
  WHERE PriKey BETWEEN 1 AND 3  
```  
  
 <span data-ttu-id="42367-212">UPDLOCK ロック ヒントを使用すると、最初のトランザクションが完了する前に行を更新しようとするすべての行がブロックされます。</span><span class="sxs-lookup"><span data-stu-id="42367-212">Using the UPDLOCK lock hint blocks any rows attempting to update the rows before the first transaction completes.</span></span> <span data-ttu-id="42367-213">これにより、トランザクションの後半で、選択した行が更新されるときに、確実に競合が発生しなくなります。</span><span class="sxs-lookup"><span data-stu-id="42367-213">This guarantees that the selected rows have no conflicts when they are updated later in the transaction.</span></span> <span data-ttu-id="42367-214">SQL Server オンラインブックの「ロック ヒント」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42367-214">See "Locking Hints" in SQL Server Books Online.</span></span>  
  
 <span data-ttu-id="42367-215">アプリケーションで多くの競合が発生する場合は、スナップショット分離が最適な選択肢にならないことがあります。</span><span class="sxs-lookup"><span data-stu-id="42367-215">If your application has many conflicts, snapshot isolation may not be the best choice.</span></span> <span data-ttu-id="42367-216">ヒントは、本当に必要な場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="42367-216">Hints should only be used when really needed.</span></span> <span data-ttu-id="42367-217">アプリケーションでは、その操作が常にロック ヒントに依存することのないように設計してください。</span><span class="sxs-lookup"><span data-stu-id="42367-217">Your application should not be designed so that it constantly relies on lock hints for its operation.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="42367-218">関連項目</span><span class="sxs-lookup"><span data-stu-id="42367-218">See also</span></span>

- [<span data-ttu-id="42367-219">SQL Server と ADO.NET</span><span class="sxs-lookup"><span data-stu-id="42367-219">SQL Server and ADO.NET</span></span>](index.md)
- [<span data-ttu-id="42367-220">ADO.NET の概要</span><span class="sxs-lookup"><span data-stu-id="42367-220">ADO.NET Overview</span></span>](../ado-net-overview.md)
- [<span data-ttu-id="42367-221">トランザクションのロックおよび行のバージョン管理ガイド</span><span class="sxs-lookup"><span data-stu-id="42367-221">Transaction Locking and Row Versioning Guide</span></span>](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)
