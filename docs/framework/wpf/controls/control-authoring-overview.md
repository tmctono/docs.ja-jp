---
title: コントロールの作成の概要
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- controls [WPF], authoring overview
- authoring overview for controls [WPF]
ms.assetid: 3d864748-cff0-4e63-9b23-d8e5a635b28f
ms.openlocfilehash: fba640ab71459407bfc7a62908021e509346c363
ms.sourcegitcommit: 5a28f8eb071fcc09b045b0c4ae4b96898673192e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/31/2019
ms.locfileid: "73197367"
---
# <a name="control-authoring-overview"></a><span data-ttu-id="be9ab-102">コントロールの作成の概要</span><span class="sxs-lookup"><span data-stu-id="be9ab-102">Control Authoring Overview</span></span>

<span data-ttu-id="be9ab-103">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] コントロール モデルの機能拡張により、新しいコントロールを作成する必要性が大幅に削減されます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-103">The extensibility of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] control model greatly reduces the need to create a new control.</span></span> <span data-ttu-id="be9ab-104">ただし、場合によっては、カスタム コントロールを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-104">However, in certain cases you may still need to create a custom control.</span></span> <span data-ttu-id="be9ab-105">このトピックでは、カスタム コントロールを作成する必要性を最小限に抑える機能と、[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] のさまざまなコントロール作成モデルについて説明します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-105">This topic discusses the features that minimize your need to create a custom control and the different control authoring models in [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)].</span></span> <span data-ttu-id="be9ab-106">また、新しいコントロールを作成する方法も示します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-106">This topic also demonstrates how to create a new control.</span></span>

<a name="when_to_write_a_new_control"></a>

## <a name="alternatives-to-writing-a-new-control"></a><span data-ttu-id="be9ab-107">新しいコントロールの作成に代わる方法</span><span class="sxs-lookup"><span data-stu-id="be9ab-107">Alternatives to Writing a New Control</span></span>

<span data-ttu-id="be9ab-108">従来は、既存のコントロールをカスタマイズする場合、背景色、境界線の幅、フォントのサイズなど、コントロールの標準プロパティを変更するなどの範囲に制限されていました。</span><span class="sxs-lookup"><span data-stu-id="be9ab-108">Historically, if you wanted to get a customized experience from an existing control, you were limited to changing the standard properties of the control, such as background color, border width, and font size.</span></span> <span data-ttu-id="be9ab-109">これらの定義済みのパラメーター以外に、コントロールの外観や動作にまでカスタマイズを拡張しようとすると、通常、既存のコントロールを継承し、コントロールを描画するメソッドをオーバーライドして、新しいコントロールを作成する必要がありました。</span><span class="sxs-lookup"><span data-stu-id="be9ab-109">If you wished to extend the appearance or behavior of a control beyond these predefined parameters, you would need to create a new control, usually by inheriting from an existing control and overriding the method responsible for drawing the control.</span></span>  <span data-ttu-id="be9ab-110">その方法は今でも選択できますが、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の場合、リッチ コンテンツ モデル、スタイル、テンプレート、トリガーを使用して、既存のコントロールをカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-110">Although that is still an option, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] enables to you customize existing controls by using its rich content model, styles, templates, and triggers.</span></span> <span data-ttu-id="be9ab-111">新しいコントロールを作成しなくても、これらの機能を使用して、カスタマイズされた一貫性のあるエクスペリエンスを得られる方法としては、次のような例が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-111">The following list gives examples of how these features can be used to create custom and consistent experiences without having to create a new control.</span></span>

- <span data-ttu-id="be9ab-112">**リッチ コンテンツ。**</span><span class="sxs-lookup"><span data-stu-id="be9ab-112">**Rich Content.**</span></span> <span data-ttu-id="be9ab-113">標準の [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] コントロールの多くがリッチ コンテンツをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="be9ab-113">Many of the standard [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls support rich content.</span></span> <span data-ttu-id="be9ab-114">たとえば、<xref:System.Windows.Controls.Button> の content プロパティは <xref:System.Object>型であるため、理論的には <xref:System.Windows.Controls.Button>に何でも表示できます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-114">For example, the content property of a <xref:System.Windows.Controls.Button> is of type <xref:System.Object>, so theoretically anything can be displayed on a <xref:System.Windows.Controls.Button>.</span></span>  <span data-ttu-id="be9ab-115">ボタンに画像とテキストを表示させるには、画像と <xref:System.Windows.Controls.TextBlock> を <xref:System.Windows.Controls.StackPanel> に追加し、<xref:System.Windows.Controls.StackPanel> を <xref:System.Windows.Controls.ContentControl.Content%2A> プロパティに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-115">To have a button display an image and text, you can add an image and a <xref:System.Windows.Controls.TextBlock> to a <xref:System.Windows.Controls.StackPanel> and assign the <xref:System.Windows.Controls.StackPanel> to the <xref:System.Windows.Controls.ContentControl.Content%2A> property.</span></span> <span data-ttu-id="be9ab-116">コントロールには、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の視覚的要素と任意のデータを表示できるため、複雑な視覚化をサポートするために、新しいコントロールを作成したり、既存のコントロールを変更したりする必要性が少なくなります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-116">Because the controls can display [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] visual elements and arbitrary data, there is less need to create a new control or to modify an existing control to support a complex visualization.</span></span> <span data-ttu-id="be9ab-117">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]における <xref:System.Windows.Controls.Button> およびその他のコンテンツモデルのコンテンツモデルの詳細については、「 [WPF コンテンツモデル](wpf-content-model.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="be9ab-117">For more information about the content model for <xref:System.Windows.Controls.Button> and other content models in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [WPF Content Model](wpf-content-model.md).</span></span>

- <span data-ttu-id="be9ab-118">**スタイル**</span><span class="sxs-lookup"><span data-stu-id="be9ab-118">**Styles.**</span></span> <span data-ttu-id="be9ab-119"><xref:System.Windows.Style> は、コントロールのプロパティを表す値のコレクションです。</span><span class="sxs-lookup"><span data-stu-id="be9ab-119">A <xref:System.Windows.Style> is a collection of values that represent properties for a control.</span></span> <span data-ttu-id="be9ab-120">スタイルを使用すると、新しいコントロールを作成しなくても、必要なコントロールの外観と動作を備えた再利用可能な表現を作成できます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-120">By using styles, you can create a reusable representation of a desired control appearance and behavior without writing a new control.</span></span> <span data-ttu-id="be9ab-121">たとえば、すべての <xref:System.Windows.Controls.TextBlock> コントロールに対して、フォントサイズが14の赤い Arial フォントを使用するとします。</span><span class="sxs-lookup"><span data-stu-id="be9ab-121">For example, assume that you want all of your <xref:System.Windows.Controls.TextBlock> controls to have red, Arial font with a font size of 14.</span></span> <span data-ttu-id="be9ab-122">そこで、リソースとしてスタイルを作成し、それに応じて、適切なプロパティを設定します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-122">You can create a style as a resource and set the appropriate properties accordingly.</span></span> <span data-ttu-id="be9ab-123">アプリケーションに追加したすべての <xref:System.Windows.Controls.TextBlock> の外観は同じになります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-123">Then every <xref:System.Windows.Controls.TextBlock> that you add to your application will have the same appearance.</span></span>

- <span data-ttu-id="be9ab-124">**データ テンプレート。**</span><span class="sxs-lookup"><span data-stu-id="be9ab-124">**Data Templates.**</span></span> <span data-ttu-id="be9ab-125"><xref:System.Windows.DataTemplate> を使用すると、コントロールにデータを表示する方法をカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-125">A <xref:System.Windows.DataTemplate> enables you to customize how data is displayed on a control.</span></span> <span data-ttu-id="be9ab-126">たとえば、<xref:System.Windows.DataTemplate> を使用すると、<xref:System.Windows.Controls.ListBox>でのデータの表示方法を指定できます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-126">For example, a <xref:System.Windows.DataTemplate> can be used to specify how data is displayed in a <xref:System.Windows.Controls.ListBox>.</span></span>  <span data-ttu-id="be9ab-127">この例については、「[データ テンプレートの概要](../data/data-templating-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="be9ab-127">For an example of this, see [Data Templating Overview](../data/data-templating-overview.md).</span></span>  <span data-ttu-id="be9ab-128">データの外観をカスタマイズすることに加えて、<xref:System.Windows.DataTemplate> には UI 要素を含めることができます。これにより、カスタム Ui の柔軟性が大幅に向上します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-128">In addition to customizing the appearance of data, a <xref:System.Windows.DataTemplate> can include UI elements, which gives you a lot of flexibility in custom UIs.</span></span>  <span data-ttu-id="be9ab-129">たとえば、<xref:System.Windows.DataTemplate>を使用すると、各項目にチェックボックスが含まれている <xref:System.Windows.Controls.ComboBox> を作成できます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-129">For example, by using a <xref:System.Windows.DataTemplate>, you can create a <xref:System.Windows.Controls.ComboBox> in which each item contains a check box.</span></span>

- <span data-ttu-id="be9ab-130">**コントロール テンプレート。**</span><span class="sxs-lookup"><span data-stu-id="be9ab-130">**Control Templates.**</span></span> <span data-ttu-id="be9ab-131">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の多くのコントロールでは、コントロールの構造と外観を定義するために <xref:System.Windows.Controls.ControlTemplate> を使用します。これにより、コントロールの外観とコントロールの機能が分離されます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-131">Many controls in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] use a <xref:System.Windows.Controls.ControlTemplate> to define the control's structure and appearance, which separates the appearance of a control from the functionality of the control.</span></span> <span data-ttu-id="be9ab-132"><xref:System.Windows.Controls.ControlTemplate>を再定義することで、コントロールの外観を大幅に変更できます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-132">You can drastically change the appearance of a control by redefining its <xref:System.Windows.Controls.ControlTemplate>.</span></span>  <span data-ttu-id="be9ab-133">たとえば、信号機のような外観のコントロールが必要だとします。</span><span class="sxs-lookup"><span data-stu-id="be9ab-133">For example, suppose you want a control that looks like a stoplight.</span></span> <span data-ttu-id="be9ab-134">このコントロールのユーザー インターフェイスと機能は単純です。</span><span class="sxs-lookup"><span data-stu-id="be9ab-134">This control has a simple user interface and functionality.</span></span>  <span data-ttu-id="be9ab-135">コントロールは 3 つの円で構成され、一度に点灯するのはそのうちの 1 つだけです。</span><span class="sxs-lookup"><span data-stu-id="be9ab-135">The control is three circles, only one of which can be lit up at a time.</span></span> <span data-ttu-id="be9ab-136">一部のリフレクションでは、一度に選択できるのは1つの機能だけであることがわかっている場合がありますが、<xref:System.Windows.Controls.RadioButton> の既定の外観は、ライト信号のようなものでは <xref:System.Windows.Controls.RadioButton> ないように見えます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-136">After some reflection, you might realize that a <xref:System.Windows.Controls.RadioButton> offers the functionality of only one being selected at a time, but the default appearance of the <xref:System.Windows.Controls.RadioButton> looks nothing like the lights on a stoplight.</span></span>  <span data-ttu-id="be9ab-137"><xref:System.Windows.Controls.RadioButton> はコントロールテンプレートを使用してその外観を定義するため、コントロールの要件に合わせて <xref:System.Windows.Controls.ControlTemplate> を再定義し、オプションボタンを使用して信号を行うことが簡単です。</span><span class="sxs-lookup"><span data-stu-id="be9ab-137">Because the <xref:System.Windows.Controls.RadioButton> uses a control template to define its appearance, it is easy to redefine the <xref:System.Windows.Controls.ControlTemplate> to fit the requirements of the control, and use radio buttons to make your stoplight.</span></span>

  > [!NOTE]
  > <span data-ttu-id="be9ab-138"><xref:System.Windows.Controls.RadioButton> は <xref:System.Windows.DataTemplate>を使用できますが、この例では <xref:System.Windows.DataTemplate> では不十分です。</span><span class="sxs-lookup"><span data-stu-id="be9ab-138">Although a <xref:System.Windows.Controls.RadioButton> can use a <xref:System.Windows.DataTemplate>, a <xref:System.Windows.DataTemplate> is not sufficient in this example.</span></span>  <span data-ttu-id="be9ab-139"><xref:System.Windows.DataTemplate> は、コントロールのコンテンツの外観を定義します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-139">The <xref:System.Windows.DataTemplate> defines the appearance of the content of a control.</span></span> <span data-ttu-id="be9ab-140"><xref:System.Windows.Controls.RadioButton>の場合、コンテンツは、<xref:System.Windows.Controls.RadioButton> が選択されているかどうかを示す円の右側に表示されます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-140">In the case of a <xref:System.Windows.Controls.RadioButton>, the content is whatever appears to the right of the circle that indicates whether the <xref:System.Windows.Controls.RadioButton> is selected.</span></span>  <span data-ttu-id="be9ab-141">信号機の例では、オプション ボタンに必要なのは "点灯" する円だけです。</span><span class="sxs-lookup"><span data-stu-id="be9ab-141">In the example of the stoplight, the radio button needs just be a circle that can "light up."</span></span> <span data-ttu-id="be9ab-142">信号の外観要件は <xref:System.Windows.Controls.RadioButton>の既定の外観とは異なるため、<xref:System.Windows.Controls.ControlTemplate>を再定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-142">Because the appearance requirement for the stoplight is so different than the default appearance of the <xref:System.Windows.Controls.RadioButton>, it is necessary to redefine the <xref:System.Windows.Controls.ControlTemplate>.</span></span>  <span data-ttu-id="be9ab-143">一般に、コントロールのコンテンツ (またはデータ) を定義するために <xref:System.Windows.DataTemplate> を使用し、<xref:System.Windows.Controls.ControlTemplate> を使用してコントロールを構造化する方法を定義します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-143">In general a <xref:System.Windows.DataTemplate> is used for defining the content (or data) of a control, and a <xref:System.Windows.Controls.ControlTemplate> is used for defining how a control is structured.</span></span>

- <span data-ttu-id="be9ab-144">**トリガー。**</span><span class="sxs-lookup"><span data-stu-id="be9ab-144">**Triggers.**</span></span> <span data-ttu-id="be9ab-145"><xref:System.Windows.Trigger> を使用すると、新しいコントロールを作成せずに、コントロールの外観と動作を動的に変更できます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-145">A <xref:System.Windows.Trigger> allows you to dynamically change the appearance and behavior of a control without creating a new control.</span></span> <span data-ttu-id="be9ab-146">たとえば、アプリケーションに複数の <xref:System.Windows.Controls.ListBox> コントロールがあり、各 <xref:System.Windows.Controls.ListBox> の項目を選択したときに太字と赤にする必要があるとします。</span><span class="sxs-lookup"><span data-stu-id="be9ab-146">For example, suppose you have multiple <xref:System.Windows.Controls.ListBox> controls in your application and want the items in each <xref:System.Windows.Controls.ListBox> to be bold and red when they are selected.</span></span> <span data-ttu-id="be9ab-147">最初の性質は、<xref:System.Windows.Controls.ListBox> から継承するクラスを作成し、選択した項目の外観を変更するために <xref:System.Windows.Controls.Primitives.Selector.OnSelectionChanged%2A> メソッドをオーバーライドする場合がありますが、選択した項目の外観を変更する <xref:System.Windows.Controls.ListBoxItem> のスタイルにトリガーを追加する方法が適しています.</span><span class="sxs-lookup"><span data-stu-id="be9ab-147">Your first instinct might be to create a class that inherits from <xref:System.Windows.Controls.ListBox> and override the <xref:System.Windows.Controls.Primitives.Selector.OnSelectionChanged%2A> method to change the appearance of the selected item, but a better approach is to add a trigger to a style of a <xref:System.Windows.Controls.ListBoxItem> that changes the appearance of the selected item.</span></span> <span data-ttu-id="be9ab-148">トリガーを使用すると、プロパティ値を変更したり、プロパティ値に基づいた処理を実行したりできます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-148">A trigger enables you to change property values or take actions based on the value of a property.</span></span> <span data-ttu-id="be9ab-149"><xref:System.Windows.EventTrigger> を使用すると、イベントが発生したときにアクションを実行できます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-149">An <xref:System.Windows.EventTrigger> enables you to take actions when an event occurs.</span></span>

<span data-ttu-id="be9ab-150">スタイル、テンプレート、トリガーの詳細については、「[スタイルとテンプレート](styling-and-templating.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="be9ab-150">For more information about styles, templates, and triggers, see [Styling and Templating](styling-and-templating.md).</span></span>

<span data-ttu-id="be9ab-151">一般に、既存のコントロールと同じ機能を持ち、外観が異なるコントロールが必要な場合は、このセクションで説明した方法のいずれかを使用して、既存のコントロールの外観を変更できないかどうかをまず検討することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="be9ab-151">In general, if your control mirrors the functionality of an existing control, but you want the control to look different, you should first consider whether you can use any of the methods discussed in this section to change the existing control's appearance.</span></span>

<a name="models_for_control_authoring"></a>

## <a name="models-for-control-authoring"></a><span data-ttu-id="be9ab-152">コントロール作成モデル</span><span class="sxs-lookup"><span data-stu-id="be9ab-152">Models for Control Authoring</span></span>

<span data-ttu-id="be9ab-153">リッチ コンテンツ モデル、スタイル、テンプレート、トリガーを使用すると、新しいコントロールを作成する必要性が最小限に抑えられます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-153">The rich content model, styles, templates, and triggers minimize the need for you to create a new control.</span></span> <span data-ttu-id="be9ab-154">ただし、新しいコントロールを作成する必要がある場合は、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の各種のコントロール作成モデルを理解することが重要です。</span><span class="sxs-lookup"><span data-stu-id="be9ab-154">However, if you do need to create a new control, it is important to understand the different control authoring models in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="be9ab-155">には、コントロールを作成するための一般的なモデルが 3 つあり、各モデルはそれぞれ異なる機能と柔軟性レベルを備えています。</span><span class="sxs-lookup"><span data-stu-id="be9ab-155">provides three general models for creating a control, each of which provides a different set of features and level of flexibility.</span></span> <span data-ttu-id="be9ab-156">3つのモデルの基本クラスは、<xref:System.Windows.Controls.UserControl>、<xref:System.Windows.Controls.Control>、および <xref:System.Windows.FrameworkElement>です。</span><span class="sxs-lookup"><span data-stu-id="be9ab-156">The base classes for the three models are <xref:System.Windows.Controls.UserControl>, <xref:System.Windows.Controls.Control>, and <xref:System.Windows.FrameworkElement>.</span></span>

### <a name="deriving-from-usercontrol"></a><span data-ttu-id="be9ab-157">UserControl からの派生</span><span class="sxs-lookup"><span data-stu-id="be9ab-157">Deriving from UserControl</span></span>

<span data-ttu-id="be9ab-158">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] でコントロールを作成する最も簡単な方法は、<xref:System.Windows.Controls.UserControl>から派生することです。</span><span class="sxs-lookup"><span data-stu-id="be9ab-158">The simplest way to create a control in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to derive from <xref:System.Windows.Controls.UserControl>.</span></span> <span data-ttu-id="be9ab-159"><xref:System.Windows.Controls.UserControl>から継承するコントロールを作成する場合は、既存のコンポーネントを <xref:System.Windows.Controls.UserControl>に追加し、コンポーネントに名前を付けると共に、[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]でイベントハンドラーを参照します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-159">When you build a control that inherits from <xref:System.Windows.Controls.UserControl>, you add existing components to the <xref:System.Windows.Controls.UserControl>, name the components, and reference event handlers in [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)].</span></span> <span data-ttu-id="be9ab-160">次に、指定の要素を参照し、コードでイベント ハンドラーを定義します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-160">You can then reference the named elements and define the event handlers in code.</span></span> <span data-ttu-id="be9ab-161">この開発モデルは、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] でのアプリケーション開発に使用されるモデルとよく似ています。</span><span class="sxs-lookup"><span data-stu-id="be9ab-161">This development model is very similar to the model used for application development in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>

<span data-ttu-id="be9ab-162">正しく構築されている場合、<xref:System.Windows.Controls.UserControl> はリッチコンテンツ、スタイル、およびトリガーの利点を活用できます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-162">If built correctly, a <xref:System.Windows.Controls.UserControl> can take advantage of the benefits of rich content, styles, and triggers.</span></span> <span data-ttu-id="be9ab-163">ただし、コントロールが <xref:System.Windows.Controls.UserControl>から継承されている場合、コントロールを使用するユーザーは、<xref:System.Windows.DataTemplate> または <xref:System.Windows.Controls.ControlTemplate> を使用してその外観をカスタマイズすることはできません。</span><span class="sxs-lookup"><span data-stu-id="be9ab-163">However, if your control inherits from <xref:System.Windows.Controls.UserControl>, people who use your control will not be able to use a <xref:System.Windows.DataTemplate> or <xref:System.Windows.Controls.ControlTemplate> to customize its appearance.</span></span>  <span data-ttu-id="be9ab-164">テンプレートをサポートするカスタムコントロールを作成するには、<xref:System.Windows.Controls.Control> クラスまたはその派生クラス (<xref:System.Windows.Controls.UserControl>以外) から派生する必要があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-164">It is necessary to derive from the <xref:System.Windows.Controls.Control> class or one of its derived classes (other than <xref:System.Windows.Controls.UserControl>) to create a custom control that supports templates.</span></span>

#### <a name="benefits-of-deriving-from-usercontrol"></a><span data-ttu-id="be9ab-165">UserControl からの派生の利点</span><span class="sxs-lookup"><span data-stu-id="be9ab-165">Benefits of Deriving from UserControl</span></span>

<span data-ttu-id="be9ab-166">次のすべてに該当する場合は、<xref:System.Windows.Controls.UserControl> から派生することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="be9ab-166">Consider deriving from <xref:System.Windows.Controls.UserControl> if all of the following apply:</span></span>

- <span data-ttu-id="be9ab-167">アプリケーションの構築と同じ方法でコントロールをビルドする必要がある場合。</span><span class="sxs-lookup"><span data-stu-id="be9ab-167">You want to build your control similarly to how you build an application.</span></span>

- <span data-ttu-id="be9ab-168">コントロールが既存のコンポーネントのみで構成されている場合。</span><span class="sxs-lookup"><span data-stu-id="be9ab-168">Your control consists only of existing components.</span></span>

- <span data-ttu-id="be9ab-169">複雑なカスタマイズをサポートする必要がない場合。</span><span class="sxs-lookup"><span data-stu-id="be9ab-169">You don't need to support complex customization.</span></span>

### <a name="deriving-from-control"></a><span data-ttu-id="be9ab-170">Control からの派生</span><span class="sxs-lookup"><span data-stu-id="be9ab-170">Deriving from Control</span></span>

<span data-ttu-id="be9ab-171"><xref:System.Windows.Controls.Control> クラスからの派生は、既存の [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] コントロールの大部分で使用されるモデルです。</span><span class="sxs-lookup"><span data-stu-id="be9ab-171">Deriving from the <xref:System.Windows.Controls.Control> class is the model used by most of the existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls.</span></span> <span data-ttu-id="be9ab-172"><xref:System.Windows.Controls.Control> クラスから継承するコントロールを作成する場合は、テンプレートを使用してそのコントロールの外観を定義します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-172">When you create a control that inherits from the <xref:System.Windows.Controls.Control> class, you define its appearance by using templates.</span></span> <span data-ttu-id="be9ab-173">これにより、操作ロジックと視覚的表現とが分離されます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-173">By doing so, you separate the operational logic from the visual representation.</span></span> <span data-ttu-id="be9ab-174">また、イベントではなくコマンドとバインドを使用して UI とロジックを分離し、可能な限り <xref:System.Windows.Controls.ControlTemplate> 内の要素を参照しないようにすることもできます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-174">You can also ensure the decoupling of the UI and logic by using commands and bindings instead of events and avoiding referencing elements in the <xref:System.Windows.Controls.ControlTemplate> whenever possible.</span></span>  <span data-ttu-id="be9ab-175">コントロールの UI とロジックが適切に分離されている場合は、コントロールのユーザーがコントロールの <xref:System.Windows.Controls.ControlTemplate> を再定義して、外観をカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-175">If the UI and logic of your control are properly decoupled, a user of your control can redefine the control's <xref:System.Windows.Controls.ControlTemplate> to customize its appearance.</span></span> <span data-ttu-id="be9ab-176">カスタム <xref:System.Windows.Controls.Control> の構築は、<xref:System.Windows.Controls.UserControl>を構築するほど簡単ではありませんが、カスタム <xref:System.Windows.Controls.Control> は最も柔軟性があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-176">Although building a custom <xref:System.Windows.Controls.Control> is not as simple as building a <xref:System.Windows.Controls.UserControl>, a custom <xref:System.Windows.Controls.Control> provides the most flexibility.</span></span>

#### <a name="benefits-of-deriving-from-control"></a><span data-ttu-id="be9ab-177">Control からの派生の利点</span><span class="sxs-lookup"><span data-stu-id="be9ab-177">Benefits of Deriving from Control</span></span>

<span data-ttu-id="be9ab-178">次のいずれかに該当する場合は、<xref:System.Windows.Controls.UserControl> クラスを使用するのではなく、<xref:System.Windows.Controls.Control> から派生することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="be9ab-178">Consider deriving from <xref:System.Windows.Controls.Control> instead of using the <xref:System.Windows.Controls.UserControl> class if any of the following apply:</span></span>

- <span data-ttu-id="be9ab-179">コントロールの外観をカスタマイズできるようにするには、<xref:System.Windows.Controls.ControlTemplate>を使用します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-179">You want the appearance of your control to be customizable via the <xref:System.Windows.Controls.ControlTemplate>.</span></span>

- <span data-ttu-id="be9ab-180">コントロールがさまざまなテーマをサポートする必要がある場合。</span><span class="sxs-lookup"><span data-stu-id="be9ab-180">You want your control to support different themes.</span></span>

### <a name="deriving-from-frameworkelement"></a><span data-ttu-id="be9ab-181">FrameworkElement からの派生</span><span class="sxs-lookup"><span data-stu-id="be9ab-181">Deriving from FrameworkElement</span></span>

<span data-ttu-id="be9ab-182"><xref:System.Windows.Controls.UserControl> または <xref:System.Windows.Controls.Control> から派生するコントロールは、既存の要素の作成に依存します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-182">Controls that derive from <xref:System.Windows.Controls.UserControl> or <xref:System.Windows.Controls.Control> rely upon composing existing elements.</span></span> <span data-ttu-id="be9ab-183">多くのシナリオでは、これは許容できるソリューションです。 <xref:System.Windows.FrameworkElement> から継承されたオブジェクトは <xref:System.Windows.Controls.ControlTemplate>内に存在する可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="be9ab-183">For many scenarios, this is an acceptable solution, because any object that inherits from <xref:System.Windows.FrameworkElement> can be in a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="be9ab-184">しかし、場合によっては、単純な要素コンポジションでは、コントロールの外観に必要な機能を実現できないことがあります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-184">However, there are times when a control's appearance requires more than the functionality of simple element composition.</span></span> <span data-ttu-id="be9ab-185">これらのシナリオでは、<xref:System.Windows.FrameworkElement> 上のコンポーネントに基づいて適切な選択を行います。</span><span class="sxs-lookup"><span data-stu-id="be9ab-185">For these scenarios, basing a component on <xref:System.Windows.FrameworkElement> is the right choice.</span></span>

<span data-ttu-id="be9ab-186"><xref:System.Windows.FrameworkElement>ベースのコンポーネントを構築するには、直接レンダリングとカスタム要素構成という2つの標準的な方法があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-186">There are two standard methods for building <xref:System.Windows.FrameworkElement>-based components: direct rendering and custom element composition.</span></span> <span data-ttu-id="be9ab-187">直接レンダリングでは、<xref:System.Windows.FrameworkElement> の <xref:System.Windows.UIElement.OnRender%2A> メソッドをオーバーライドし、コンポーネントのビジュアルを明示的に定義する <xref:System.Windows.Media.DrawingContext> 操作を提供します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-187">Direct rendering involves overriding the <xref:System.Windows.UIElement.OnRender%2A> method of <xref:System.Windows.FrameworkElement> and providing <xref:System.Windows.Media.DrawingContext> operations that explicitly define the component visuals.</span></span> <span data-ttu-id="be9ab-188">これは、<xref:System.Windows.Controls.Image> と <xref:System.Windows.Controls.Border>によって使用されるメソッドです。</span><span class="sxs-lookup"><span data-stu-id="be9ab-188">This is the method used by <xref:System.Windows.Controls.Image> and <xref:System.Windows.Controls.Border>.</span></span> <span data-ttu-id="be9ab-189">カスタム要素の構成では、<xref:System.Windows.Media.Visual> 型のオブジェクトを使用して、コンポーネントの外観を構成します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-189">Custom element composition involves using objects of type <xref:System.Windows.Media.Visual> to compose the appearance of your component.</span></span> <span data-ttu-id="be9ab-190">例については、「[DrawingVisual オブジェクトの使用](../graphics-multimedia/using-drawingvisual-objects.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="be9ab-190">For an example, see [Using DrawingVisual Objects](../graphics-multimedia/using-drawingvisual-objects.md).</span></span> <span data-ttu-id="be9ab-191"><xref:System.Windows.Controls.Primitives.Track> は、カスタム要素構成を使用する [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 内のコントロールの例です。</span><span class="sxs-lookup"><span data-stu-id="be9ab-191"><xref:System.Windows.Controls.Primitives.Track> is an example of a control in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] that uses custom element composition.</span></span> <span data-ttu-id="be9ab-192">同じコントロールでダイレクト レンダリングとカスタム要素コンポジションを混在させることもできます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-192">It is also possible to mix direct rendering and custom element composition in the same control.</span></span>

#### <a name="benefits-of-deriving-from-frameworkelement"></a><span data-ttu-id="be9ab-193">FrameworkElement からの派生の利点</span><span class="sxs-lookup"><span data-stu-id="be9ab-193">Benefits of Deriving from FrameworkElement</span></span>

<span data-ttu-id="be9ab-194">次のいずれかに該当する場合は、<xref:System.Windows.FrameworkElement> から派生することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="be9ab-194">Consider deriving from <xref:System.Windows.FrameworkElement> if any of the following apply:</span></span>

- <span data-ttu-id="be9ab-195">コントロールの外観について、単純な要素コンポジションが提供する以上の厳密な制御を必要とする場合。</span><span class="sxs-lookup"><span data-stu-id="be9ab-195">You want to have precise control over the appearance of your control beyond what is provided by simple element composition.</span></span>

- <span data-ttu-id="be9ab-196">独自のレンダリング ロジックを定義して、コントロールの外観を定義する必要がある場合。</span><span class="sxs-lookup"><span data-stu-id="be9ab-196">You want to define the appearance of your control by defining your own render logic.</span></span>

- <span data-ttu-id="be9ab-197">既存の要素を新しい方法で作成し、<xref:System.Windows.Controls.UserControl> と <xref:System.Windows.Controls.Control>で可能なものを超えています。</span><span class="sxs-lookup"><span data-stu-id="be9ab-197">You want to compose existing elements in novel ways that go beyond what is possible with <xref:System.Windows.Controls.UserControl> and <xref:System.Windows.Controls.Control>.</span></span>

<a name="control_authoring_basics"></a>

## <a name="control-authoring-basics"></a><span data-ttu-id="be9ab-198">コントロール作成の基本</span><span class="sxs-lookup"><span data-stu-id="be9ab-198">Control Authoring Basics</span></span>

<span data-ttu-id="be9ab-199">既に説明したように、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の最も強力な機能の 1 つは、コントロールの基本的なプロパティ設定だけでは不可能な外観や動作の変更を実現し、しかもカスタム コントロールを作成する必要がないということです。</span><span class="sxs-lookup"><span data-stu-id="be9ab-199">As discussed earlier, one of the most powerful features of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is the ability to go beyond setting basic properties of a control to change its appearance and behavior, yet still not needing to create a custom control.</span></span> <span data-ttu-id="be9ab-200">スタイル設定、データ バインディング、トリガーの各機能は、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] プロパティ システムおよび [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] イベント システムによって実現されています。</span><span class="sxs-lookup"><span data-stu-id="be9ab-200">The styling, data binding, and trigger features are made possible by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system and the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system.</span></span> <span data-ttu-id="be9ab-201">以降のセクションでは、カスタム コントロールのユーザーが、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] に付属のコントロールと同じように、これらの機能を使用できるようにするために、カスタム コントロールの作成に使用するモデルに関係なく、従う必要があるプラクティスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-201">The following sections describe some practices that you should follow, regardless of the model you use to create the custom control, so that users of your custom control can use these features just as they would for a control that is included with [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>

### <a name="use-dependency-properties"></a><span data-ttu-id="be9ab-202">依存関係プロパティの使用</span><span class="sxs-lookup"><span data-stu-id="be9ab-202">Use Dependency Properties</span></span>

<span data-ttu-id="be9ab-203">プロパティが依存関係プロパティである場合、以下の操作が可能です。</span><span class="sxs-lookup"><span data-stu-id="be9ab-203">When a property is a dependency property, it is possible to do the following:</span></span>

- <span data-ttu-id="be9ab-204">スタイルのプロパティを設定する。</span><span class="sxs-lookup"><span data-stu-id="be9ab-204">Set the property in a style.</span></span>

- <span data-ttu-id="be9ab-205">プロパティをデータ ソースにバインドする。</span><span class="sxs-lookup"><span data-stu-id="be9ab-205">Bind the property to a data source.</span></span>

- <span data-ttu-id="be9ab-206">プロパティの値として、動的リソースを使用する。</span><span class="sxs-lookup"><span data-stu-id="be9ab-206">Use a dynamic resource as the property's value.</span></span>

- <span data-ttu-id="be9ab-207">プロパティ名をアニメーション化する。</span><span class="sxs-lookup"><span data-stu-id="be9ab-207">Animate the property.</span></span>

<span data-ttu-id="be9ab-208">コントロールのプロパティがこれらの機能のいずれかをサポートす必要がある場合、それを依存関係プロパティとして実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-208">If you want a property of your control to support any of this functionality, you should implement it as a dependency property.</span></span> <span data-ttu-id="be9ab-209">次の例では、以下の処理を実行して、`Value` という名前の依存関係プロパティを定義します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-209">The following example defines a dependency property named `Value` by doing the following:</span></span>

- <span data-ttu-id="be9ab-210">`ValueProperty` という名前の <xref:System.Windows.DependencyProperty> 識別子を `readonly` フィールド `static` `public` として定義します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-210">Define a <xref:System.Windows.DependencyProperty> identifier named `ValueProperty` as a `public` `static` `readonly` field.</span></span>

- <span data-ttu-id="be9ab-211"><xref:System.Windows.DependencyProperty.Register%2A?displayProperty=nameWithType>を呼び出して、プロパティ名をプロパティシステムに登録し、次の値を指定します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-211">Register the property name with the property system, by calling <xref:System.Windows.DependencyProperty.Register%2A?displayProperty=nameWithType>, to specify the following:</span></span>

  - <span data-ttu-id="be9ab-212">プロパティの名前。</span><span class="sxs-lookup"><span data-stu-id="be9ab-212">The name of the property.</span></span>

  - <span data-ttu-id="be9ab-213">プロパティの型。</span><span class="sxs-lookup"><span data-stu-id="be9ab-213">The type of the property.</span></span>

  - <span data-ttu-id="be9ab-214">プロパティを所有する型。</span><span class="sxs-lookup"><span data-stu-id="be9ab-214">The type that owns the property.</span></span>

  - <span data-ttu-id="be9ab-215">プロパティのメタデータ。</span><span class="sxs-lookup"><span data-stu-id="be9ab-215">The metadata for the property.</span></span> <span data-ttu-id="be9ab-216">メタデータには、プロパティの既定値、<xref:System.Windows.CoerceValueCallback> および <xref:System.Windows.PropertyChangedCallback>が含まれています。</span><span class="sxs-lookup"><span data-stu-id="be9ab-216">The metadata contains the property's default value, a <xref:System.Windows.CoerceValueCallback> and a <xref:System.Windows.PropertyChangedCallback>.</span></span>

- <span data-ttu-id="be9ab-217">`Value`という名前の CLR ラッパープロパティを定義します。これは、プロパティの `get` と `set` アクセサーを実装することによって、依存関係プロパティの登録に使用される名前と同じです。</span><span class="sxs-lookup"><span data-stu-id="be9ab-217">Define a CLR wrapper property named `Value`, which is the same name that is used to register the dependency property, by implementing the property's `get` and `set` accessors.</span></span> <span data-ttu-id="be9ab-218">`get` アクセサーと `set` アクセサーは、それぞれ <xref:System.Windows.DependencyObject.GetValue%2A> および <xref:System.Windows.DependencyObject.SetValue%2A> を呼び出すだけであることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="be9ab-218">Note that the `get` and `set` accessors only call <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> respectively.</span></span> <span data-ttu-id="be9ab-219">クライアントと [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] はアクセサーをバイパスし、<xref:System.Windows.DependencyObject.GetValue%2A> と <xref:System.Windows.DependencyObject.SetValue%2A> を直接呼び出すことができるため、依存関係プロパティのアクセサーに追加のロジックが含まれないようにすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="be9ab-219">It is recommended that the accessors of dependency properties not contain additional logic because clients and [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can bypass the accessors and call <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> directly.</span></span> <span data-ttu-id="be9ab-220">たとえば、プロパティがデータ ソースにバインドされている場合、プロパティの `set` アクセサーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="be9ab-220">For example, when a property is bound to a data source, the property's `set` accessor is not called.</span></span>  <span data-ttu-id="be9ab-221">Get アクセサーと set アクセサーにロジックを追加するのではなく、<xref:System.Windows.ValidateValueCallback>、<xref:System.Windows.CoerceValueCallback>、および <xref:System.Windows.PropertyChangedCallback> デリゲートを使用して応答するか、変更時に値を確認します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-221">Instead of adding additional logic to the get and set accessors, use the <xref:System.Windows.ValidateValueCallback>, <xref:System.Windows.CoerceValueCallback>, and <xref:System.Windows.PropertyChangedCallback> delegates to respond to or check the value when it changes.</span></span>  <span data-ttu-id="be9ab-222">これらのコールバックの詳細については、「[依存関係プロパティのコールバックと検証](../advanced/dependency-property-callbacks-and-validation.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="be9ab-222">For more information on these callbacks, see [Dependency Property Callbacks and Validation](../advanced/dependency-property-callbacks-and-validation.md).</span></span>

- <span data-ttu-id="be9ab-223">`CoerceValue`という名前の <xref:System.Windows.CoerceValueCallback> のメソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-223">Define a method for the <xref:System.Windows.CoerceValueCallback> named `CoerceValue`.</span></span> <span data-ttu-id="be9ab-224">`CoerceValue` によって、`Value` は `MinValue` 以上で `MaxValue` 以下になります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-224">`CoerceValue` ensures that `Value` is greater or equal to `MinValue` and less than or equal to `MaxValue`.</span></span>

- <span data-ttu-id="be9ab-225">`OnValueChanged`という名前の <xref:System.Windows.PropertyChangedCallback>のメソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-225">Define a method for the <xref:System.Windows.PropertyChangedCallback>, named `OnValueChanged`.</span></span> <span data-ttu-id="be9ab-226">`OnValueChanged` は <xref:System.Windows.RoutedPropertyChangedEventArgs%601> オブジェクトを作成し、`ValueChanged` ルーティングイベントの発生を準備します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-226">`OnValueChanged` creates a <xref:System.Windows.RoutedPropertyChangedEventArgs%601> object and prepares to raise the `ValueChanged` routed event.</span></span> <span data-ttu-id="be9ab-227">ルーティング イベントについては、次のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-227">Routed events are discussed in the next section.</span></span>

[!code-csharp[UserControlNumericUpDown#DependencyProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#dependencyproperty)]
[!code-vb[UserControlNumericUpDown#DependencyProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#dependencyproperty)]

<span data-ttu-id="be9ab-228">詳細については、「[カスタム依存関係プロパティ](../advanced/custom-dependency-properties.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="be9ab-228">For more information, see [Custom Dependency Properties](../advanced/custom-dependency-properties.md).</span></span>

### <a name="use-routed-events"></a><span data-ttu-id="be9ab-229">ルーティング イベントの使用</span><span class="sxs-lookup"><span data-stu-id="be9ab-229">Use Routed Events</span></span>

<span data-ttu-id="be9ab-230">依存関係プロパティが CLR プロパティの概念を拡張し、機能が追加されるのと同様に、ルーティングイベントは標準の CLR イベントの概念を拡張します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-230">Just as dependency properties extend the notion of CLR properties with additional functionality, routed events extend the notion of standard CLR events.</span></span> <span data-ttu-id="be9ab-231">新しい [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] コントロール作成する場合、イベントをルーティング イベントとして実装することをお勧めします。ルーティング イベントは以下の機能をサポートしているためです。</span><span class="sxs-lookup"><span data-stu-id="be9ab-231">When you create a new [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control, it is also good practice to implement your event as a routed event because a routed event supports the following behavior:</span></span>

- <span data-ttu-id="be9ab-232">複数のコントロールの親でイベントを処理できます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-232">Events can be handled on a parent of multiple controls.</span></span> <span data-ttu-id="be9ab-233">イベントがバブル イベントの場合、要素ツリー内の単一の親はイベントをサブスクライブできます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-233">If an event is a bubbling event, a single parent in the element tree can subscribe to the event.</span></span> <span data-ttu-id="be9ab-234">これにより、アプリケーション開発者は、複数のコントロールのイベントに 1 つのハンドラーで対応できます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-234">Then application authors can use one handler to respond to the event of multiple controls.</span></span> <span data-ttu-id="be9ab-235">たとえば、コントロールが <xref:System.Windows.Controls.ListBox> 内の各項目の一部である場合 (<xref:System.Windows.DataTemplate>に含まれているため)、アプリケーション開発者は <xref:System.Windows.Controls.ListBox>に対するコントロールのイベントのイベントハンドラーを定義できます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-235">For example, if your control is a part of each item in a <xref:System.Windows.Controls.ListBox> (because it is included in a <xref:System.Windows.DataTemplate>), the application developer can define the event handler for your control's event on the <xref:System.Windows.Controls.ListBox>.</span></span> <span data-ttu-id="be9ab-236">いずれかのコントロールでイベントが発生するたびに、そのイベント ハンドラーが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-236">Whenever the event occurs on any of the controls, the event handler is called.</span></span>

- <span data-ttu-id="be9ab-237">ルーティングイベントは、<xref:System.Windows.EventSetter>で使用できます。これにより、アプリケーション開発者は、スタイル内でイベントのハンドラーを指定できます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-237">Routed events can be used in an <xref:System.Windows.EventSetter>, which enables application developers to specify the handler of an event within a style.</span></span>

- <span data-ttu-id="be9ab-238">ルーティングイベントは、<xref:System.Windows.EventTrigger>で使用できます。これは、[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]を使用してプロパティをアニメーション化する場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="be9ab-238">Routed events can be used in an <xref:System.Windows.EventTrigger>, which is useful for animating properties by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="be9ab-239">詳しくは、「 [アニメーションの概要](../graphics-multimedia/animation-overview.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="be9ab-239">For more information, see [Animation Overview](../graphics-multimedia/animation-overview.md).</span></span>

<span data-ttu-id="be9ab-240">次に示す例では、以下の処理を実行して、ルーティング イベントを定義します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-240">The following example defines a routed event by doing the following:</span></span>

- <span data-ttu-id="be9ab-241">`ValueChangedEvent` という名前の <xref:System.Windows.RoutedEvent> 識別子を `readonly` フィールド `static` `public` として定義します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-241">Define a <xref:System.Windows.RoutedEvent> identifier named `ValueChangedEvent` as a `public` `static` `readonly` field.</span></span>

- <span data-ttu-id="be9ab-242"><xref:System.Windows.EventManager.RegisterRoutedEvent%2A?displayProperty=nameWithType> メソッドを呼び出して、ルーティングイベントを登録します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-242">Register the routed event by calling the <xref:System.Windows.EventManager.RegisterRoutedEvent%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="be9ab-243">この例では、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>を呼び出すときに、次の情報を指定します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-243">The example specifies the following information when it calls <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>:</span></span>

  - <span data-ttu-id="be9ab-244">イベントの名前が `ValueChanged` であること。</span><span class="sxs-lookup"><span data-stu-id="be9ab-244">The name of the event is `ValueChanged`.</span></span>

  - <span data-ttu-id="be9ab-245">ルーティング方法は <xref:System.Windows.RoutingStrategy.Bubble>です。つまり、ソース (イベントを発生させたオブジェクト) のイベントハンドラーが最初に呼び出され、次に、ソースの親要素のイベントハンドラーが連続して呼び出されます。その後、最も近い親要素。</span><span class="sxs-lookup"><span data-stu-id="be9ab-245">The routing strategy is <xref:System.Windows.RoutingStrategy.Bubble>, which means that an event handler on the source (the object that raises the event) is called first, and then event handlers on the source's parent elements are called in succession, starting with the event handler on the closest parent element.</span></span>

  - <span data-ttu-id="be9ab-246">イベントハンドラーの種類は、<xref:System.Decimal> の種類を使用して構築された <xref:System.Windows.RoutedPropertyChangedEventHandler%601>です。</span><span class="sxs-lookup"><span data-stu-id="be9ab-246">The type of the event handler is <xref:System.Windows.RoutedPropertyChangedEventHandler%601>, constructed with a <xref:System.Decimal> type.</span></span>

  - <span data-ttu-id="be9ab-247">イベントを所有する型が `NumericUpDown` であること。</span><span class="sxs-lookup"><span data-stu-id="be9ab-247">The owning type of the event is `NumericUpDown`.</span></span>

- <span data-ttu-id="be9ab-248">`ValueChanged` という名前のパブリック イベントを宣言し、イベント アクセサー宣言を含めます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-248">Declare a public event named `ValueChanged` and includes event-accessor declarations.</span></span> <span data-ttu-id="be9ab-249">この例では、`add` アクセサー宣言で <xref:System.Windows.UIElement.AddHandler%2A> を呼び出し、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] イベントサービスを使用するために `remove` アクセサー宣言で <xref:System.Windows.UIElement.RemoveHandler%2A> します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-249">The example calls <xref:System.Windows.UIElement.AddHandler%2A> in the `add` accessor declaration and <xref:System.Windows.UIElement.RemoveHandler%2A> in the `remove` accessor declaration to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event services.</span></span>

- <span data-ttu-id="be9ab-250">`ValueChanged`イベントを発生させる、保護された仮想メソッド `OnValueChanged` を作成します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-250">Create a protected, virtual method named `OnValueChanged` that raises the `ValueChanged` event.</span></span>

[!code-csharp[UserControlNumericUpDown#RoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#routedevent)]
[!code-vb[UserControlNumericUpDown#RoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#routedevent)]

<span data-ttu-id="be9ab-251">詳細については、「[ルーティング イベントの概要](../advanced/routed-events-overview.md)」および「[カスタム ルーティング イベントを作成する](../advanced/how-to-create-a-custom-routed-event.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="be9ab-251">For more information, see [Routed Events Overview](../advanced/routed-events-overview.md) and [Create a Custom Routed Event](../advanced/how-to-create-a-custom-routed-event.md).</span></span>

### <a name="use-binding"></a><span data-ttu-id="be9ab-252">バインディングの使用</span><span class="sxs-lookup"><span data-stu-id="be9ab-252">Use Binding</span></span>

<span data-ttu-id="be9ab-253">コントロールの UI とロジックを分離するには、データ バインディングを使用する方法もあります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-253">To decouple the UI of your control from its logic, consider using data binding.</span></span> <span data-ttu-id="be9ab-254">これは、<xref:System.Windows.Controls.ControlTemplate>を使用してコントロールの外観を定義する場合に特に重要です。</span><span class="sxs-lookup"><span data-stu-id="be9ab-254">This is particularly important if you define the appearance of your control by using a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="be9ab-255">データ バインディングを使用すると、コードから UI の特定の部分を参照する必要性がなくなる場合があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-255">When you use data binding, you might be able to eliminate the need to reference specific parts of the UI from the code.</span></span> <span data-ttu-id="be9ab-256"><xref:System.Windows.Controls.ControlTemplate> 内の要素を参照しないようにすることをお勧めします。コードが <xref:System.Windows.Controls.ControlTemplate> 内の要素を参照し、<xref:System.Windows.Controls.ControlTemplate> が変更された場合、参照される要素を新しい <xref:System.Windows.Controls.ControlTemplate>に含める必要があるためです。</span><span class="sxs-lookup"><span data-stu-id="be9ab-256">It's a good idea to avoid referencing elements that are in the <xref:System.Windows.Controls.ControlTemplate> because when the code references elements that are in the <xref:System.Windows.Controls.ControlTemplate> and the <xref:System.Windows.Controls.ControlTemplate> is changed, the referenced element needs to be included in the new <xref:System.Windows.Controls.ControlTemplate>.</span></span>

<span data-ttu-id="be9ab-257">次の例では、`NumericUpDown` コントロールの <xref:System.Windows.Controls.TextBlock> を更新し、それに名前を割り当て、コードでテキストボックスを名前で参照しています。</span><span class="sxs-lookup"><span data-stu-id="be9ab-257">The following example updates the <xref:System.Windows.Controls.TextBlock> of the `NumericUpDown` control, assigning a name to it and referencing the textbox by name in code.</span></span>

[!code-xaml[UserControlNumericUpDownSimple#UIRefMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml#uirefmarkup)]

[!code-csharp[UserControlNumericUpDownSimple#UIRefCode](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml.cs#uirefcode)]
[!code-vb[UserControlNumericUpDownSimple#UIRefCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDownSimple/VisualBasic/NumericUpDown.xaml.vb#uirefcode)]

<span data-ttu-id="be9ab-258">次の例では、バインディングを使用して同じことを実現しています。</span><span class="sxs-lookup"><span data-stu-id="be9ab-258">The following example uses binding to accomplish the same thing.</span></span>

[!code-xaml[UserControlNumericUpDown#Binding](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml#binding)]

<span data-ttu-id="be9ab-259">データ バインディングの詳細については、「[データ バインディングの概要](../data/data-binding-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="be9ab-259">For more information about data binding, see [Data Binding Overview](../data/data-binding-overview.md).</span></span>

### <a name="design-for-designers"></a><span data-ttu-id="be9ab-260">デザイナーに対応したデザイン</span><span class="sxs-lookup"><span data-stu-id="be9ab-260">Design for Designers</span></span>

<span data-ttu-id="be9ab-261">[!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)] でカスタム WPF コントロールのサポート (たとえば、[プロパティ] ウィンドウでのプロパティ編集) を利用するには、以下のガイドラインに従います。</span><span class="sxs-lookup"><span data-stu-id="be9ab-261">To receive support for custom WPF controls in the [!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)] (for example, property editing with the Properties window), follow these guidelines.</span></span>  <span data-ttu-id="be9ab-262">[!INCLUDE[wpfdesigner_current_short](../../../../includes/wpfdesigner-current-short-md.md)]の開発の詳細については、「 [Visual Studio での XAML のデザイン](/visualstudio/xaml-tools/designing-xaml-in-visual-studio)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="be9ab-262">For more information on developing for the [!INCLUDE[wpfdesigner_current_short](../../../../includes/wpfdesigner-current-short-md.md)], see [Design XAML in Visual Studio](/visualstudio/xaml-tools/designing-xaml-in-visual-studio).</span></span>

#### <a name="dependency-properties"></a><span data-ttu-id="be9ab-263">依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="be9ab-263">Dependency Properties</span></span>

<span data-ttu-id="be9ab-264">「依存関係プロパティの使用」で前述したように、CLR `get` と `set` アクセサーを実装してください。</span><span class="sxs-lookup"><span data-stu-id="be9ab-264">Be sure to implement CLR `get` and `set` accessors as described earlier, in "Use Dependency Properties."</span></span> <span data-ttu-id="be9ab-265">デザイナーは、ラッパーを使用して依存関係プロパティの存在を検出する場合がありますが、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] およびコントロールのクライアントと同様、プロパティを取得または設定するときにアクセサーを呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="be9ab-265">Designers may use the wrapper to detect the presence of a dependency property, but they, like [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and clients of the control, are not required to call the accessors when getting or setting the property.</span></span>

#### <a name="attached-properties"></a><span data-ttu-id="be9ab-266">アタッチされるプロパティ</span><span class="sxs-lookup"><span data-stu-id="be9ab-266">Attached Properties</span></span>

<span data-ttu-id="be9ab-267">以下のガイドラインに従って、カスタム コントロールに添付プロパティを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-267">You should implement attached properties on custom controls using the following guidelines:</span></span>

- <span data-ttu-id="be9ab-268">`Property` メソッドを使用して作成された*PropertyName* <xref:System.Windows.DependencyProperty.RegisterAttached%2A> フォームの <xref:System.Windows.DependencyProperty> `readonly` `public` `static` を持っている。</span><span class="sxs-lookup"><span data-stu-id="be9ab-268">Have a `public` `static` `readonly` <xref:System.Windows.DependencyProperty> of the form *PropertyName*`Property` that was creating using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="be9ab-269"><xref:System.Windows.DependencyProperty.RegisterAttached%2A> に渡されるプロパティ名は*PropertyName*と一致している必要があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-269">The property name that is passed to <xref:System.Windows.DependencyProperty.RegisterAttached%2A> must match *PropertyName*.</span></span>

- <span data-ttu-id="be9ab-270">`Set` *PropertyName* および `Get` *PropertyName* という名前の `public``static` CLR メソッドのペアを実装します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-270">Implement a pair of `public` `static` CLR methods named `Set`*PropertyName* and `Get`*PropertyName*.</span></span> <span data-ttu-id="be9ab-271">どちらのメソッドも、最初の引数として <xref:System.Windows.DependencyProperty> から派生したクラスを受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-271">Both methods should accept a class derived from <xref:System.Windows.DependencyProperty> as their first argument.</span></span> <span data-ttu-id="be9ab-272">また、`Set` *PropertyName* メソッドでは、プロパティの登録データ型と同じ型の引数も受け取ります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-272">The `Set`*PropertyName* method also accepts an argument whose type matches the registered data type for the property.</span></span> <span data-ttu-id="be9ab-273">`Get` *PropertyName*メソッドでは、同じ型の値を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-273">The `Get`*PropertyName* method should return a value of the same type.</span></span> <span data-ttu-id="be9ab-274">`Set` *PropertyName*メソッドがない場合、プロパティは読み取り専用としてマークされます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-274">If the `Set`*PropertyName* method is missing, the property is marked read-only.</span></span>

- <span data-ttu-id="be9ab-275">`Set` *propertyname*および `Get`*propertyname*は、ターゲットの依存関係オブジェクトの <xref:System.Windows.DependencyObject.GetValue%2A> および <xref:System.Windows.DependencyObject.SetValue%2A> メソッドにそれぞれ直接ルーティングする必要があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-275">`Set` *PropertyName* and `Get`*PropertyName* must route directly to the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> methods on the target dependency object, respectively.</span></span> <span data-ttu-id="be9ab-276">デザイナーが添付プロパティにアクセスするには、メソッド ラッパー経由で呼び出す場合もあれば、対象の依存関係オブジェクトを直接呼び出す場合もあります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-276">Designers may access the attached property by calling through the method wrapper or making a direct call to the target dependency object.</span></span>

<span data-ttu-id="be9ab-277">添付プロパティの詳細については、「[添付プロパティの概要](../advanced/attached-properties-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="be9ab-277">For more information on attached properties, see [Attached Properties Overview](../advanced/attached-properties-overview.md).</span></span>

### <a name="define-and-use-shared-resources"></a><span data-ttu-id="be9ab-278">共有リソースの定義と使用</span><span class="sxs-lookup"><span data-stu-id="be9ab-278">Define and Use Shared Resources</span></span>

<span data-ttu-id="be9ab-279">アプリケーションと同じアセンブリにコントロールを含めることも、複数のアプリケーションが使用できる別のアセンブリにコントロールをパッケージ化することもできます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-279">You can include your control in the same assembly as your application, or you can package your control in a separate assembly that can be used in multiple applications.</span></span> <span data-ttu-id="be9ab-280">このトピックで説明した情報の大部分は、使用する方法に関係なく適用されます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-280">For the most part, the information discussed in this topic applies regardless of the method you use.</span></span>  <span data-ttu-id="be9ab-281">ただし、1 つだけ例外があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-281">There is one difference worth noting, however.</span></span>  <span data-ttu-id="be9ab-282">アプリケーションと同じアセンブリ内にコントロールを配置する場合、App.xaml ファイルにグローバル リソースを自由に追加できます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-282">When you put a control in the same assembly as an application, you are free to add global resources to the App.xaml file.</span></span> <span data-ttu-id="be9ab-283">ただし、コントロールのみを含むアセンブリには <xref:System.Windows.Application> オブジェクトが関連付けられていないため、app.xaml ファイルは使用できません。</span><span class="sxs-lookup"><span data-stu-id="be9ab-283">But an assembly that contains only controls does not have an <xref:System.Windows.Application> object associated with it, so an App.xaml file is not available.</span></span>

<span data-ttu-id="be9ab-284">アプリケーションがリソースを検索するときは、次に示す順序で 3 つのレベルを検索します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-284">When an application looks for a resource, it looks at three levels in the following order:</span></span>

1. <span data-ttu-id="be9ab-285">要素レベル。</span><span class="sxs-lookup"><span data-stu-id="be9ab-285">The element level.</span></span>

   <span data-ttu-id="be9ab-286">システムは、リソースを参照する要素から検索を開始し、ルート要素に到達するまで、論理上の親のリソースの検索を継続します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-286">The system starts with the element that references the resource and then searches resources of the logical parent and so forth until the root element is reached.</span></span>

2. <span data-ttu-id="be9ab-287">アプリケーション レベル。</span><span class="sxs-lookup"><span data-stu-id="be9ab-287">The application level.</span></span>

   <span data-ttu-id="be9ab-288"><xref:System.Windows.Application> オブジェクトによって定義されたリソース。</span><span class="sxs-lookup"><span data-stu-id="be9ab-288">Resources defined by the <xref:System.Windows.Application> object.</span></span>

3. <span data-ttu-id="be9ab-289">テーマ レベル。</span><span class="sxs-lookup"><span data-stu-id="be9ab-289">The theme level.</span></span>

   <span data-ttu-id="be9ab-290">テーマ レベルのディクショナリは、Themes という名前のサブフォルダーに格納されています。</span><span class="sxs-lookup"><span data-stu-id="be9ab-290">Theme-level dictionaries are stored in a subfolder named Themes.</span></span>  <span data-ttu-id="be9ab-291">Themes フォルダー内のファイルはテーマに対応しています。</span><span class="sxs-lookup"><span data-stu-id="be9ab-291">The files in the Themes folder correspond to themes.</span></span>  <span data-ttu-id="be9ab-292">たとえば、Aero.NormalColor.xaml、Luna.NormalColor.xaml、Royale.NormalColor.xaml などのファイルがあります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-292">For example, you might have Aero.NormalColor.xaml, Luna.NormalColor.xaml, Royale.NormalColor.xaml, and so on.</span></span>  <span data-ttu-id="be9ab-293">generic.xaml という名前のファイルが含まれている場合もあります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-293">You can also have a file named generic.xaml.</span></span>  <span data-ttu-id="be9ab-294">システムがテーマ レベルでリソースを検索するとき、最初にテーマ固有のファイル内を検索し、次に generic.xaml 内を検索します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-294">When the system looks for a resource at the themes level, it first looks for it in the theme-specific file and then looks for it in generic.xaml.</span></span>

<span data-ttu-id="be9ab-295">アプリケーションとは別のアセンブリ内にコントロールを含めるときは、グローバル リソースを要素レベルまたはテーマ レベルに配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-295">When your control is in an assembly that is separate from the application, you must put your global resources at the element level or at the theme level.</span></span> <span data-ttu-id="be9ab-296">どちらに配置する場合も、それぞれの利点があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-296">Both methods have their advantages.</span></span>

#### <a name="defining-resources-at-the-element-level"></a><span data-ttu-id="be9ab-297">要素レベルでのリソース定義</span><span class="sxs-lookup"><span data-stu-id="be9ab-297">Defining Resources at the Element Level</span></span>

<span data-ttu-id="be9ab-298">カスタムのリソース ディクショナリを作成し、それをコントロールのリソース ディクショナリと結合することによって、共有リソースを要素レベルで定義できます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-298">You can define shared resources at the element level by creating a custom resource dictionary and merging it with your control’s resource dictionary.</span></span>  <span data-ttu-id="be9ab-299">このメソッドで定義する場合は、リソース ファイルに任意の名前を付けて、コントロールと同じフォルダーに配置できます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-299">When you use this method, you can name your resource file anything you want, and it can be in the same folder as your controls.</span></span> <span data-ttu-id="be9ab-300">要素レベルでのリソースでは、単純な文字列をキーとして使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-300">Resources at the element level can also use simple strings as keys.</span></span> <span data-ttu-id="be9ab-301">次の例では、Dictionary1 という名前の <xref:System.Windows.Media.LinearGradientBrush> リソースファイルを作成します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-301">The following example creates a <xref:System.Windows.Media.LinearGradientBrush> resource file named Dictionary1.xaml.</span></span>

[!code-xaml[SharedResources#1](~/samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/Dictionary1.xaml#1)]

<span data-ttu-id="be9ab-302">ディクショナリを定義したら、それをコントロールのリソース ディクショナリにマージする必要があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-302">Once you have defined your dictionary, you need to merge it with your control's resource dictionary.</span></span>  <span data-ttu-id="be9ab-303">これには、[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] またはコードを使用します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-303">You can do this by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or code.</span></span>

<span data-ttu-id="be9ab-304">次の例では、[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] を使用してリソース ディクショナリを結合します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-304">The following example merges a resource dictionary by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span>

[!code-xaml[SharedResources#2](~/samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml#2)]

<span data-ttu-id="be9ab-305">この方法の欠点は、参照するたびに <xref:System.Windows.ResourceDictionary> オブジェクトが作成されることです。</span><span class="sxs-lookup"><span data-stu-id="be9ab-305">The disadvantage to this approach is that a <xref:System.Windows.ResourceDictionary> object is created each time you reference it.</span></span>  <span data-ttu-id="be9ab-306">たとえば、ライブラリに10個のカスタムコントロールがあり、XAML を使用して各コントロールの共有リソースディクショナリをマージする場合は、10個の同一 <xref:System.Windows.ResourceDictionary> オブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-306">For example, if you have 10 custom controls in your library and merge the shared resource dictionaries for each control by using XAML, you create 10 identical <xref:System.Windows.ResourceDictionary> objects.</span></span>  <span data-ttu-id="be9ab-307">これを回避するには、コード内のリソースをマージし、結果の <xref:System.Windows.ResourceDictionary>を返す静的クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-307">You can avoid this by creating a static class that merges the resources in code and returns the resulting <xref:System.Windows.ResourceDictionary>.</span></span>

<span data-ttu-id="be9ab-308">次の例では、共有 <xref:System.Windows.ResourceDictionary>を返すクラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-308">The following example creates a class that returns a shared <xref:System.Windows.ResourceDictionary>.</span></span>

[!code-csharp[SharedResources#3](~/samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/SharedDictionaryManager.cs#3)]

<span data-ttu-id="be9ab-309">次の例では、`InitializeComponent` を呼び出す前に、共有リソースをコントロールのコンス トラクター内でカスタム コントロールのリソースと結合します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-309">The following example merges the shared resource with the resources of a custom control in the control's constructor before it calls `InitializeComponent`.</span></span>  <span data-ttu-id="be9ab-310">`SharedDictionaryManager.SharedDictionary` は静的プロパティであるため、<xref:System.Windows.ResourceDictionary> は1回だけ作成されます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-310">Because the `SharedDictionaryManager.SharedDictionary` is a static property, the <xref:System.Windows.ResourceDictionary> is created only once.</span></span> <span data-ttu-id="be9ab-311">`InitializeComponent` が呼び出される前に、リソース ディクショナリが結合されため、コントロールは [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] ファイル内でリソースを使用できます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-311">Because the resource dictionary was merged before `InitializeComponent` was called, the resources are available to the control in its [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] file.</span></span>

[!code-csharp[SharedResources#4](~/samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml.cs#4)]

#### <a name="defining-resources-at-the-theme-level"></a><span data-ttu-id="be9ab-312">テーマ レベルでのリソース定義</span><span class="sxs-lookup"><span data-stu-id="be9ab-312">Defining Resources at the Theme Level</span></span>

[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="be9ab-313">では、さまざまな Windows テーマ用にリソースを作成できます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-313">enables you to create resources for different Windows themes.</span></span>  <span data-ttu-id="be9ab-314">コントロールの作成者は、特定のテーマ用のリソースを定義して、使用するテーマに応じてコントロールの外観を変更できます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-314">As a control author, you can define a resource for a specific theme to change your control's appearance depending on what theme is in use.</span></span> <span data-ttu-id="be9ab-315">たとえば、windows クラシックテーマでの <xref:System.Windows.Controls.Button> の外観 (Windows 2000 の既定のテーマ) は、Windows Luna テーマの <xref:System.Windows.Controls.Button> (windows XP の既定のテーマ) とは異なります。これは、<xref:System.Windows.Controls.Button> がテーマごとに異なる <xref:System.Windows.Controls.ControlTemplate> を使用するためです。</span><span class="sxs-lookup"><span data-stu-id="be9ab-315">For example, the appearance of a <xref:System.Windows.Controls.Button> in the Windows Classic theme (the default theme for Windows 2000) differs from a <xref:System.Windows.Controls.Button> in the Windows Luna theme (the default theme for Windows XP) because the <xref:System.Windows.Controls.Button> uses a different <xref:System.Windows.Controls.ControlTemplate> for each theme.</span></span>

<span data-ttu-id="be9ab-316">テーマ固有のリソースは、固有のファイル名でリソース ディクショナリに保持されます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-316">Resources that are specific to a theme are kept in a resource dictionary with a specific file name.</span></span> <span data-ttu-id="be9ab-317">これらのファイルは、コントロールが格納されているフォルダーのサブフォルダーである `Themes` フォルダー内に配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-317">These files must be in a folder named `Themes` that is a subfolder of the folder that contains the control.</span></span> <span data-ttu-id="be9ab-318">次の表は、リソース ディクショナリ ファイルと、各ファイルに関連付けられているテーマを示しています。</span><span class="sxs-lookup"><span data-stu-id="be9ab-318">The following table lists the resource dictionary files and the theme that is associated with each file:</span></span>

|<span data-ttu-id="be9ab-319">リソース ディクショナリ ファイル名</span><span class="sxs-lookup"><span data-stu-id="be9ab-319">Resource dictionary file name</span></span>|<span data-ttu-id="be9ab-320">Windows テーマ</span><span class="sxs-lookup"><span data-stu-id="be9ab-320">Windows theme</span></span>|
|-----------------------------------|-------------------|
|`Classic.xaml`|<span data-ttu-id="be9ab-321">Windows XP のクラシックな Windows 9x/2000 の外観</span><span class="sxs-lookup"><span data-stu-id="be9ab-321">Classic Windows 9x/2000 look on Windows XP</span></span>|
|`Luna.NormalColor.xaml`|<span data-ttu-id="be9ab-322">Windows XP の既定の青のテーマ</span><span class="sxs-lookup"><span data-stu-id="be9ab-322">Default blue theme on Windows XP</span></span>|
|`Luna.Homestead.xaml`|<span data-ttu-id="be9ab-323">Windows XP のオリーブのテーマ</span><span class="sxs-lookup"><span data-stu-id="be9ab-323">Olive theme on Windows XP</span></span>|
|`Luna.Metallic.xaml`|<span data-ttu-id="be9ab-324">Windows XP のシルバーのテーマ</span><span class="sxs-lookup"><span data-stu-id="be9ab-324">Silver theme on Windows XP</span></span>|
|`Royale.NormalColor.xaml`|<span data-ttu-id="be9ab-325">Windows XP Media Center Edition の既定テーマ</span><span class="sxs-lookup"><span data-stu-id="be9ab-325">Default theme on Windows XP Media Center Edition</span></span>|
|`Aero.NormalColor.xaml`|<span data-ttu-id="be9ab-326">Windows Vista の既定テーマ</span><span class="sxs-lookup"><span data-stu-id="be9ab-326">Default theme on Windows Vista</span></span>|

<span data-ttu-id="be9ab-327">すべてのテーマのリソースを定義する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="be9ab-327">You do not need to define a resource for every theme.</span></span> <span data-ttu-id="be9ab-328">特定のテーマについてリソースが定義されていない場合、コントロールはリソースの `Classic.xaml` を確認します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-328">If a resource is not defined for a specific theme, then the control checks `Classic.xaml` for the resource.</span></span> <span data-ttu-id="be9ab-329">現在のテーマに対応するファイルや `Classic.xaml` でリソースが定義されていない場合、コントロールは汎用のリソースを使用します。汎用のリソースは、`generic.xaml` という名前のリソース ディクショナリ ファイルにあります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-329">If the resource is not defined in the file that corresponds to the current theme or in `Classic.xaml`, the control uses the generic resource, which is in a resource dictionary file named `generic.xaml`.</span></span>  <span data-ttu-id="be9ab-330">`generic.xaml` ファイルは、テーマ固有のリソース ディクショナリ ファイルと同じフォルダーに配置されています。</span><span class="sxs-lookup"><span data-stu-id="be9ab-330">The `generic.xaml` file is located in the same folder as the theme-specific resource dictionary files.</span></span> <span data-ttu-id="be9ab-331">`generic.xaml` は、特定の Windows テーマには対応していませんが、テーマ レベルのディクショナリであることに変わりありません。</span><span class="sxs-lookup"><span data-stu-id="be9ab-331">Although `generic.xaml` does not correspond to a specific Windows theme, it is still a theme-level dictionary.</span></span>

<span data-ttu-id="be9ab-332">[C#](https://github.com/dotnet/samples/tree/master/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp)または[Visual Basic](https://github.com/dotnet/samples/tree/master/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic) NumericUpDown カスタムコントロールとテーマおよび UI オートメーションサポートのサンプルには、`NumericUpDown` コントロール用の2つのリソースディクショナリが含まれています。1つは汎用 .xaml で、もう1つは Luna にあります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-332">The [C#](https://github.com/dotnet/samples/tree/master/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp) or [Visual Basic](https://github.com/dotnet/samples/tree/master/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic) NumericUpDown custom control with theme and UI automation support sample contains two resource dictionaries for the `NumericUpDown` control: one is in generic.xaml, and the other is in Luna.NormalColor.xaml.</span></span> 

<span data-ttu-id="be9ab-333">テーマ固有のリソースディクショナリファイルに <xref:System.Windows.Controls.ControlTemplate> を配置する場合は、次の例に示すように、コントロールの静的コンストラクターを作成し、<xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>で <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-333">When you put a <xref:System.Windows.Controls.ControlTemplate> in any of the theme-specific resource dictionary files, you must create a static constructor for your control and call the <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29> method on the <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>, as shown in the following example.</span></span>

[!code-csharp[CustomControlNumericUpDownOneProject#StaticConstructor](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/CSharp/NumericUpDown.cs#staticconstructor)]
[!code-vb[CustomControlNumericUpDownOneProject#StaticConstructor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/visualbasic/numericupdown.vb#staticconstructor)]

##### <a name="defining-and-referencing-keys-for-theme-resources"></a><span data-ttu-id="be9ab-334">テーマ リソース用のキーの定義と参照</span><span class="sxs-lookup"><span data-stu-id="be9ab-334">Defining and Referencing Keys for Theme Resources</span></span>

<span data-ttu-id="be9ab-335">要素レベルでリソースを定義するときに、文字列をキーとして割り当て、その文字列を使用してリソースにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="be9ab-335">When you define a resource at the element level, you can assign a string as its key and access the resource via the string.</span></span> <span data-ttu-id="be9ab-336">テーマレベルでリソースを定義する場合は、キーとして <xref:System.Windows.ComponentResourceKey> を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-336">When you define a resource at the theme level, you must use a <xref:System.Windows.ComponentResourceKey> as the key.</span></span>  <span data-ttu-id="be9ab-337">次の例では、generic.xaml でリソースを定義します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-337">The following example defines a resource in generic.xaml.</span></span>

[!code-xaml[ThemeResourcesControlLibrary#5](~/samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/Themes/generic.xaml#5)]

<span data-ttu-id="be9ab-338">次の例では、キーとして <xref:System.Windows.ComponentResourceKey> を指定することによって、リソースを参照しています。</span><span class="sxs-lookup"><span data-stu-id="be9ab-338">The following example references the resource by specifying the <xref:System.Windows.ComponentResourceKey> as the key.</span></span>

[!code-xaml[ThemeResourcesControlLibrary#6](~/samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/NumericUpDown.xaml#6)]

##### <a name="specifying-the-location-of-theme-resources"></a><span data-ttu-id="be9ab-339">テーマ リソースの場所の指定</span><span class="sxs-lookup"><span data-stu-id="be9ab-339">Specifying the Location of Theme Resources</span></span>

<span data-ttu-id="be9ab-340">コントロールのリソースを見つけるには、アセンブリにコントロール固有のリソースが含まれていることを、ホスト アプリケーションが認識する必要があります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-340">To find the resources for a control, the hosting application needs to know that the assembly contains control-specific resources.</span></span> <span data-ttu-id="be9ab-341">これを行うには、コントロールを含むアセンブリに <xref:System.Windows.ThemeInfoAttribute> を追加します。</span><span class="sxs-lookup"><span data-stu-id="be9ab-341">You can accomplish that by adding the <xref:System.Windows.ThemeInfoAttribute> to the assembly that contains the control.</span></span> <span data-ttu-id="be9ab-342"><xref:System.Windows.ThemeInfoAttribute> には、汎用リソースの場所を指定する <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> プロパティと、テーマ固有のリソースの場所を指定する <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> プロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="be9ab-342">The <xref:System.Windows.ThemeInfoAttribute> has a <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> property that specifies the location of generic resources, and a <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> property that specifies the location of the theme-specific resources.</span></span>

<span data-ttu-id="be9ab-343">次の例では、<xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> プロパティと <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> プロパティを <xref:System.Windows.ResourceDictionaryLocation.SourceAssembly>に設定して、汎用およびテーマ固有のリソースがコントロールと同じアセンブリ内にあることを指定しています。</span><span class="sxs-lookup"><span data-stu-id="be9ab-343">The following example sets the <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> and <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> properties to <xref:System.Windows.ResourceDictionaryLocation.SourceAssembly>, to specify that the generic and theme-specific resources are in the same assembly as the control.</span></span>

[!code-csharp[CustomControlNumericUpDown#ThemesSection](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/Properties/AssemblyInfo.cs#themessection)]
[!code-vb[CustomControlNumericUpDown#ThemesSection](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/my project/assemblyinfo.vb#themessection)]

## <a name="see-also"></a><span data-ttu-id="be9ab-344">関連項目</span><span class="sxs-lookup"><span data-stu-id="be9ab-344">See also</span></span>

- [<span data-ttu-id="be9ab-345">Visual Studio で XAML をデザインする</span><span class="sxs-lookup"><span data-stu-id="be9ab-345">Design XAML in Visual Studio</span></span>](/visualstudio/xaml-tools/designing-xaml-in-visual-studio)
- [<span data-ttu-id="be9ab-346">WPF におけるパッケージの URI</span><span class="sxs-lookup"><span data-stu-id="be9ab-346">Pack URIs in WPF</span></span>](../app-development/pack-uris-in-wpf.md)
- [<span data-ttu-id="be9ab-347">コントロールのカスタマイズ</span><span class="sxs-lookup"><span data-stu-id="be9ab-347">Control Customization</span></span>](control-customization.md)
