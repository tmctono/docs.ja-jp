---
title: コントロールの作成の概要
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- controls [WPF], authoring overview
- authoring overview for controls [WPF]
ms.assetid: 3d864748-cff0-4e63-9b23-d8e5a635b28f
ms.openlocfilehash: 2326520039085beb5f5294e23db67b67f9d7d7da
ms.sourcegitcommit: 7980a91f90ae5eca859db7e6bfa03e23e76a1a50
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/13/2020
ms.locfileid: "81243272"
---
# <a name="control-authoring-overview"></a><span data-ttu-id="4d93f-102">コントロール作成の概要</span><span class="sxs-lookup"><span data-stu-id="4d93f-102">Control authoring overview</span></span>

<span data-ttu-id="4d93f-103">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] コントロール モデルの機能拡張により、新しいコントロールを作成する必要性が大幅に削減されます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-103">The extensibility of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] control model greatly reduces the need to create a new control.</span></span> <span data-ttu-id="4d93f-104">ただし、場合によっては、カスタム コントロールを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-104">However, in certain cases you may still need to create a custom control.</span></span> <span data-ttu-id="4d93f-105">このトピックでは、カスタム コントロールを作成する必要性を最小限に抑える機能と、[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] のさまざまなコントロール作成モデルについて説明します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-105">This topic discusses the features that minimize your need to create a custom control and the different control authoring models in [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)].</span></span> <span data-ttu-id="4d93f-106">また、新しいコントロールを作成する方法も示します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-106">This topic also demonstrates how to create a new control.</span></span>

<a name="when_to_write_a_new_control"></a>

## <a name="alternatives-to-writing-a-new-control"></a><span data-ttu-id="4d93f-107">新しいコントロールの作成に代わる方法</span><span class="sxs-lookup"><span data-stu-id="4d93f-107">Alternatives to Writing a New Control</span></span>

<span data-ttu-id="4d93f-108">従来は、既存のコントロールをカスタマイズする場合、背景色、境界線の幅、フォントのサイズなど、コントロールの標準プロパティを変更するなどの範囲に制限されていました。</span><span class="sxs-lookup"><span data-stu-id="4d93f-108">Historically, if you wanted to get a customized experience from an existing control, you were limited to changing the standard properties of the control, such as background color, border width, and font size.</span></span> <span data-ttu-id="4d93f-109">これらの定義済みのパラメーター以外に、コントロールの外観や動作にまでカスタマイズを拡張しようとすると、通常、既存のコントロールを継承し、コントロールを描画するメソッドをオーバーライドして、新しいコントロールを作成する必要がありました。</span><span class="sxs-lookup"><span data-stu-id="4d93f-109">If you wished to extend the appearance or behavior of a control beyond these predefined parameters, you would need to create a new control, usually by inheriting from an existing control and overriding the method responsible for drawing the control.</span></span>  <span data-ttu-id="4d93f-110">その方法は今でも選択できますが、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の場合、リッチ コンテンツ モデル、スタイル、テンプレート、トリガーを使用して、既存のコントロールをカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-110">Although that is still an option, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] enables to you customize existing controls by using its rich content model, styles, templates, and triggers.</span></span> <span data-ttu-id="4d93f-111">新しいコントロールを作成しなくても、これらの機能を使用して、カスタマイズされた一貫性のあるエクスペリエンスを得られる方法としては、次のような例が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-111">The following list gives examples of how these features can be used to create custom and consistent experiences without having to create a new control.</span></span>

- <span data-ttu-id="4d93f-112">**リッチ コンテンツ。**</span><span class="sxs-lookup"><span data-stu-id="4d93f-112">**Rich Content.**</span></span> <span data-ttu-id="4d93f-113">標準の [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] コントロールの多くがリッチ コンテンツをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="4d93f-113">Many of the standard [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls support rich content.</span></span> <span data-ttu-id="4d93f-114">たとえば、 の<xref:System.Windows.Controls.Button>content プロパティは 型<xref:System.Object>、 の場合、理論的には何でも<xref:System.Windows.Controls.Button>表示できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-114">For example, the content property of a <xref:System.Windows.Controls.Button> is of type <xref:System.Object>, so theoretically anything can be displayed on a <xref:System.Windows.Controls.Button>.</span></span>  <span data-ttu-id="4d93f-115">ボタンに<xref:System.Windows.Controls.TextBlock>イメージとテキストを表示するには、イメージと a を に<xref:System.Windows.Controls.StackPanel>追加して、<xref:System.Windows.Controls.StackPanel><xref:System.Windows.Controls.ContentControl.Content%2A>プロパティに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-115">To have a button display an image and text, you can add an image and a <xref:System.Windows.Controls.TextBlock> to a <xref:System.Windows.Controls.StackPanel> and assign the <xref:System.Windows.Controls.StackPanel> to the <xref:System.Windows.Controls.ContentControl.Content%2A> property.</span></span> <span data-ttu-id="4d93f-116">コントロールには、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の視覚的要素と任意のデータを表示できるため、複雑な視覚化をサポートするために、新しいコントロールを作成したり、既存のコントロールを変更したりする必要性が少なくなります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-116">Because the controls can display [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] visual elements and arbitrary data, there is less need to create a new control or to modify an existing control to support a complex visualization.</span></span> <span data-ttu-id="4d93f-117">のコンテンツ モデル<xref:System.Windows.Controls.Button>と他のコンテンツ モデルの[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]詳細については、「 [WPF コンテンツ モデル](wpf-content-model.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4d93f-117">For more information about the content model for <xref:System.Windows.Controls.Button> and other content models in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [WPF Content Model](wpf-content-model.md).</span></span>

- <span data-ttu-id="4d93f-118">**スタイル。**</span><span class="sxs-lookup"><span data-stu-id="4d93f-118">**Styles.**</span></span> <span data-ttu-id="4d93f-119">A<xref:System.Windows.Style>は、コントロールのプロパティを表す値のコレクションです。</span><span class="sxs-lookup"><span data-stu-id="4d93f-119">A <xref:System.Windows.Style> is a collection of values that represent properties for a control.</span></span> <span data-ttu-id="4d93f-120">スタイルを使用すると、新しいコントロールを作成しなくても、必要なコントロールの外観と動作を備えた再利用可能な表現を作成できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-120">By using styles, you can create a reusable representation of a desired control appearance and behavior without writing a new control.</span></span> <span data-ttu-id="4d93f-121">たとえば、すべての<xref:System.Windows.Controls.TextBlock>コントロールに赤、Arial フォント、フォント サイズ 14 を使用する必要があるとします。</span><span class="sxs-lookup"><span data-stu-id="4d93f-121">For example, assume that you want all of your <xref:System.Windows.Controls.TextBlock> controls to have red, Arial font with a font size of 14.</span></span> <span data-ttu-id="4d93f-122">そこで、リソースとしてスタイルを作成し、それに応じて、適切なプロパティを設定します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-122">You can create a style as a resource and set the appropriate properties accordingly.</span></span> <span data-ttu-id="4d93f-123">その後<xref:System.Windows.Controls.TextBlock>、アプリケーションに追加する場合は、すべての外観が同じになります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-123">Then every <xref:System.Windows.Controls.TextBlock> that you add to your application will have the same appearance.</span></span>

- <span data-ttu-id="4d93f-124">**データ テンプレート。**</span><span class="sxs-lookup"><span data-stu-id="4d93f-124">**Data Templates.**</span></span> <span data-ttu-id="4d93f-125">A<xref:System.Windows.DataTemplate>を使用すると、コントロール上でのデータの表示方法をカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-125">A <xref:System.Windows.DataTemplate> enables you to customize how data is displayed on a control.</span></span> <span data-ttu-id="4d93f-126">たとえば、 を<xref:System.Windows.DataTemplate>使用して、 でのデータの表示方法を<xref:System.Windows.Controls.ListBox>指定できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-126">For example, a <xref:System.Windows.DataTemplate> can be used to specify how data is displayed in a <xref:System.Windows.Controls.ListBox>.</span></span>  <span data-ttu-id="4d93f-127">この例については、「[データ テンプレートの概要](../data/data-templating-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4d93f-127">For an example of this, see [Data Templating Overview](../data/data-templating-overview.md).</span></span>  <span data-ttu-id="4d93f-128">データの外観をカスタマイズするだけでなく、UI 要素を<xref:System.Windows.DataTemplate>含めることができ、カスタム UI に多くの柔軟性を提供します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-128">In addition to customizing the appearance of data, a <xref:System.Windows.DataTemplate> can include UI elements, which gives you a lot of flexibility in custom UIs.</span></span>  <span data-ttu-id="4d93f-129">たとえば、 を<xref:System.Windows.DataTemplate>使用して、 各項目に<xref:System.Windows.Controls.ComboBox>チェック ボックスを含む を作成できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-129">For example, by using a <xref:System.Windows.DataTemplate>, you can create a <xref:System.Windows.Controls.ComboBox> in which each item contains a check box.</span></span>

- <span data-ttu-id="4d93f-130">**コントロール テンプレート。**</span><span class="sxs-lookup"><span data-stu-id="4d93f-130">**Control Templates.**</span></span> <span data-ttu-id="4d93f-131">の多くの[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]コントロールは<xref:System.Windows.Controls.ControlTemplate>、 コントロールの構造と外観を定義するために使用され、コントロールの外観とコントロールの機能を分離します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-131">Many controls in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] use a <xref:System.Windows.Controls.ControlTemplate> to define the control's structure and appearance, which separates the appearance of a control from the functionality of the control.</span></span> <span data-ttu-id="4d93f-132">コントロールを再定義することで、コントロールの外観を大幅に<xref:System.Windows.Controls.ControlTemplate>変更できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-132">You can drastically change the appearance of a control by redefining its <xref:System.Windows.Controls.ControlTemplate>.</span></span>  <span data-ttu-id="4d93f-133">たとえば、信号機のような外観のコントロールが必要だとします。</span><span class="sxs-lookup"><span data-stu-id="4d93f-133">For example, suppose you want a control that looks like a stoplight.</span></span> <span data-ttu-id="4d93f-134">このコントロールのユーザー インターフェイスと機能は単純です。</span><span class="sxs-lookup"><span data-stu-id="4d93f-134">This control has a simple user interface and functionality.</span></span>  <span data-ttu-id="4d93f-135">コントロールは 3 つの円で構成され、一度に点灯するのはそのうちの 1 つだけです。</span><span class="sxs-lookup"><span data-stu-id="4d93f-135">The control is three circles, only one of which can be lit up at a time.</span></span> <span data-ttu-id="4d93f-136">いくつかの反射の後、一度に選択<xref:System.Windows.Controls.RadioButton>されている 1 つの機能しか提供していないことに気付くかもしれませんが、既定の外観は<xref:System.Windows.Controls.RadioButton>、信号のライトのようには見えなくなります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-136">After some reflection, you might realize that a <xref:System.Windows.Controls.RadioButton> offers the functionality of only one being selected at a time, but the default appearance of the <xref:System.Windows.Controls.RadioButton> looks nothing like the lights on a stoplight.</span></span>  <span data-ttu-id="4d93f-137">コントロール<xref:System.Windows.Controls.RadioButton>テンプレートを使用して外観を定義するため、コントロールの要件に合わせて<xref:System.Windows.Controls.ControlTemplate>を再定義し、ラジオ ボタンを使用してストップライトを作成できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-137">Because the <xref:System.Windows.Controls.RadioButton> uses a control template to define its appearance, it is easy to redefine the <xref:System.Windows.Controls.ControlTemplate> to fit the requirements of the control, and use radio buttons to make your stoplight.</span></span>

  > [!NOTE]
  > <span data-ttu-id="4d93f-138">a<xref:System.Windows.Controls.RadioButton>は を<xref:System.Windows.DataTemplate>使用できますが<xref:System.Windows.DataTemplate>、この例では a は十分ではありません。</span><span class="sxs-lookup"><span data-stu-id="4d93f-138">Although a <xref:System.Windows.Controls.RadioButton> can use a <xref:System.Windows.DataTemplate>, a <xref:System.Windows.DataTemplate> is not sufficient in this example.</span></span>  <span data-ttu-id="4d93f-139">コントロール<xref:System.Windows.DataTemplate>のコンテンツの外観を定義します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-139">The <xref:System.Windows.DataTemplate> defines the appearance of the content of a control.</span></span> <span data-ttu-id="4d93f-140">の<xref:System.Windows.Controls.RadioButton>場合、コンテンツは、選択されているかどうかを示す円の右側に表示<xref:System.Windows.Controls.RadioButton>される内容です。</span><span class="sxs-lookup"><span data-stu-id="4d93f-140">In the case of a <xref:System.Windows.Controls.RadioButton>, the content is whatever appears to the right of the circle that indicates whether the <xref:System.Windows.Controls.RadioButton> is selected.</span></span>  <span data-ttu-id="4d93f-141">信号機の例では、オプション ボタンに必要なのは "点灯" する円だけです。</span><span class="sxs-lookup"><span data-stu-id="4d93f-141">In the example of the stoplight, the radio button needs just be a circle that can "light up."</span></span> <span data-ttu-id="4d93f-142">ストップライトの外観要件は<xref:System.Windows.Controls.RadioButton>、 の既定の外観とは非常に異なるため、<xref:System.Windows.Controls.ControlTemplate>を再定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-142">Because the appearance requirement for the stoplight is so different than the default appearance of the <xref:System.Windows.Controls.RadioButton>, it is necessary to redefine the <xref:System.Windows.Controls.ControlTemplate>.</span></span>  <span data-ttu-id="4d93f-143">一般に<xref:System.Windows.DataTemplate>a はコントロールのコンテンツ (またはデータ) を定義するために使用<xref:System.Windows.Controls.ControlTemplate>され、a はコントロールの構造を定義するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-143">In general a <xref:System.Windows.DataTemplate> is used for defining the content (or data) of a control, and a <xref:System.Windows.Controls.ControlTemplate> is used for defining how a control is structured.</span></span>

- <span data-ttu-id="4d93f-144">**トリガー。**</span><span class="sxs-lookup"><span data-stu-id="4d93f-144">**Triggers.**</span></span> <span data-ttu-id="4d93f-145">A<xref:System.Windows.Trigger>を使用すると、新しいコントロールを作成せずに、コントロールの外観と動作を動的に変更できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-145">A <xref:System.Windows.Trigger> allows you to dynamically change the appearance and behavior of a control without creating a new control.</span></span> <span data-ttu-id="4d93f-146">たとえば、アプリケーションに複数<xref:System.Windows.Controls.ListBox>のコントロールがあり、各項目を選択したときに項目<xref:System.Windows.Controls.ListBox>を太字にして赤にする場合を考えます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-146">For example, suppose you have multiple <xref:System.Windows.Controls.ListBox> controls in your application and want the items in each <xref:System.Windows.Controls.ListBox> to be bold and red when they are selected.</span></span> <span data-ttu-id="4d93f-147">最初の本能は、選択した項目の外観を変更する<xref:System.Windows.Controls.ListBox><xref:System.Windows.Controls.Primitives.Selector.OnSelectionChanged%2A>メソッドを継承してオーバーライドするクラスを作成することですが、選択した項目の外観を変更<xref:System.Windows.Controls.ListBoxItem>するスタイルにトリガーを追加する方が良いでしょう。</span><span class="sxs-lookup"><span data-stu-id="4d93f-147">Your first instinct might be to create a class that inherits from <xref:System.Windows.Controls.ListBox> and override the <xref:System.Windows.Controls.Primitives.Selector.OnSelectionChanged%2A> method to change the appearance of the selected item, but a better approach is to add a trigger to a style of a <xref:System.Windows.Controls.ListBoxItem> that changes the appearance of the selected item.</span></span> <span data-ttu-id="4d93f-148">トリガーを使用すると、プロパティ値を変更したり、プロパティ値に基づいた処理を実行したりできます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-148">A trigger enables you to change property values or take actions based on the value of a property.</span></span> <span data-ttu-id="4d93f-149">イベント<xref:System.Windows.EventTrigger>が発生したときにアクションを実行できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-149">An <xref:System.Windows.EventTrigger> enables you to take actions when an event occurs.</span></span>

<span data-ttu-id="4d93f-150">スタイル、テンプレート、トリガーの詳細については、「[スタイルとテンプレート](styling-and-templating.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4d93f-150">For more information about styles, templates, and triggers, see [Styling and Templating](styling-and-templating.md).</span></span>

<span data-ttu-id="4d93f-151">一般に、既存のコントロールと同じ機能を持ち、外観が異なるコントロールが必要な場合は、このセクションで説明した方法のいずれかを使用して、既存のコントロールの外観を変更できないかどうかをまず検討することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="4d93f-151">In general, if your control mirrors the functionality of an existing control, but you want the control to look different, you should first consider whether you can use any of the methods discussed in this section to change the existing control's appearance.</span></span>

<a name="models_for_control_authoring"></a>

## <a name="models-for-control-authoring"></a><span data-ttu-id="4d93f-152">コントロール作成モデル</span><span class="sxs-lookup"><span data-stu-id="4d93f-152">Models for Control Authoring</span></span>

<span data-ttu-id="4d93f-153">リッチ コンテンツ モデル、スタイル、テンプレート、トリガーを使用すると、新しいコントロールを作成する必要性が最小限に抑えられます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-153">The rich content model, styles, templates, and triggers minimize the need for you to create a new control.</span></span> <span data-ttu-id="4d93f-154">ただし、新しいコントロールを作成する必要がある場合は、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の各種のコントロール作成モデルを理解することが重要です。</span><span class="sxs-lookup"><span data-stu-id="4d93f-154">However, if you do need to create a new control, it is important to understand the different control authoring models in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="4d93f-155">には、コントロールを作成するための一般的なモデルが 3 つあり、各モデルはそれぞれ異なる機能と柔軟性レベルを備えています。</span><span class="sxs-lookup"><span data-stu-id="4d93f-155">provides three general models for creating a control, each of which provides a different set of features and level of flexibility.</span></span> <span data-ttu-id="4d93f-156">3 つのモデルの基本クラスは<xref:System.Windows.Controls.UserControl>、 <xref:System.Windows.Controls.Control>、<xref:System.Windows.FrameworkElement>および です。</span><span class="sxs-lookup"><span data-stu-id="4d93f-156">The base classes for the three models are <xref:System.Windows.Controls.UserControl>, <xref:System.Windows.Controls.Control>, and <xref:System.Windows.FrameworkElement>.</span></span>

### <a name="deriving-from-usercontrol"></a><span data-ttu-id="4d93f-157">UserControl からの派生</span><span class="sxs-lookup"><span data-stu-id="4d93f-157">Deriving from UserControl</span></span>

<span data-ttu-id="4d93f-158">でコントロールを作成する最も簡単な[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]方法は、<xref:System.Windows.Controls.UserControl>から派生することです。</span><span class="sxs-lookup"><span data-stu-id="4d93f-158">The simplest way to create a control in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to derive from <xref:System.Windows.Controls.UserControl>.</span></span> <span data-ttu-id="4d93f-159">から<xref:System.Windows.Controls.UserControl>継承するコントロールを構築する場合は、 に既存のコンポーネントを<xref:System.Windows.Controls.UserControl>追加し、 コンポーネントに名前を付け[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]、イベント ハンドラを参照します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-159">When you build a control that inherits from <xref:System.Windows.Controls.UserControl>, you add existing components to the <xref:System.Windows.Controls.UserControl>, name the components, and reference event handlers in [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)].</span></span> <span data-ttu-id="4d93f-160">次に、指定の要素を参照し、コードでイベント ハンドラーを定義します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-160">You can then reference the named elements and define the event handlers in code.</span></span> <span data-ttu-id="4d93f-161">この開発モデルは、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] でのアプリケーション開発に使用されるモデルとよく似ています。</span><span class="sxs-lookup"><span data-stu-id="4d93f-161">This development model is very similar to the model used for application development in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>

<span data-ttu-id="4d93f-162">正しく構築されていれば、<xref:System.Windows.Controls.UserControl>はリッチコンテンツ、スタイル、トリガの利点を活用できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-162">If built correctly, a <xref:System.Windows.Controls.UserControl> can take advantage of the benefits of rich content, styles, and triggers.</span></span> <span data-ttu-id="4d93f-163">ただし、コントロールが から<xref:System.Windows.Controls.UserControl>継承されている場合、コントロールを使用するユーザーは、 または<xref:System.Windows.DataTemplate>外観<xref:System.Windows.Controls.ControlTemplate>をカスタマイズできません。</span><span class="sxs-lookup"><span data-stu-id="4d93f-163">However, if your control inherits from <xref:System.Windows.Controls.UserControl>, people who use your control will not be able to use a <xref:System.Windows.DataTemplate> or <xref:System.Windows.Controls.ControlTemplate> to customize its appearance.</span></span>  <span data-ttu-id="4d93f-164">テンプレートをサポートするカスタム コントロール<xref:System.Windows.Controls.Control>を作成するには、クラスまたはその派生クラス (<xref:System.Windows.Controls.UserControl>以外) から派生させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-164">It is necessary to derive from the <xref:System.Windows.Controls.Control> class or one of its derived classes (other than <xref:System.Windows.Controls.UserControl>) to create a custom control that supports templates.</span></span>

#### <a name="benefits-of-deriving-from-usercontrol"></a><span data-ttu-id="4d93f-165">UserControl からの派生の利点</span><span class="sxs-lookup"><span data-stu-id="4d93f-165">Benefits of Deriving from UserControl</span></span>

<span data-ttu-id="4d93f-166">以下のすべてが当<xref:System.Windows.Controls.UserControl>てはまる場合に派生することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="4d93f-166">Consider deriving from <xref:System.Windows.Controls.UserControl> if all of the following apply:</span></span>

- <span data-ttu-id="4d93f-167">アプリケーションの構築と同じ方法でコントロールをビルドする必要がある場合。</span><span class="sxs-lookup"><span data-stu-id="4d93f-167">You want to build your control similarly to how you build an application.</span></span>

- <span data-ttu-id="4d93f-168">コントロールが既存のコンポーネントのみで構成されている場合。</span><span class="sxs-lookup"><span data-stu-id="4d93f-168">Your control consists only of existing components.</span></span>

- <span data-ttu-id="4d93f-169">複雑なカスタマイズをサポートする必要がない場合。</span><span class="sxs-lookup"><span data-stu-id="4d93f-169">You don't need to support complex customization.</span></span>

### <a name="deriving-from-control"></a><span data-ttu-id="4d93f-170">Control からの派生</span><span class="sxs-lookup"><span data-stu-id="4d93f-170">Deriving from Control</span></span>

<span data-ttu-id="4d93f-171">クラスから派生する<xref:System.Windows.Controls.Control>モデルは、既存[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]のコントロールの大部分で使用されるモデルです。</span><span class="sxs-lookup"><span data-stu-id="4d93f-171">Deriving from the <xref:System.Windows.Controls.Control> class is the model used by most of the existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls.</span></span> <span data-ttu-id="4d93f-172"><xref:System.Windows.Controls.Control>クラスから継承するコントロールを作成する場合は、テンプレートを使用して外観を定義します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-172">When you create a control that inherits from the <xref:System.Windows.Controls.Control> class, you define its appearance by using templates.</span></span> <span data-ttu-id="4d93f-173">これにより、操作ロジックと視覚的表現とが分離されます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-173">By doing so, you separate the operational logic from the visual representation.</span></span> <span data-ttu-id="4d93f-174">イベントの代わりにコマンドとバインディングを使用し、可能な<xref:System.Windows.Controls.ControlTemplate>限り要素を参照しないようにすることで、UI とロジックの分離を確実に行うことができます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-174">You can also ensure the decoupling of the UI and logic by using commands and bindings instead of events and avoiding referencing elements in the <xref:System.Windows.Controls.ControlTemplate> whenever possible.</span></span>  <span data-ttu-id="4d93f-175">コントロールの UI とロジックが適切に切り離されている場合、コントロールのユーザーはコントロールを再定義<xref:System.Windows.Controls.ControlTemplate>して外観をカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-175">If the UI and logic of your control are properly decoupled, a user of your control can redefine the control's <xref:System.Windows.Controls.ControlTemplate> to customize its appearance.</span></span> <span data-ttu-id="4d93f-176">カスタム<xref:System.Windows.Controls.Control>の構築は<xref:System.Windows.Controls.UserControl>、 を構築するほど簡単ではありませんが、カスタム<xref:System.Windows.Controls.Control>を使用すると、最も柔軟性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-176">Although building a custom <xref:System.Windows.Controls.Control> is not as simple as building a <xref:System.Windows.Controls.UserControl>, a custom <xref:System.Windows.Controls.Control> provides the most flexibility.</span></span>

#### <a name="benefits-of-deriving-from-control"></a><span data-ttu-id="4d93f-177">Control からの派生の利点</span><span class="sxs-lookup"><span data-stu-id="4d93f-177">Benefits of Deriving from Control</span></span>

<span data-ttu-id="4d93f-178">次のいずれかが該当する<xref:System.Windows.Controls.Control>場合は、クラス<xref:System.Windows.Controls.UserControl>を使用する代わりに派生することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="4d93f-178">Consider deriving from <xref:System.Windows.Controls.Control> instead of using the <xref:System.Windows.Controls.UserControl> class if any of the following apply:</span></span>

- <span data-ttu-id="4d93f-179">コントロールの外観を<xref:System.Windows.Controls.ControlTemplate>でカスタマイズできるようにする。</span><span class="sxs-lookup"><span data-stu-id="4d93f-179">You want the appearance of your control to be customizable via the <xref:System.Windows.Controls.ControlTemplate>.</span></span>

- <span data-ttu-id="4d93f-180">コントロールがさまざまなテーマをサポートする必要がある場合。</span><span class="sxs-lookup"><span data-stu-id="4d93f-180">You want your control to support different themes.</span></span>

### <a name="deriving-from-frameworkelement"></a><span data-ttu-id="4d93f-181">FrameworkElement からの派生</span><span class="sxs-lookup"><span data-stu-id="4d93f-181">Deriving from FrameworkElement</span></span>

<span data-ttu-id="4d93f-182">既存の要素の<xref:System.Windows.Controls.UserControl>作成<xref:System.Windows.Controls.Control>から派生するコントロール、または既存の要素の作成に依存するコントロール。</span><span class="sxs-lookup"><span data-stu-id="4d93f-182">Controls that derive from <xref:System.Windows.Controls.UserControl> or <xref:System.Windows.Controls.Control> rely upon composing existing elements.</span></span> <span data-ttu-id="4d93f-183">多くのシナリオでは、継承するオブジェクト<xref:System.Windows.FrameworkElement>は . <xref:System.Windows.Controls.ControlTemplate></span><span class="sxs-lookup"><span data-stu-id="4d93f-183">For many scenarios, this is an acceptable solution, because any object that inherits from <xref:System.Windows.FrameworkElement> can be in a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="4d93f-184">しかし、場合によっては、単純な要素コンポジションでは、コントロールの外観に必要な機能を実現できないことがあります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-184">However, there are times when a control's appearance requires more than the functionality of simple element composition.</span></span> <span data-ttu-id="4d93f-185">これらのシナリオでは、コンポーネントを基に<xref:System.Windows.FrameworkElement>することが正しい選択です。</span><span class="sxs-lookup"><span data-stu-id="4d93f-185">For these scenarios, basing a component on <xref:System.Windows.FrameworkElement> is the right choice.</span></span>

<span data-ttu-id="4d93f-186">ベースのコンポーネントを構築<xref:System.Windows.FrameworkElement>するための標準の方法には、直接レンダリングとカスタム要素のコンポジションの 2 つがあります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-186">There are two standard methods for building <xref:System.Windows.FrameworkElement>-based components: direct rendering and custom element composition.</span></span> <span data-ttu-id="4d93f-187">直接レンダリングでは、メソッドを<xref:System.Windows.UIElement.OnRender%2A>オーバーライド<xref:System.Windows.FrameworkElement>し、コンポーネント<xref:System.Windows.Media.DrawingContext>ビジュアルを明示的に定義する操作を提供します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-187">Direct rendering involves overriding the <xref:System.Windows.UIElement.OnRender%2A> method of <xref:System.Windows.FrameworkElement> and providing <xref:System.Windows.Media.DrawingContext> operations that explicitly define the component visuals.</span></span> <span data-ttu-id="4d93f-188">これは、 と で<xref:System.Windows.Controls.Image>使用<xref:System.Windows.Controls.Border>される方法です。</span><span class="sxs-lookup"><span data-stu-id="4d93f-188">This is the method used by <xref:System.Windows.Controls.Image> and <xref:System.Windows.Controls.Border>.</span></span> <span data-ttu-id="4d93f-189">カスタム要素の構成では、型<xref:System.Windows.Media.Visual>のオブジェクトを使用してコンポーネントの外観を構成します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-189">Custom element composition involves using objects of type <xref:System.Windows.Media.Visual> to compose the appearance of your component.</span></span> <span data-ttu-id="4d93f-190">例については、「[DrawingVisual オブジェクトの使用](../graphics-multimedia/using-drawingvisual-objects.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4d93f-190">For an example, see [Using DrawingVisual Objects](../graphics-multimedia/using-drawingvisual-objects.md).</span></span> <span data-ttu-id="4d93f-191"><xref:System.Windows.Controls.Primitives.Track>は、カスタム要素の構成を[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]使用するコントロールの例です。</span><span class="sxs-lookup"><span data-stu-id="4d93f-191"><xref:System.Windows.Controls.Primitives.Track> is an example of a control in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] that uses custom element composition.</span></span> <span data-ttu-id="4d93f-192">同じコントロールでダイレクト レンダリングとカスタム要素コンポジションを混在させることもできます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-192">It is also possible to mix direct rendering and custom element composition in the same control.</span></span>

#### <a name="benefits-of-deriving-from-frameworkelement"></a><span data-ttu-id="4d93f-193">FrameworkElement からの派生の利点</span><span class="sxs-lookup"><span data-stu-id="4d93f-193">Benefits of Deriving from FrameworkElement</span></span>

<span data-ttu-id="4d93f-194">次のいずれかが該当する<xref:System.Windows.FrameworkElement>場合は、派生元を検討してください。</span><span class="sxs-lookup"><span data-stu-id="4d93f-194">Consider deriving from <xref:System.Windows.FrameworkElement> if any of the following apply:</span></span>

- <span data-ttu-id="4d93f-195">コントロールの外観について、単純な要素コンポジションが提供する以上の厳密な制御を必要とする場合。</span><span class="sxs-lookup"><span data-stu-id="4d93f-195">You want to have precise control over the appearance of your control beyond what is provided by simple element composition.</span></span>

- <span data-ttu-id="4d93f-196">独自のレンダリング ロジックを定義して、コントロールの外観を定義する必要がある場合。</span><span class="sxs-lookup"><span data-stu-id="4d93f-196">You want to define the appearance of your control by defining your own render logic.</span></span>

- <span data-ttu-id="4d93f-197">既存の要素を、可能な点を超えた新しい方法で<xref:System.Windows.Controls.UserControl>構成する<xref:System.Windows.Controls.Control>必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-197">You want to compose existing elements in novel ways that go beyond what is possible with <xref:System.Windows.Controls.UserControl> and <xref:System.Windows.Controls.Control>.</span></span>

<a name="control_authoring_basics"></a>

## <a name="control-authoring-basics"></a><span data-ttu-id="4d93f-198">コントロール作成の基本</span><span class="sxs-lookup"><span data-stu-id="4d93f-198">Control Authoring Basics</span></span>

<span data-ttu-id="4d93f-199">既に説明したように、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の最も強力な機能の 1 つは、コントロールの基本的なプロパティ設定だけでは不可能な外観や動作の変更を実現し、しかもカスタム コントロールを作成する必要がないということです。</span><span class="sxs-lookup"><span data-stu-id="4d93f-199">As discussed earlier, one of the most powerful features of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is the ability to go beyond setting basic properties of a control to change its appearance and behavior, yet still not needing to create a custom control.</span></span> <span data-ttu-id="4d93f-200">スタイル設定、データ バインディング、トリガーの各機能は、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] プロパティ システムおよび [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] イベント システムによって実現されています。</span><span class="sxs-lookup"><span data-stu-id="4d93f-200">The styling, data binding, and trigger features are made possible by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system and the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system.</span></span> <span data-ttu-id="4d93f-201">以降のセクションでは、カスタム コントロールのユーザーが、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] に付属のコントロールと同じように、これらの機能を使用できるようにするために、カスタム コントロールの作成に使用するモデルに関係なく、従う必要があるプラクティスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-201">The following sections describe some practices that you should follow, regardless of the model you use to create the custom control, so that users of your custom control can use these features just as they would for a control that is included with [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>

### <a name="use-dependency-properties"></a><span data-ttu-id="4d93f-202">依存関係プロパティの使用</span><span class="sxs-lookup"><span data-stu-id="4d93f-202">Use Dependency Properties</span></span>

<span data-ttu-id="4d93f-203">プロパティが依存関係プロパティである場合、以下の操作が可能です。</span><span class="sxs-lookup"><span data-stu-id="4d93f-203">When a property is a dependency property, it is possible to do the following:</span></span>

- <span data-ttu-id="4d93f-204">スタイルのプロパティを設定する。</span><span class="sxs-lookup"><span data-stu-id="4d93f-204">Set the property in a style.</span></span>

- <span data-ttu-id="4d93f-205">プロパティをデータ ソースにバインドする。</span><span class="sxs-lookup"><span data-stu-id="4d93f-205">Bind the property to a data source.</span></span>

- <span data-ttu-id="4d93f-206">プロパティの値として、動的リソースを使用する。</span><span class="sxs-lookup"><span data-stu-id="4d93f-206">Use a dynamic resource as the property's value.</span></span>

- <span data-ttu-id="4d93f-207">プロパティ名をアニメーション化する。</span><span class="sxs-lookup"><span data-stu-id="4d93f-207">Animate the property.</span></span>

<span data-ttu-id="4d93f-208">コントロールのプロパティがこれらの機能のいずれかをサポートす必要がある場合、それを依存関係プロパティとして実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-208">If you want a property of your control to support any of this functionality, you should implement it as a dependency property.</span></span> <span data-ttu-id="4d93f-209">次の例では、以下の処理を実行して、`Value` という名前の依存関係プロパティを定義します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-209">The following example defines a dependency property named `Value` by doing the following:</span></span>

- <span data-ttu-id="4d93f-210">フィールドとして<xref:System.Windows.DependencyProperty>名前を`ValueProperty`付ける`public``static``readonly`識別子を定義します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-210">Define a <xref:System.Windows.DependencyProperty> identifier named `ValueProperty` as a `public` `static` `readonly` field.</span></span>

- <span data-ttu-id="4d93f-211">プロパティシステムにプロパティ名を登録するには、 を<xref:System.Windows.DependencyProperty.Register%2A?displayProperty=nameWithType>呼び出して、次の項目を指定します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-211">Register the property name with the property system, by calling <xref:System.Windows.DependencyProperty.Register%2A?displayProperty=nameWithType>, to specify the following:</span></span>

  - <span data-ttu-id="4d93f-212">プロパティの名前。</span><span class="sxs-lookup"><span data-stu-id="4d93f-212">The name of the property.</span></span>

  - <span data-ttu-id="4d93f-213">プロパティの型。</span><span class="sxs-lookup"><span data-stu-id="4d93f-213">The type of the property.</span></span>

  - <span data-ttu-id="4d93f-214">プロパティを所有する型。</span><span class="sxs-lookup"><span data-stu-id="4d93f-214">The type that owns the property.</span></span>

  - <span data-ttu-id="4d93f-215">プロパティのメタデータ。</span><span class="sxs-lookup"><span data-stu-id="4d93f-215">The metadata for the property.</span></span> <span data-ttu-id="4d93f-216">メタデータには、プロパティの既定値 、および<xref:System.Windows.CoerceValueCallback>a が含<xref:System.Windows.PropertyChangedCallback>まれています。</span><span class="sxs-lookup"><span data-stu-id="4d93f-216">The metadata contains the property's default value, a <xref:System.Windows.CoerceValueCallback> and a <xref:System.Windows.PropertyChangedCallback>.</span></span>

- <span data-ttu-id="4d93f-217">プロパティ`get`と`set`アクセサーを実装`Value`することによって、依存関係プロパティの登録に使用される名前の CLR ラッパー プロパティを定義します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-217">Define a CLR wrapper property named `Value`, which is the same name that is used to register the dependency property, by implementing the property's `get` and `set` accessors.</span></span> <span data-ttu-id="4d93f-218">アクセサーと`get``set`アクセサーは、<xref:System.Windows.DependencyObject.GetValue%2A>それぞれ<xref:System.Windows.DependencyObject.SetValue%2A>呼び出しのみであることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="4d93f-218">Note that the `get` and `set` accessors only call <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> respectively.</span></span> <span data-ttu-id="4d93f-219">クライアントと呼び出[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.DependencyObject.GetValue%2A>しをバイパスして<xref:System.Windows.DependencyObject.SetValue%2A>直接実行できるため、依存関係プロパティのアクセサーには追加のロジックを含めないことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="4d93f-219">It is recommended that the accessors of dependency properties not contain additional logic because clients and [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can bypass the accessors and call <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> directly.</span></span> <span data-ttu-id="4d93f-220">たとえば、プロパティがデータ ソースにバインドされている場合、プロパティの `set` アクセサーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="4d93f-220">For example, when a property is bound to a data source, the property's `set` accessor is not called.</span></span>  <span data-ttu-id="4d93f-221">get アクセサーおよび set アクセサーにロジックを追加する<xref:System.Windows.ValidateValueCallback>代<xref:System.Windows.CoerceValueCallback>わりに、 <xref:System.Windows.PropertyChangedCallback> 、および デリゲートを使用して、値が変更されたときに値に応答したり、チェックしたりします。</span><span class="sxs-lookup"><span data-stu-id="4d93f-221">Instead of adding additional logic to the get and set accessors, use the <xref:System.Windows.ValidateValueCallback>, <xref:System.Windows.CoerceValueCallback>, and <xref:System.Windows.PropertyChangedCallback> delegates to respond to or check the value when it changes.</span></span>  <span data-ttu-id="4d93f-222">これらのコールバックの詳細については、「[依存関係プロパティのコールバックと検証](../advanced/dependency-property-callbacks-and-validation.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4d93f-222">For more information on these callbacks, see [Dependency Property Callbacks and Validation](../advanced/dependency-property-callbacks-and-validation.md).</span></span>

- <span data-ttu-id="4d93f-223">名前付き`CoerceValue`の<xref:System.Windows.CoerceValueCallback>メソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-223">Define a method for the <xref:System.Windows.CoerceValueCallback> named `CoerceValue`.</span></span> <span data-ttu-id="4d93f-224">`CoerceValue` によって、`Value` は `MinValue` 以上で `MaxValue` 以下になります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-224">`CoerceValue` ensures that `Value` is greater or equal to `MinValue` and less than or equal to `MaxValue`.</span></span>

- <span data-ttu-id="4d93f-225">という名前`OnValueChanged`の メソッド<xref:System.Windows.PropertyChangedCallback>を定義します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-225">Define a method for the <xref:System.Windows.PropertyChangedCallback>, named `OnValueChanged`.</span></span> <span data-ttu-id="4d93f-226">`OnValueChanged`オブジェクトを<xref:System.Windows.RoutedPropertyChangedEventArgs%601>作成し、ルーティング イベントを`ValueChanged`発生させる準備をします。</span><span class="sxs-lookup"><span data-stu-id="4d93f-226">`OnValueChanged` creates a <xref:System.Windows.RoutedPropertyChangedEventArgs%601> object and prepares to raise the `ValueChanged` routed event.</span></span> <span data-ttu-id="4d93f-227">ルーティング イベントについては、次のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-227">Routed events are discussed in the next section.</span></span>

[!code-csharp[UserControlNumericUpDown#DependencyProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#dependencyproperty)]
[!code-vb[UserControlNumericUpDown#DependencyProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#dependencyproperty)]

<span data-ttu-id="4d93f-228">詳細については、「[カスタム依存関係プロパティ](../advanced/custom-dependency-properties.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4d93f-228">For more information, see [Custom Dependency Properties](../advanced/custom-dependency-properties.md).</span></span>

### <a name="use-routed-events"></a><span data-ttu-id="4d93f-229">ルーティング イベントの使用</span><span class="sxs-lookup"><span data-stu-id="4d93f-229">Use Routed Events</span></span>

<span data-ttu-id="4d93f-230">依存関係プロパティが CLR プロパティの概念を拡張して機能を追加するのと同様に、ルーティング イベントは標準 CLR イベントの概念を拡張します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-230">Just as dependency properties extend the notion of CLR properties with additional functionality, routed events extend the notion of standard CLR events.</span></span> <span data-ttu-id="4d93f-231">新しい [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] コントロール作成する場合、イベントをルーティング イベントとして実装することをお勧めします。ルーティング イベントは以下の機能をサポートしているためです。</span><span class="sxs-lookup"><span data-stu-id="4d93f-231">When you create a new [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control, it is also good practice to implement your event as a routed event because a routed event supports the following behavior:</span></span>

- <span data-ttu-id="4d93f-232">複数のコントロールの親でイベントを処理できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-232">Events can be handled on a parent of multiple controls.</span></span> <span data-ttu-id="4d93f-233">イベントがバブル イベントの場合、要素ツリー内の単一の親はイベントをサブスクライブできます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-233">If an event is a bubbling event, a single parent in the element tree can subscribe to the event.</span></span> <span data-ttu-id="4d93f-234">これにより、アプリケーション開発者は、複数のコントロールのイベントに 1 つのハンドラーで対応できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-234">Then application authors can use one handler to respond to the event of multiple controls.</span></span> <span data-ttu-id="4d93f-235">たとえば、コントロールが<xref:System.Windows.Controls.ListBox>の各項目の一部である場合 (コントロールは<xref:System.Windows.DataTemplate>に含まれているため)、アプリケーション開発者は コントロールのイベントのイベント ハンドラを . <xref:System.Windows.Controls.ListBox></span><span class="sxs-lookup"><span data-stu-id="4d93f-235">For example, if your control is a part of each item in a <xref:System.Windows.Controls.ListBox> (because it is included in a <xref:System.Windows.DataTemplate>), the application developer can define the event handler for your control's event on the <xref:System.Windows.Controls.ListBox>.</span></span> <span data-ttu-id="4d93f-236">いずれかのコントロールでイベントが発生するたびに、そのイベント ハンドラーが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-236">Whenever the event occurs on any of the controls, the event handler is called.</span></span>

- <span data-ttu-id="4d93f-237">ルーティング イベントは<xref:System.Windows.EventSetter>、 で使用でき、アプリケーション開発者はスタイル内でイベントのハンドラーを指定できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-237">Routed events can be used in an <xref:System.Windows.EventSetter>, which enables application developers to specify the handler of an event within a style.</span></span>

- <span data-ttu-id="4d93f-238">ルーティング イベントは<xref:System.Windows.EventTrigger>で使用できます。 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</span><span class="sxs-lookup"><span data-stu-id="4d93f-238">Routed events can be used in an <xref:System.Windows.EventTrigger>, which is useful for animating properties by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="4d93f-239">詳細については、「アニメーションの[概要](../graphics-multimedia/animation-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4d93f-239">For more information, see [Animation Overview](../graphics-multimedia/animation-overview.md).</span></span>

<span data-ttu-id="4d93f-240">次に示す例では、以下の処理を実行して、ルーティング イベントを定義します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-240">The following example defines a routed event by doing the following:</span></span>

- <span data-ttu-id="4d93f-241">フィールドとして<xref:System.Windows.RoutedEvent>名前を`ValueChangedEvent`付ける`public``static``readonly`識別子を定義します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-241">Define a <xref:System.Windows.RoutedEvent> identifier named `ValueChangedEvent` as a `public` `static` `readonly` field.</span></span>

- <span data-ttu-id="4d93f-242">メソッドを呼び出してルーティング<xref:System.Windows.EventManager.RegisterRoutedEvent%2A?displayProperty=nameWithType>イベントを登録します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-242">Register the routed event by calling the <xref:System.Windows.EventManager.RegisterRoutedEvent%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4d93f-243">この例では、 を呼び出<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>すときに次の情報を指定します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-243">The example specifies the following information when it calls <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>:</span></span>

  - <span data-ttu-id="4d93f-244">イベントの名前が `ValueChanged` であること。</span><span class="sxs-lookup"><span data-stu-id="4d93f-244">The name of the event is `ValueChanged`.</span></span>

  - <span data-ttu-id="4d93f-245">ルーティング戦略は、<xref:System.Windows.RoutingStrategy.Bubble>ソース (イベントを発生させるオブジェクト) のイベント ハンドラが最初に呼び出され、次にソースの親要素のイベント ハンドラが、最も近い親要素のイベント ハンドラから順に連続して呼び出されることを意味します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-245">The routing strategy is <xref:System.Windows.RoutingStrategy.Bubble>, which means that an event handler on the source (the object that raises the event) is called first, and then event handlers on the source's parent elements are called in succession, starting with the event handler on the closest parent element.</span></span>

  - <span data-ttu-id="4d93f-246">イベント ハンドラの型は、<xref:System.Windows.RoutedPropertyChangedEventHandler%601>型で構築されます<xref:System.Decimal>。</span><span class="sxs-lookup"><span data-stu-id="4d93f-246">The type of the event handler is <xref:System.Windows.RoutedPropertyChangedEventHandler%601>, constructed with a <xref:System.Decimal> type.</span></span>

  - <span data-ttu-id="4d93f-247">イベントを所有する型が `NumericUpDown` であること。</span><span class="sxs-lookup"><span data-stu-id="4d93f-247">The owning type of the event is `NumericUpDown`.</span></span>

- <span data-ttu-id="4d93f-248">`ValueChanged` という名前のパブリック イベントを宣言し、イベント アクセサー宣言を含めます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-248">Declare a public event named `ValueChanged` and includes event-accessor declarations.</span></span> <span data-ttu-id="4d93f-249">この例では<xref:System.Windows.UIElement.AddHandler%2A>、`add`アクセサー宣言と<xref:System.Windows.UIElement.RemoveHandler%2A>アクセサー`remove`宣言を呼び出[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]して、イベント サービスを使用します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-249">The example calls <xref:System.Windows.UIElement.AddHandler%2A> in the `add` accessor declaration and <xref:System.Windows.UIElement.RemoveHandler%2A> in the `remove` accessor declaration to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event services.</span></span>

- <span data-ttu-id="4d93f-250">`ValueChanged`イベントを発生させる、保護された仮想メソッド `OnValueChanged` を作成します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-250">Create a protected, virtual method named `OnValueChanged` that raises the `ValueChanged` event.</span></span>

[!code-csharp[UserControlNumericUpDown#RoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#routedevent)]
[!code-vb[UserControlNumericUpDown#RoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#routedevent)]

<span data-ttu-id="4d93f-251">詳細については、「[ルーティング イベントの概要](../advanced/routed-events-overview.md)」および「[カスタム ルーティング イベントを作成する](../advanced/how-to-create-a-custom-routed-event.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4d93f-251">For more information, see [Routed Events Overview](../advanced/routed-events-overview.md) and [Create a Custom Routed Event](../advanced/how-to-create-a-custom-routed-event.md).</span></span>

### <a name="use-binding"></a><span data-ttu-id="4d93f-252">バインディングの使用</span><span class="sxs-lookup"><span data-stu-id="4d93f-252">Use Binding</span></span>

<span data-ttu-id="4d93f-253">コントロールの UI とロジックを分離するには、データ バインディングを使用する方法もあります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-253">To decouple the UI of your control from its logic, consider using data binding.</span></span> <span data-ttu-id="4d93f-254">これは、コントロールの外観を をを定義する場合に特に<xref:System.Windows.Controls.ControlTemplate>重要です。</span><span class="sxs-lookup"><span data-stu-id="4d93f-254">This is particularly important if you define the appearance of your control by using a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="4d93f-255">データ バインディングを使用すると、コードから UI の特定の部分を参照する必要性がなくなる場合があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-255">When you use data binding, you might be able to eliminate the need to reference specific parts of the UI from the code.</span></span> <span data-ttu-id="4d93f-256">の要素を<xref:System.Windows.Controls.ControlTemplate>参照するコードが 変更されると、参照先の要素<xref:System.Windows.Controls.ControlTemplate><xref:System.Windows.Controls.ControlTemplate>を new <xref:System.Windows.Controls.ControlTemplate>.</span><span class="sxs-lookup"><span data-stu-id="4d93f-256">It's a good idea to avoid referencing elements that are in the <xref:System.Windows.Controls.ControlTemplate> because when the code references elements that are in the <xref:System.Windows.Controls.ControlTemplate> and the <xref:System.Windows.Controls.ControlTemplate> is changed, the referenced element needs to be included in the new <xref:System.Windows.Controls.ControlTemplate>.</span></span>

<span data-ttu-id="4d93f-257">次の例では、<xref:System.Windows.Controls.TextBlock>コントロールの`NumericUpDown`を更新し、名前を割り当て、コード内でテキスト ボックスを名前で参照します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-257">The following example updates the <xref:System.Windows.Controls.TextBlock> of the `NumericUpDown` control, assigning a name to it and referencing the textbox by name in code.</span></span>

[!code-xaml[UserControlNumericUpDownSimple#UIRefMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml#uirefmarkup)]

[!code-csharp[UserControlNumericUpDownSimple#UIRefCode](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml.cs#uirefcode)]
[!code-vb[UserControlNumericUpDownSimple#UIRefCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDownSimple/VisualBasic/NumericUpDown.xaml.vb#uirefcode)]

<span data-ttu-id="4d93f-258">次の例では、バインディングを使用して同じことを実現しています。</span><span class="sxs-lookup"><span data-stu-id="4d93f-258">The following example uses binding to accomplish the same thing.</span></span>

[!code-xaml[UserControlNumericUpDown#Binding](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml#binding)]

<span data-ttu-id="4d93f-259">データ バインディングの詳細については、「[データ バインディングの概要](../../../desktop-wpf/data/data-binding-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4d93f-259">For more information about data binding, see [Data Binding Overview](../../../desktop-wpf/data/data-binding-overview.md).</span></span>

### <a name="design-for-designers"></a><span data-ttu-id="4d93f-260">デザイナーに対応したデザイン</span><span class="sxs-lookup"><span data-stu-id="4d93f-260">Design for Designers</span></span>

<span data-ttu-id="4d93f-261">Visual Studio 用の WPF デザイナーでカスタム WPF コントロールのサポートを受ける (プロパティ ウィンドウを使用したプロパティの編集など) には、次のガイドラインに従います。</span><span class="sxs-lookup"><span data-stu-id="4d93f-261">To receive support for custom WPF controls in the WPF Designer for Visual Studio (for example, property editing with the Properties window), follow these guidelines.</span></span>  <span data-ttu-id="4d93f-262">WPF デザイナーの開発の詳細については、「 Visual [Studio で XAML をデザイン](/visualstudio/xaml-tools/designing-xaml-in-visual-studio)する 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4d93f-262">For more information on developing for the WPF Designer, see [Design XAML in Visual Studio](/visualstudio/xaml-tools/designing-xaml-in-visual-studio).</span></span>

#### <a name="dependency-properties"></a><span data-ttu-id="4d93f-263">依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="4d93f-263">Dependency Properties</span></span>

<span data-ttu-id="4d93f-264">CLR`get`と`set`アクセサーは、前述の「依存関係プロパティの使用」で説明したように実装してください。</span><span class="sxs-lookup"><span data-stu-id="4d93f-264">Be sure to implement CLR `get` and `set` accessors as described earlier, in "Use Dependency Properties."</span></span> <span data-ttu-id="4d93f-265">デザイナーは、ラッパーを使用して依存関係プロパティの存在を検出する場合がありますが、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] およびコントロールのクライアントと同様、プロパティを取得または設定するときにアクセサーを呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="4d93f-265">Designers may use the wrapper to detect the presence of a dependency property, but they, like [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and clients of the control, are not required to call the accessors when getting or setting the property.</span></span>

#### <a name="attached-properties"></a><span data-ttu-id="4d93f-266">アタッチされるプロパティ</span><span class="sxs-lookup"><span data-stu-id="4d93f-266">Attached Properties</span></span>

<span data-ttu-id="4d93f-267">以下のガイドラインに従って、カスタム コントロールに添付プロパティを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-267">You should implement attached properties on custom controls using the following guidelines:</span></span>

- <span data-ttu-id="4d93f-268">メソッド`public``static``readonly`を<xref:System.Windows.DependencyProperty>使用して作成したフォーム*PropertyName*`Property`を<xref:System.Windows.DependencyProperty.RegisterAttached%2A>使用します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-268">Have a `public` `static` `readonly` <xref:System.Windows.DependencyProperty> of the form *PropertyName*`Property` that was creating using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="4d93f-269">渡されるプロパティ名は<xref:System.Windows.DependencyProperty.RegisterAttached%2A>*、プロパティ名*と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-269">The property name that is passed to <xref:System.Windows.DependencyProperty.RegisterAttached%2A> must match *PropertyName*.</span></span>

- <span data-ttu-id="4d93f-270">`Set`*PropertyName* および `Get`*PropertyName* という名前の `public` `static` CLR メソッドのペアを実装します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-270">Implement a pair of `public` `static` CLR methods named `Set`*PropertyName* and `Get`*PropertyName*.</span></span> <span data-ttu-id="4d93f-271">どちらのメソッドも、最初の引数<xref:System.Windows.DependencyProperty>として派生したクラスを受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-271">Both methods should accept a class derived from <xref:System.Windows.DependencyProperty> as their first argument.</span></span> <span data-ttu-id="4d93f-272">また、`Set`*PropertyName* メソッドでは、プロパティの登録データ型と同じ型の引数も受け取ります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-272">The `Set`*PropertyName* method also accepts an argument whose type matches the registered data type for the property.</span></span> <span data-ttu-id="4d93f-273">`Get`*PropertyName*メソッドでは、同じ型の値を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-273">The `Get`*PropertyName* method should return a value of the same type.</span></span> <span data-ttu-id="4d93f-274">`Set`*PropertyName*メソッドがない場合、プロパティは読み取り専用としてマークされます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-274">If the `Set`*PropertyName* method is missing, the property is marked read-only.</span></span>

- <span data-ttu-id="4d93f-275">`Set`*PropertyName* `Get`と*PropertyName*は、<xref:System.Windows.DependencyObject.GetValue%2A>ターゲット<xref:System.Windows.DependencyObject.SetValue%2A>依存関係オブジェクトの メソッドとメソッドにそれぞれ直接ルーティングする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-275">`Set` *PropertyName* and `Get`*PropertyName* must route directly to the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> methods on the target dependency object, respectively.</span></span> <span data-ttu-id="4d93f-276">デザイナーが添付プロパティにアクセスするには、メソッド ラッパー経由で呼び出す場合もあれば、対象の依存関係オブジェクトを直接呼び出す場合もあります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-276">Designers may access the attached property by calling through the method wrapper or making a direct call to the target dependency object.</span></span>

<span data-ttu-id="4d93f-277">添付プロパティの詳細については、「[添付プロパティの概要](../advanced/attached-properties-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4d93f-277">For more information on attached properties, see [Attached Properties Overview](../advanced/attached-properties-overview.md).</span></span>

### <a name="define-and-use-shared-resources"></a><span data-ttu-id="4d93f-278">共有リソースの定義と使用</span><span class="sxs-lookup"><span data-stu-id="4d93f-278">Define and Use Shared Resources</span></span>

<span data-ttu-id="4d93f-279">アプリケーションと同じアセンブリにコントロールを含めることも、複数のアプリケーションが使用できる別のアセンブリにコントロールをパッケージ化することもできます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-279">You can include your control in the same assembly as your application, or you can package your control in a separate assembly that can be used in multiple applications.</span></span> <span data-ttu-id="4d93f-280">このトピックで説明した情報の大部分は、使用する方法に関係なく適用されます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-280">For the most part, the information discussed in this topic applies regardless of the method you use.</span></span>  <span data-ttu-id="4d93f-281">ただし、1 つだけ例外があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-281">There is one difference worth noting, however.</span></span>  <span data-ttu-id="4d93f-282">アプリケーションと同じアセンブリ内にコントロールを配置する場合、App.xaml ファイルにグローバル リソースを自由に追加できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-282">When you put a control in the same assembly as an application, you are free to add global resources to the App.xaml file.</span></span> <span data-ttu-id="4d93f-283">ただし、コントロールのみを含むアセンブリには<xref:System.Windows.Application>オブジェクトが関連付けられていないため、App.xaml ファイルは使用できません。</span><span class="sxs-lookup"><span data-stu-id="4d93f-283">But an assembly that contains only controls does not have an <xref:System.Windows.Application> object associated with it, so an App.xaml file is not available.</span></span>

<span data-ttu-id="4d93f-284">アプリケーションがリソースを検索するときは、次に示す順序で 3 つのレベルを検索します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-284">When an application looks for a resource, it looks at three levels in the following order:</span></span>

1. <span data-ttu-id="4d93f-285">要素レベル。</span><span class="sxs-lookup"><span data-stu-id="4d93f-285">The element level.</span></span>

   <span data-ttu-id="4d93f-286">システムは、リソースを参照する要素から検索を開始し、ルート要素に到達するまで、論理上の親のリソースの検索を継続します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-286">The system starts with the element that references the resource and then searches resources of the logical parent and so forth until the root element is reached.</span></span>

2. <span data-ttu-id="4d93f-287">アプリケーション レベル。</span><span class="sxs-lookup"><span data-stu-id="4d93f-287">The application level.</span></span>

   <span data-ttu-id="4d93f-288">オブジェクトによって定義された<xref:System.Windows.Application>リソース。</span><span class="sxs-lookup"><span data-stu-id="4d93f-288">Resources defined by the <xref:System.Windows.Application> object.</span></span>

3. <span data-ttu-id="4d93f-289">テーマ レベル。</span><span class="sxs-lookup"><span data-stu-id="4d93f-289">The theme level.</span></span>

   <span data-ttu-id="4d93f-290">テーマ レベルのディクショナリは、Themes という名前のサブフォルダーに格納されています。</span><span class="sxs-lookup"><span data-stu-id="4d93f-290">Theme-level dictionaries are stored in a subfolder named Themes.</span></span>  <span data-ttu-id="4d93f-291">Themes フォルダー内のファイルはテーマに対応しています。</span><span class="sxs-lookup"><span data-stu-id="4d93f-291">The files in the Themes folder correspond to themes.</span></span>  <span data-ttu-id="4d93f-292">たとえば、Aero.NormalColor.xaml、Luna.NormalColor.xaml、Royale.NormalColor.xaml などのファイルがあります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-292">For example, you might have Aero.NormalColor.xaml, Luna.NormalColor.xaml, Royale.NormalColor.xaml, and so on.</span></span>  <span data-ttu-id="4d93f-293">generic.xaml という名前のファイルが含まれている場合もあります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-293">You can also have a file named generic.xaml.</span></span>  <span data-ttu-id="4d93f-294">システムがテーマ レベルでリソースを検索するとき、最初にテーマ固有のファイル内を検索し、次に generic.xaml 内を検索します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-294">When the system looks for a resource at the themes level, it first looks for it in the theme-specific file and then looks for it in generic.xaml.</span></span>

<span data-ttu-id="4d93f-295">アプリケーションとは別のアセンブリ内にコントロールを含めるときは、グローバル リソースを要素レベルまたはテーマ レベルに配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-295">When your control is in an assembly that is separate from the application, you must put your global resources at the element level or at the theme level.</span></span> <span data-ttu-id="4d93f-296">どちらに配置する場合も、それぞれの利点があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-296">Both methods have their advantages.</span></span>

#### <a name="defining-resources-at-the-element-level"></a><span data-ttu-id="4d93f-297">要素レベルでのリソース定義</span><span class="sxs-lookup"><span data-stu-id="4d93f-297">Defining Resources at the Element Level</span></span>

<span data-ttu-id="4d93f-298">ユーザー定義リソース ディクショナリを作成し、それをコントロールのリソース ディクショナリとマージすることで、要素レベルで共有リソースを定義できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-298">You can define shared resources at the element level by creating a custom resource dictionary and merging it with your control's resource dictionary.</span></span>  <span data-ttu-id="4d93f-299">このメソッドで定義する場合は、リソース ファイルに任意の名前を付けて、コントロールと同じフォルダーに配置できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-299">When you use this method, you can name your resource file anything you want, and it can be in the same folder as your controls.</span></span> <span data-ttu-id="4d93f-300">要素レベルでのリソースでは、単純な文字列をキーとして使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-300">Resources at the element level can also use simple strings as keys.</span></span> <span data-ttu-id="4d93f-301">次の例では、Dictionary1.xaml という名前の<xref:System.Windows.Media.LinearGradientBrush>リソース ファイルを作成します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-301">The following example creates a <xref:System.Windows.Media.LinearGradientBrush> resource file named Dictionary1.xaml.</span></span>

[!code-xaml[SharedResources#1](~/samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/Dictionary1.xaml#1)]

<span data-ttu-id="4d93f-302">ディクショナリを定義したら、それをコントロールのリソース ディクショナリにマージする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-302">Once you have defined your dictionary, you need to merge it with your control's resource dictionary.</span></span>  <span data-ttu-id="4d93f-303">これには、[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] またはコードを使用します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-303">You can do this by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or code.</span></span>

<span data-ttu-id="4d93f-304">次の例では、[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] を使用してリソース ディクショナリを結合します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-304">The following example merges a resource dictionary by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span>

[!code-xaml[SharedResources#2](~/samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml#2)]

<span data-ttu-id="4d93f-305">この方法の欠点は、オブジェクトを<xref:System.Windows.ResourceDictionary>参照するたびにオブジェクトが作成されるということです。</span><span class="sxs-lookup"><span data-stu-id="4d93f-305">The disadvantage to this approach is that a <xref:System.Windows.ResourceDictionary> object is created each time you reference it.</span></span>  <span data-ttu-id="4d93f-306">たとえば、ライブラリに 10 個のカスタム コントロールがあり、XAML を使用して各コントロールの共有リソース ディクショナリをマージする場合、10 個の同一<xref:System.Windows.ResourceDictionary>のオブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-306">For example, if you have 10 custom controls in your library and merge the shared resource dictionaries for each control by using XAML, you create 10 identical <xref:System.Windows.ResourceDictionary> objects.</span></span>  <span data-ttu-id="4d93f-307">これを回避するには、コード内のリソースをマージし、結果を<xref:System.Windows.ResourceDictionary>返す静的クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-307">You can avoid this by creating a static class that merges the resources in code and returns the resulting <xref:System.Windows.ResourceDictionary>.</span></span>

<span data-ttu-id="4d93f-308">次の例では、共有<xref:System.Windows.ResourceDictionary>を返すクラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-308">The following example creates a class that returns a shared <xref:System.Windows.ResourceDictionary>.</span></span>

[!code-csharp[SharedResources#3](~/samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/SharedDictionaryManager.cs#3)]

<span data-ttu-id="4d93f-309">次の例では、`InitializeComponent` を呼び出す前に、共有リソースをコントロールのコンス トラクター内でカスタム コントロールのリソースと結合します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-309">The following example merges the shared resource with the resources of a custom control in the control's constructor before it calls `InitializeComponent`.</span></span>  <span data-ttu-id="4d93f-310">`SharedDictionaryManager.SharedDictionary`は静的プロパティであるため、 は<xref:System.Windows.ResourceDictionary>一度だけ作成されます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-310">Because the `SharedDictionaryManager.SharedDictionary` is a static property, the <xref:System.Windows.ResourceDictionary> is created only once.</span></span> <span data-ttu-id="4d93f-311">`InitializeComponent` が呼び出される前に、リソース ディクショナリが結合されため、コントロールは [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] ファイル内でリソースを使用できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-311">Because the resource dictionary was merged before `InitializeComponent` was called, the resources are available to the control in its [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] file.</span></span>

[!code-csharp[SharedResources#4](~/samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml.cs#4)]

#### <a name="defining-resources-at-the-theme-level"></a><span data-ttu-id="4d93f-312">テーマ レベルでのリソース定義</span><span class="sxs-lookup"><span data-stu-id="4d93f-312">Defining Resources at the Theme Level</span></span>

[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="4d93f-313">では、さまざまな Windows テーマ用にリソースを作成できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-313">enables you to create resources for different Windows themes.</span></span>  <span data-ttu-id="4d93f-314">コントロールの作成者は、特定のテーマ用のリソースを定義して、使用するテーマに応じてコントロールの外観を変更できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-314">As a control author, you can define a resource for a specific theme to change your control's appearance depending on what theme is in use.</span></span> <span data-ttu-id="4d93f-315">たとえば、Windows クラシック テーマ<xref:System.Windows.Controls.Button>(Windows 2000 の既定のテーマ) の外観は、Windows の<xref:System.Windows.Controls.Button>ルナ テーマ (Windows XP の既定のテーマ)<xref:System.Windows.Controls.Button>の外観とは異<xref:System.Windows.Controls.ControlTemplate>なります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-315">For example, the appearance of a <xref:System.Windows.Controls.Button> in the Windows Classic theme (the default theme for Windows 2000) differs from a <xref:System.Windows.Controls.Button> in the Windows Luna theme (the default theme for Windows XP) because the <xref:System.Windows.Controls.Button> uses a different <xref:System.Windows.Controls.ControlTemplate> for each theme.</span></span>

<span data-ttu-id="4d93f-316">テーマ固有のリソースは、固有のファイル名でリソース ディクショナリに保持されます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-316">Resources that are specific to a theme are kept in a resource dictionary with a specific file name.</span></span> <span data-ttu-id="4d93f-317">これらのファイルは、コントロールが格納されているフォルダーのサブフォルダーである `Themes` フォルダー内に配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-317">These files must be in a folder named `Themes` that is a subfolder of the folder that contains the control.</span></span> <span data-ttu-id="4d93f-318">次の表は、リソース ディクショナリ ファイルと、各ファイルに関連付けられているテーマを示しています。</span><span class="sxs-lookup"><span data-stu-id="4d93f-318">The following table lists the resource dictionary files and the theme that is associated with each file:</span></span>

|<span data-ttu-id="4d93f-319">リソース ディクショナリ ファイル名</span><span class="sxs-lookup"><span data-stu-id="4d93f-319">Resource dictionary file name</span></span>|<span data-ttu-id="4d93f-320">Windows テーマ</span><span class="sxs-lookup"><span data-stu-id="4d93f-320">Windows theme</span></span>|
|-----------------------------------|-------------------|
|`Classic.xaml`|<span data-ttu-id="4d93f-321">Windows XP のクラシックな Windows 9x/2000 の外観</span><span class="sxs-lookup"><span data-stu-id="4d93f-321">Classic Windows 9x/2000 look on Windows XP</span></span>|
|`Luna.NormalColor.xaml`|<span data-ttu-id="4d93f-322">Windows XP の既定の青のテーマ</span><span class="sxs-lookup"><span data-stu-id="4d93f-322">Default blue theme on Windows XP</span></span>|
|`Luna.Homestead.xaml`|<span data-ttu-id="4d93f-323">Windows XP のオリーブのテーマ</span><span class="sxs-lookup"><span data-stu-id="4d93f-323">Olive theme on Windows XP</span></span>|
|`Luna.Metallic.xaml`|<span data-ttu-id="4d93f-324">Windows XP のシルバーのテーマ</span><span class="sxs-lookup"><span data-stu-id="4d93f-324">Silver theme on Windows XP</span></span>|
|`Royale.NormalColor.xaml`|<span data-ttu-id="4d93f-325">Windows XP Media Center Edition の既定テーマ</span><span class="sxs-lookup"><span data-stu-id="4d93f-325">Default theme on Windows XP Media Center Edition</span></span>|
|`Aero.NormalColor.xaml`|<span data-ttu-id="4d93f-326">Windows Vista の既定テーマ</span><span class="sxs-lookup"><span data-stu-id="4d93f-326">Default theme on Windows Vista</span></span>|

<span data-ttu-id="4d93f-327">すべてのテーマのリソースを定義する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="4d93f-327">You do not need to define a resource for every theme.</span></span> <span data-ttu-id="4d93f-328">特定のテーマについてリソースが定義されていない場合、コントロールはリソースの `Classic.xaml` を確認します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-328">If a resource is not defined for a specific theme, then the control checks `Classic.xaml` for the resource.</span></span> <span data-ttu-id="4d93f-329">現在のテーマに対応するファイルや `Classic.xaml` でリソースが定義されていない場合、コントロールは汎用のリソースを使用します。汎用のリソースは、`generic.xaml` という名前のリソース ディクショナリ ファイルにあります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-329">If the resource is not defined in the file that corresponds to the current theme or in `Classic.xaml`, the control uses the generic resource, which is in a resource dictionary file named `generic.xaml`.</span></span>  <span data-ttu-id="4d93f-330">`generic.xaml` ファイルは、テーマ固有のリソース ディクショナリ ファイルと同じフォルダーに配置されています。</span><span class="sxs-lookup"><span data-stu-id="4d93f-330">The `generic.xaml` file is located in the same folder as the theme-specific resource dictionary files.</span></span> <span data-ttu-id="4d93f-331">`generic.xaml` は、特定の Windows テーマには対応していませんが、テーマ レベルのディクショナリであることに変わりありません。</span><span class="sxs-lookup"><span data-stu-id="4d93f-331">Although `generic.xaml` does not correspond to a specific Windows theme, it is still a theme-level dictionary.</span></span>

<span data-ttu-id="4d93f-332">テーマと UI オートメーション のサポート サンプルを含む[C#](https://github.com/dotnet/docs/tree/master/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp)または[Visual Basic](https://github.com/dotnet/docs/tree/master/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic) NumericUpDown`NumericUpDown`カスタム コントロールには、コントロール用の 2 つのリソース ディクショナリが含まれています。</span><span class="sxs-lookup"><span data-stu-id="4d93f-332">The [C#](https://github.com/dotnet/docs/tree/master/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp) or [Visual Basic](https://github.com/dotnet/docs/tree/master/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic) NumericUpDown custom control with theme and UI automation support sample contains two resource dictionaries for the `NumericUpDown` control: one is in generic.xaml, and the other is in Luna.NormalColor.xaml.</span></span>

<span data-ttu-id="4d93f-333">テーマ固有のリソース<xref:System.Windows.Controls.ControlTemplate>ディクショナリ ファイルのいずれかに を配置する場合は、次の例に示すように、コントロールの静的コンストラクターを<xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>作成し<xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>、 でメソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-333">When you put a <xref:System.Windows.Controls.ControlTemplate> in any of the theme-specific resource dictionary files, you must create a static constructor for your control and call the <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29> method on the <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>, as shown in the following example.</span></span>

[!code-csharp[CustomControlNumericUpDownOneProject#StaticConstructor](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/CSharp/NumericUpDown.cs#staticconstructor)]
[!code-vb[CustomControlNumericUpDownOneProject#StaticConstructor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/visualbasic/numericupdown.vb#staticconstructor)]

##### <a name="defining-and-referencing-keys-for-theme-resources"></a><span data-ttu-id="4d93f-334">テーマ リソース用のキーの定義と参照</span><span class="sxs-lookup"><span data-stu-id="4d93f-334">Defining and Referencing Keys for Theme Resources</span></span>

<span data-ttu-id="4d93f-335">要素レベルでリソースを定義するときに、文字列をキーとして割り当て、その文字列を使用してリソースにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-335">When you define a resource at the element level, you can assign a string as its key and access the resource via the string.</span></span> <span data-ttu-id="4d93f-336">テーマ レベルでリソースを定義する場合は、 を<xref:System.Windows.ComponentResourceKey>キーとして使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-336">When you define a resource at the theme level, you must use a <xref:System.Windows.ComponentResourceKey> as the key.</span></span>  <span data-ttu-id="4d93f-337">次の例では、generic.xaml でリソースを定義します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-337">The following example defines a resource in generic.xaml.</span></span>

[!code-xaml[ThemeResourcesControlLibrary#5](~/samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/Themes/generic.xaml#5)]

<span data-ttu-id="4d93f-338">次の例では、 キーとしてを<xref:System.Windows.ComponentResourceKey>指定してリソースを参照します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-338">The following example references the resource by specifying the <xref:System.Windows.ComponentResourceKey> as the key.</span></span>

[!code-xaml[ThemeResourcesControlLibrary#6](~/samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/NumericUpDown.xaml#6)]

##### <a name="specifying-the-location-of-theme-resources"></a><span data-ttu-id="4d93f-339">テーマ リソースの場所の指定</span><span class="sxs-lookup"><span data-stu-id="4d93f-339">Specifying the Location of Theme Resources</span></span>

<span data-ttu-id="4d93f-340">コントロールのリソースを見つけるには、アセンブリにコントロール固有のリソースが含まれていることを、ホスト アプリケーションが認識する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-340">To find the resources for a control, the hosting application needs to know that the assembly contains control-specific resources.</span></span> <span data-ttu-id="4d93f-341">これは、コントロールを含むアセンブリ<xref:System.Windows.ThemeInfoAttribute>に を追加することで実現できます。</span><span class="sxs-lookup"><span data-stu-id="4d93f-341">You can accomplish that by adding the <xref:System.Windows.ThemeInfoAttribute> to the assembly that contains the control.</span></span> <span data-ttu-id="4d93f-342"><xref:System.Windows.ThemeInfoAttribute>には、<xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A>汎用リソースの場所を指定する<xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A>プロパティと、テーマ固有のリソースの場所を指定するプロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="4d93f-342">The <xref:System.Windows.ThemeInfoAttribute> has a <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> property that specifies the location of generic resources, and a <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> property that specifies the location of the theme-specific resources.</span></span>

<span data-ttu-id="4d93f-343">プロパティ<xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A>と<xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A>プロパティをに<xref:System.Windows.ResourceDictionaryLocation.SourceAssembly>設定し、ジェネリック リソースとテーマ固有のリソースがコントロールと同じアセンブリに含まれるように指定します。</span><span class="sxs-lookup"><span data-stu-id="4d93f-343">The following example sets the <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> and <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> properties to <xref:System.Windows.ResourceDictionaryLocation.SourceAssembly>, to specify that the generic and theme-specific resources are in the same assembly as the control.</span></span>

[!code-csharp[CustomControlNumericUpDown#ThemesSection](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/Properties/AssemblyInfo.cs#themessection)]
[!code-vb[CustomControlNumericUpDown#ThemesSection](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/my project/assemblyinfo.vb#themessection)]

## <a name="see-also"></a><span data-ttu-id="4d93f-344">関連項目</span><span class="sxs-lookup"><span data-stu-id="4d93f-344">See also</span></span>

- [<span data-ttu-id="4d93f-345">Visual Studio で XAML をデザインする</span><span class="sxs-lookup"><span data-stu-id="4d93f-345">Design XAML in Visual Studio</span></span>](/visualstudio/xaml-tools/designing-xaml-in-visual-studio)
- [<span data-ttu-id="4d93f-346">WPF におけるパッケージの URI</span><span class="sxs-lookup"><span data-stu-id="4d93f-346">Pack URIs in WPF</span></span>](../app-development/pack-uris-in-wpf.md)
- [<span data-ttu-id="4d93f-347">コントロールのカスタマイズ</span><span class="sxs-lookup"><span data-stu-id="4d93f-347">Control Customization</span></span>](control-customization.md)
