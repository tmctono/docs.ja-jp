---
title: アーキテクチャ
ms.date: 03/30/2017
helpviewer_keywords:
- properties [WPF], attached
- attached properties [WPF]
- architecture [WPF]
- unmanaged components [WPF]
- affinity thread [WPF]
- Storyboards [WPF]
- milcore [WPF]
- components [WPF], unmanaged
- painter's algorithm
- interfaces [WPF], INotifyPropertyChange
- CommandBindings [WPF]
- data templates [WPF]
- thread [WPF], affinity
ms.assetid: 8579c10b-76ab-4c52-9691-195ce02333c8
ms.openlocfilehash: b16be8470a47f3e8e362feb0b13e10aa901baacb
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187133"
---
# <a name="wpf-architecture"></a><span data-ttu-id="6af0a-102">WPF アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="6af0a-102">WPF Architecture</span></span>
<span data-ttu-id="6af0a-103">このトピックは、Windows Presentation Foundation (WPF) のクラス階層のガイド ツアーです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-103">This topic provides a guided tour of the Windows Presentation Foundation (WPF) class hierarchy.</span></span> <span data-ttu-id="6af0a-104">WPF の主要なサブシステムの大部分と、それらの相互作用について説明します。</span><span class="sxs-lookup"><span data-stu-id="6af0a-104">It covers most of the major subsystems of WPF, and describes how they interact.</span></span> <span data-ttu-id="6af0a-105">また、WPF のアーキテクトが行ういくつかの選択についても詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="6af0a-105">It also details some of the choices made by the architects of WPF.</span></span>  

<a name="System_Object"></a>
## <a name="systemobject"></a><span data-ttu-id="6af0a-106">System.Object</span><span class="sxs-lookup"><span data-stu-id="6af0a-106">System.Object</span></span>  
 <span data-ttu-id="6af0a-107">WPF の主要なプログラミング モデルは、マネージド コードによって公開されます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-107">The primary WPF programming model is exposed through managed code.</span></span> <span data-ttu-id="6af0a-108">WPF の設計フェーズの初期段階では、システムのマネージド コンポーネントとアンマネージド コンポーネントの間のどこに線を引くかについていくつかの論争がありました。</span><span class="sxs-lookup"><span data-stu-id="6af0a-108">Early in the design phase of WPF there were a number of debates about where the line should be drawn between the managed components of the system and the unmanaged ones.</span></span> <span data-ttu-id="6af0a-109">CLR には、開発の生産性と堅牢性を高めるさまざまな機能 (メモリ管理、エラー処理、共通型システムなど) がありますが、それらにはコストが伴います。</span><span class="sxs-lookup"><span data-stu-id="6af0a-109">The CLR provides a number of features that make development more productive and robust (including memory management, error handling, common type system, etc.) but they come at a cost.</span></span>  
  
 <span data-ttu-id="6af0a-110">次の図では、WPF の主要なコンポーネントが示されています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-110">The major components of WPF are illustrated in the figure below.</span></span> <span data-ttu-id="6af0a-111">図の赤い部分 (PresentationFramework、PresentationCore、milcore) は、WPF の主要なコード部分です。</span><span class="sxs-lookup"><span data-stu-id="6af0a-111">The red sections of the diagram (PresentationFramework, PresentationCore, and milcore) are the major code portions of WPF.</span></span> <span data-ttu-id="6af0a-112">これらのうち、milcore だけがアンマネージド コンポーネントです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-112">Of these, only one is an unmanaged component – milcore.</span></span> <span data-ttu-id="6af0a-113">milcore は、DirectX との緊密な統合を可能にするためにアンマネージド コードで記述されています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-113">Milcore is written in unmanaged code in order to enable tight integration with DirectX.</span></span> <span data-ttu-id="6af0a-114">WPF でのすべての表示は、DirectX エンジンによって行われるため、ハードウェアとソフトウェアで効率的にレンダリングできます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-114">All display in WPF is done through the DirectX engine, allowing for efficient hardware and software rendering.</span></span> <span data-ttu-id="6af0a-115">WPF では、メモリと実行を細かく制御する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-115">WPF also required fine control over memory and execution.</span></span> <span data-ttu-id="6af0a-116">milcore の合成エンジンは、パフォーマンスに大きな影響を与えるため、パフォーマンスを高めるには CLR の多くの利点を放棄する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-116">The composition engine in milcore is extremely performance sensitive, and required giving up many advantages of the CLR to gain performance.</span></span>  
  
 <span data-ttu-id="6af0a-117">![.NET Framework 内での WPF の位置付け。](./media/wpf-architect1.PNG "wpf_architect1")</span><span class="sxs-lookup"><span data-stu-id="6af0a-117">![The position of WPF within the .NET Framework.](./media/wpf-architect1.PNG "wpf_architect1")</span></span>  
  
 <span data-ttu-id="6af0a-118">WPF のマネージド部分とアンマネージド部分の間の通信については、このトピックで後ほど説明します。</span><span class="sxs-lookup"><span data-stu-id="6af0a-118">Communication between the managed and unmanaged portions of WPF is discussed later in this topic.</span></span> <span data-ttu-id="6af0a-119">以下ではマネージド プログラミング モデルの残りの部分について説明します。</span><span class="sxs-lookup"><span data-stu-id="6af0a-119">The remainder of the managed programming model is described below.</span></span>  
  
<a name="System_Threading_DispatcherObject"></a>
## <a name="systemthreadingdispatcherobject"></a><span data-ttu-id="6af0a-120">System.Threading.DispatcherObject</span><span class="sxs-lookup"><span data-stu-id="6af0a-120">System.Threading.DispatcherObject</span></span>  
 <span data-ttu-id="6af0a-121">WPF のほとんどのオブジェクトは、コンカレンシーとスレッド処理を行うための基本的なコンストラクトを提供する <xref:System.Windows.Threading.DispatcherObject> から派生します。</span><span class="sxs-lookup"><span data-stu-id="6af0a-121">Most objects in WPF derive from <xref:System.Windows.Threading.DispatcherObject>, which provides the basic constructs for dealing with concurrency and threading.</span></span> <span data-ttu-id="6af0a-122">WPF は、ディスパッチャーによって実装されるメッセージング システムが基になっています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-122">WPF is based on a messaging system implemented by the dispatcher.</span></span> <span data-ttu-id="6af0a-123">これは、馴染みのある Win32 メッセージ ポンプとよく似ています。実際、WPF ディスパッチャーでは、クロス スレッド呼び出しを実行するために User32 メッセージが使用されます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-123">This works much like the familiar Win32 message pump; in fact, the WPF dispatcher uses User32 messages for performing cross thread calls.</span></span>  
  
 <span data-ttu-id="6af0a-124">WPF でのコンカレンシーに関しては、ディスパッチャーとスレッド アフィニティという 2 つの主要概念を理解しておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-124">There are really two core concepts to understand when discussing concurrency in WPF – the dispatcher and thread affinity.</span></span>  
  
 <span data-ttu-id="6af0a-125">WPF の設計フェーズでの目標は、単一の実行スレッドではあってもスレッド "アフィニティ" ではないモデルに移行することでした。</span><span class="sxs-lookup"><span data-stu-id="6af0a-125">During the design phase of WPF, the goal was to move to a single thread of execution, but a non-thread "affinitized" model.</span></span> <span data-ttu-id="6af0a-126">スレッド アフィニティは、実行中のスレッドの ID を使用してコンポーネントで何らかの種類の状態が格納されると発生します。</span><span class="sxs-lookup"><span data-stu-id="6af0a-126">Thread affinity happens when a component uses the identity of the executing thread to store some type of state.</span></span> <span data-ttu-id="6af0a-127">その最も一般的な形式は、スレッド ローカル ストア (TLS) を使用して状態を格納することです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-127">The most common form of this is to use the thread local store (TLS) to store state.</span></span> <span data-ttu-id="6af0a-128">スレッド アフィニティでは、実行の各論理スレッドが、オペレーティング システムの 1 つの物理スレッドによって所有されている必要があり、これによりメモリ集中型になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-128">Thread affinity requires that each logical thread of execution be owned by only one physical thread in the operating system, which can become memory intensive.</span></span> <span data-ttu-id="6af0a-129">最終的に、WPF のスレッド モデルは、スレッド アフィニティのある単一スレッド実行という既存の User32 スレッド モデルとの同期が維持されました。</span><span class="sxs-lookup"><span data-stu-id="6af0a-129">In the end, WPF’s threading model was kept in sync with the existing User32 threading model of single threaded execution with thread affinity.</span></span> <span data-ttu-id="6af0a-130">このようになった主な理由は相互運用性でした。OLE 2.0、クリップボード、Internet Explorer のようなシステムではすべて、単一スレッド アフィニティ (STA) の実行が必要になります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-130">The primary reason for this was interoperability – systems like OLE 2.0, the clipboard, and Internet Explorer all require single thread affinity (STA) execution.</span></span>  
  
 <span data-ttu-id="6af0a-131">STA スレッドを使用するオブジェクトがある場合は、スレッド間で通信を行い、正しいスレッドであることを検証する手段が必要です。</span><span class="sxs-lookup"><span data-stu-id="6af0a-131">Given that you have objects with STA threading, you need a way to communicate between threads, and validate that you are on the correct thread.</span></span> <span data-ttu-id="6af0a-132">ここでにディスパッチャーの役割があります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-132">Herein lies the role of the dispatcher.</span></span> <span data-ttu-id="6af0a-133">ディスパッチャーは、優先度付けされた複数のキューを使用する基本的なメッセージ ディスパッチ システムです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-133">The dispatcher is a basic message dispatching system, with multiple prioritized queues.</span></span> <span data-ttu-id="6af0a-134">メッセージの例としては、生の入力通知 (マウス移動)、フレームワーク機能 (レイアウト)、ユーザー コマンド (このメソッドの実行) などがあります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-134">Examples of messages include raw input notifications (mouse moved), framework functions (layout), or user commands (execute this method).</span></span> <span data-ttu-id="6af0a-135"><xref:System.Windows.Threading.DispatcherObject> から派生することにより、STA の動作を持つ CLR オブジェクトを作成し、作成時にディスパッチャーへのポインターを提供されます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-135">By deriving from <xref:System.Windows.Threading.DispatcherObject>, you create a CLR object that has STA behavior, and will be given a pointer to a dispatcher at creation time.</span></span>  
  
<a name="System_Windows_DependencyObject"></a>
## <a name="systemwindowsdependencyobject"></a><span data-ttu-id="6af0a-136">System.Windows.DependencyObject</span><span class="sxs-lookup"><span data-stu-id="6af0a-136">System.Windows.DependencyObject</span></span>  
 <span data-ttu-id="6af0a-137">WPF の構築で考慮されたアーキテクチャに関する主要な思想の 1 つは、メソッドまたはイベントよりプロパティを優先することでした。</span><span class="sxs-lookup"><span data-stu-id="6af0a-137">One of the primary architectural philosophies used in building WPF was a preference for properties over methods or events.</span></span> <span data-ttu-id="6af0a-138">プロパティは宣言型であり、アクションではなく意図を簡単に指定できます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-138">Properties are declarative and allow you to more easily specify intent instead of action.</span></span> <span data-ttu-id="6af0a-139">これは、また、ユーザー インターフェイスのコンテンツの表示に対して、モデル駆動型またはデータ駆動型のシステムもサポートしていました。</span><span class="sxs-lookup"><span data-stu-id="6af0a-139">This also supported a model driven, or data driven, system for displaying user interface content.</span></span> <span data-ttu-id="6af0a-140">この哲学には、アプリケーションの動作をより適切に制御するために、バインドできるプロパティをより多く作成するという意図された効果がありました。</span><span class="sxs-lookup"><span data-stu-id="6af0a-140">This philosophy had the intended effect of creating more properties that you could bind to, in order to better control the behavior of an application.</span></span>  
  
 <span data-ttu-id="6af0a-141">システムをよりプロパティ駆動型にするには、CLR によって提供されるものより機能の豊富なプロパティ システムが必要でした。</span><span class="sxs-lookup"><span data-stu-id="6af0a-141">In order to have more of the system driven by properties, a richer property system than what the CLR provides was needed.</span></span> <span data-ttu-id="6af0a-142">このような追加機能の簡単な例は変更通知です。</span><span class="sxs-lookup"><span data-stu-id="6af0a-142">A simple example of this richness is change notifications.</span></span> <span data-ttu-id="6af0a-143">双方向のバインドを有効にするには、バインドの両側で変更通知がサポートされている必要があります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-143">In order to enable two way binding, you need both sides of the bind to support change notification.</span></span> <span data-ttu-id="6af0a-144">動作をプロパティ値に結び付けるには、プロパティ値が変更されたときに通知を受け取る必要があります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-144">In order to have behavior tied to property values, you need to be notified when the property value changes.</span></span> <span data-ttu-id="6af0a-145">Microsoft .NET Framework の **INotifyPropertyChange** インターフェイスを使用すると、オブジェクトで変更通知を発行できますが、これはオプションです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-145">The Microsoft .NET Framework has an interface, **INotifyPropertyChange**, which allows an object to publish change notifications, however it is optional.</span></span>  
  
 <span data-ttu-id="6af0a-146">WPF では、<xref:System.Windows.DependencyObject> 型から派生した機能豊富なプロパティ システムが用意されています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-146">WPF provides a richer property system, derived from the <xref:System.Windows.DependencyObject> type.</span></span> <span data-ttu-id="6af0a-147">プロパティ システムは、プロパティ式間の依存関係を追跡し、依存関係が変化したときはプロパティ値を自動的に再検証するという点で、実際には "依存関係" プロパティ システムです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-147">The property system is truly a "dependency" property system in that it tracks dependencies between property expressions and automatically revalidates property values when dependencies change.</span></span> <span data-ttu-id="6af0a-148">たとえば、継承するプロパティがある場合 (<xref:System.Windows.Controls.Control.FontSize%2A> など)、値を継承する要素の親でプロパティが変更されると、システムによって自動的に更新されます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-148">For example, if you have a property that inherits (like <xref:System.Windows.Controls.Control.FontSize%2A>), the system is automatically updated if the property changes on a parent of an element that inherits the value.</span></span>  
  
 <span data-ttu-id="6af0a-149">WPF プロパティ システムの基礎は、プロパティ式の概念です。</span><span class="sxs-lookup"><span data-stu-id="6af0a-149">The foundation of the WPF property system is the concept of a property expression.</span></span> <span data-ttu-id="6af0a-150">WPF のこの最初のリリースでは、プロパティ式システムは閉じられており、式はすべてフレームワークの一部として提供されています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-150">In this first release of WPF, the property expression system is closed, and the expressions are all provided as part of the framework.</span></span> <span data-ttu-id="6af0a-151">プロパティ システムでデータ バインディング、スタイル設定、または継承がハード コーディングされるのではなく、後でフレームワーク内のレイヤーによって提供されるのは、式のためです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-151">Expressions are why the property system doesn’t have data binding, styling, or inheritance hard coded, but rather provided by later layers within the framework.</span></span>  
  
 <span data-ttu-id="6af0a-152">プロパティ システムでは、プロパティ値のスパース ストレージも提供されます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-152">The property system also provides for sparse storage of property values.</span></span> <span data-ttu-id="6af0a-153">オブジェクトには (何百とまではいかなくても) 何十ものプロパティがある場合があり、ほとんどの値は既定の状態 (継承、スタイルによる設定など) であるため、オブジェクトのすべてのインスタンスで、定義されているすべてのプロパティを重視する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="6af0a-153">Because objects can have dozens (if not hundreds) of properties, and most of the values are in their default state (inherited, set by styles, etc.), not every instance of an object needs to have the full weight of every property defined on it.</span></span>  
  
 <span data-ttu-id="6af0a-154">プロパティ システムの最後の新機能は、添付プロパティの概念です。</span><span class="sxs-lookup"><span data-stu-id="6af0a-154">The final new feature of the property system is the notion of attached properties.</span></span> <span data-ttu-id="6af0a-155">WPF の要素は、合成とコンポーネントの再利用の原則に基づいて構築されています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-155">WPF elements are built on the principle of composition and component reuse.</span></span> <span data-ttu-id="6af0a-156">多くの場合、含む側の要素 (<xref:System.Windows.Controls.Grid> レイアウト要素など) には、子要素の動作を制御するために、子要素についての追加データが必要です (行または列の情報など)。</span><span class="sxs-lookup"><span data-stu-id="6af0a-156">It is often the case that some containing element (like a <xref:System.Windows.Controls.Grid> layout element) needs additional data on child elements to control its behavior (like the Row/Column information).</span></span> <span data-ttu-id="6af0a-157">これらのすべてのプロパティをすべての要素と関連付けるのではなく、任意のオブジェクトで他のすべてのオブジェクトに対してプロパティ定義を提供できます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-157">Instead of associating all of these properties with every element, any object is allowed to provide property definitions for any other object.</span></span> <span data-ttu-id="6af0a-158">これは、JavaScript の "expando" 機能に似ています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-158">This is similar to the "expando" features of JavaScript.</span></span>  
  
<a name="System_Windows_Media_Visual"></a>
## <a name="systemwindowsmediavisual"></a><span data-ttu-id="6af0a-159">System.Windows.Media.Visual</span><span class="sxs-lookup"><span data-stu-id="6af0a-159">System.Windows.Media.Visual</span></span>  
 <span data-ttu-id="6af0a-160">システムが定義されたら、次のステップは画面にピクセルを描画することです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-160">With a system defined, the next step is getting pixels drawn to the screen.</span></span> <span data-ttu-id="6af0a-161"><xref:System.Windows.Media.Visual> クラスでは、ビジュアル オブジェクトのツリーが構築されます。各オブジェクトには、必要に応じて、描画命令と、それらの命令 (クリッピング、変換など) のレンダリング方法に関するメタデータが含まれています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-161">The <xref:System.Windows.Media.Visual> class provides for building a tree of visual objects, each optionally containing drawing instructions and metadata about how to render those instructions (clipping, transformation, etc.).</span></span> <span data-ttu-id="6af0a-162"><xref:System.Windows.Media.Visual> は、非常に軽量で高い柔軟性を持つように設計されているため、ほとんどの機能ではパブリック API は公開されておらず、保護されたコールバック関数に大きく依存しています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-162"><xref:System.Windows.Media.Visual> is designed to be extremely lightweight and flexible, so most of the features have no public API exposure and rely heavily on protected callback functions.</span></span>  
  
 <span data-ttu-id="6af0a-163"><xref:System.Windows.Media.Visual> は、実際には WPF 合成システムへのエントリ ポイントです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-163"><xref:System.Windows.Media.Visual> is really the entry point to the WPF composition system.</span></span> <span data-ttu-id="6af0a-164"><xref:System.Windows.Media.Visual> は、マネージド API とアンマネージド milcore という 2 つのサブシステムの間の接続ポイントです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-164"><xref:System.Windows.Media.Visual> is the point of connection between these two subsystems, the managed API and the unmanaged milcore.</span></span>  
  
 <span data-ttu-id="6af0a-165">WPF では、milcore によって管理されるアンマネージド データ構造を走査することによってデータが表示されます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-165">WPF displays data by traversing the unmanaged data structures managed by the milcore.</span></span> <span data-ttu-id="6af0a-166">合成ノードと呼ばれるこれらの構造は、各ノードにレンダリング命令が含まれる階層表示ツリーを表します。</span><span class="sxs-lookup"><span data-stu-id="6af0a-166">These structures, called composition nodes, represent a hierarchical display tree with rendering instructions at each node.</span></span> <span data-ttu-id="6af0a-167">このツリー (次の図の右側に示されているもの) には、メッセージング プロトコルを使用することによってのみアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-167">This tree, illustrated on the right hand side of the figure below, is only accessible through a messaging protocol.</span></span>  
  
 <span data-ttu-id="6af0a-168">WPF のプログラミングでは、<xref:System.Windows.Media.Visual> 要素と派生型を作成します。それらは、このメッセージング プロトコルを使用して合成ツリーに対する内部的な通信を行います。</span><span class="sxs-lookup"><span data-stu-id="6af0a-168">When programming WPF, you create <xref:System.Windows.Media.Visual> elements, and derived types, which internally communicate to the composition tree through this messaging protocol.</span></span> <span data-ttu-id="6af0a-169">WPF の各 <xref:System.Windows.Media.Visual> では、合成ノードを作成しても (1 つまたは複数) 作成しなくてもかまいません。</span><span class="sxs-lookup"><span data-stu-id="6af0a-169">Each <xref:System.Windows.Media.Visual> in WPF may create one, none, or several composition nodes.</span></span>  
  
 <span data-ttu-id="6af0a-170">![Windows Presentation Foundation のビジュアル ツリー。](./media/wpf-architecture2.PNG "wpf_architecture2")</span><span class="sxs-lookup"><span data-stu-id="6af0a-170">![The Windows Presentation Foundation Visual Tree.](./media/wpf-architecture2.PNG "wpf_architecture2")</span></span>  
  
 <span data-ttu-id="6af0a-171">このアーキテクチャの詳細に関して、注意する必要がある非常に重要な点は、ビジュアルと描画命令のツリー全体がキャッシュされるということです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-171">There is a very important architectural detail to notice here – the entire tree of visuals and drawing instructions is cached.</span></span> <span data-ttu-id="6af0a-172">グラフィックスの用語を使うなら、WPF では保持されたレンダリング システムが使用されます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-172">In graphics terms, WPF uses a retained rendering system.</span></span> <span data-ttu-id="6af0a-173">これにより、合成システムはユーザー コードへのコールバックでブロックされず、システムでは高いリフレッシュ レートでを再描画できます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-173">This enables the system to repaint at high refresh rates without the composition system blocking on callbacks to user code.</span></span> <span data-ttu-id="6af0a-174">これにより、アプリケーションの表示が応答しなくなるのを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-174">This helps prevent the appearance of an unresponsive application.</span></span>  
  
 <span data-ttu-id="6af0a-175">図ではわかりませんが、システムによって実際に合成が行われる方法も重要です。</span><span class="sxs-lookup"><span data-stu-id="6af0a-175">Another important detail that isn’t really noticeable in the diagram is how the system actually performs composition.</span></span>  
  
 <span data-ttu-id="6af0a-176">User32 と GDI では、システムはイミディエイト モードのクリッピング システムで動作します。</span><span class="sxs-lookup"><span data-stu-id="6af0a-176">In User32 and GDI, the system works on an immediate mode clipping system.</span></span> <span data-ttu-id="6af0a-177">コンポーネントのレンダリングが必要な場合は、それより外側のピクセルはコンポーネントで変更できないクリッピング境界がシステムによって確立された後、そのボックス内のピクセルの描画がコンポーネントに対して要求されます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-177">When a component needs to be rendered, the system establishes a clipping bounds outside of which the component isn’t allowed to touch the pixels, and then the component is asked to paint pixels in that box.</span></span> <span data-ttu-id="6af0a-178">このシステムは、操作する必要があるのは影響を受けるコンポーネントだけであり、2 つのコンポーネントが 1 つのピクセルの色に関与することがないため、メモリに制約のあるシステムで非常にうまく動作します。</span><span class="sxs-lookup"><span data-stu-id="6af0a-178">This system works very well in memory constrained systems because when something changes you only have to touch the affected component – no two components ever contribute to the color of a single pixel.</span></span>  
  
 <span data-ttu-id="6af0a-179">WPF では、"ペインター アルゴリズム" 描画モデルが使用されます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-179">WPF uses a "painter's algorithm" painting model.</span></span> <span data-ttu-id="6af0a-180">これは、各コンポーネントをクリッピングするのではなく、表示を背面から前面にレンダリングするよう各コンポーネントに要求することを意味します。</span><span class="sxs-lookup"><span data-stu-id="6af0a-180">This means that instead of clipping each component, each component is asked to render from the back to the front of the display.</span></span> <span data-ttu-id="6af0a-181">これにより、各コンポーネントでは前のコンポーネントの表示に重ねて描画できます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-181">This allows each component to paint over the previous component's display.</span></span> <span data-ttu-id="6af0a-182">このモデルの利点は、複雑で部分的に透明な形状を作成できることです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-182">The advantage of this model is that you can have complex, partially transparent shapes.</span></span> <span data-ttu-id="6af0a-183">現在の最新のグラフィックス ハードウェアを使えば、このモデルを比較的高速に実行できます (User32 と GDI が作成された当時では不可能でした)。</span><span class="sxs-lookup"><span data-stu-id="6af0a-183">With today’s modern graphics hardware, this model is relatively fast (which wasn’t the case when User32/ GDI were created).</span></span>  
  
 <span data-ttu-id="6af0a-184">前に説明したように、WPF の中核となる理念は、より宣言的な "プロパティ中心" のプログラミング モデルに移行することです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-184">As mentioned previously, a core philosophy of WPF is to move to a more declarative, "property centric" model of programming.</span></span> <span data-ttu-id="6af0a-185">ビジュアル システムでは、これに関して興味深い点が 2 つあります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-185">In the visual system, this shows up in a couple of interesting places.</span></span>  
  
 <span data-ttu-id="6af0a-186">1 つ目は、保持モード グラフィックス システムについて考えると、これにより命令型の DrawLine/DrawLine 型モデルからデータ指向モデルの new Line()/new Line() に実際に移行しています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-186">First, if you think about the retained mode graphic system, this is really moving away from an imperative DrawLine/DrawLine type model, to a data oriented model – new Line()/new Line().</span></span> <span data-ttu-id="6af0a-187">このデータ駆動型レンダリングへの移行により、描画命令での複雑な操作を、プロパティを使用して表すことができます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-187">This move to data driven rendering allows complex operations on the drawing instructions to be expressed using properties.</span></span> <span data-ttu-id="6af0a-188"><xref:System.Windows.Media.Drawing> から派生する型は、実質的にレンダリングのためのオブジェクト モデルです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-188">The types deriving from <xref:System.Windows.Media.Drawing> are effectively the object model for rendering.</span></span>  
  
 <span data-ttu-id="6af0a-189">2 つ目は、アニメーション システムを評価すると、ほぼ完全に宣言型であることがわかります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-189">Second, if you evaluate the animation system, you'll see that it is almost completely declarative.</span></span> <span data-ttu-id="6af0a-190">開発者は、次の位置や次の色を計算する必要はなく、アニメーション オブジェクトの一連のプロパティとしてアニメーションを表現できます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-190">Instead of requiring a developer to compute the next location, or next color, you can express animations as a set of properties on an animation object.</span></span> <span data-ttu-id="6af0a-191">これらのアニメーションでは開発者またはデザイナーの意図を表すことができ (このボタンをここからそこまで 5 秒で移動する)、それを実現するための最も効率的な方法をシステムで決定することができます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-191">These animations can then express the intent of the developer or designer (move this button from here to there in 5 seconds), and the system can determine the most efficient way to accomplish that.</span></span>  
  
<a name="System_Windows_UIElement"></a>
## <a name="systemwindowsuielement"></a><span data-ttu-id="6af0a-192">System.Windows.UIElement</span><span class="sxs-lookup"><span data-stu-id="6af0a-192">System.Windows.UIElement</span></span>  
 <span data-ttu-id="6af0a-193"><xref:System.Windows.UIElement> では、レイアウト、入力、イベントなどのコア サブシステムが定義されています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-193"><xref:System.Windows.UIElement> defines core subsystems including Layout, Input, and Events.</span></span>  
  
 <span data-ttu-id="6af0a-194">レイアウトは、WPF での主要な概念です。</span><span class="sxs-lookup"><span data-stu-id="6af0a-194">Layout is a core concept in WPF.</span></span> <span data-ttu-id="6af0a-195">多くのシステムでは、レイアウト モデルのセットは固定されているか (HTML でサポートされているレイアウトのモデルは、フロー、絶対、テーブルの 3 つです)、レイアウトのモデルがありません (User32 では絶対配置のみがサポートされています)。</span><span class="sxs-lookup"><span data-stu-id="6af0a-195">In many systems there is either a fixed set of layout models (HTML supports three models for layout; flow, absolute, and tables) or no model for layout (User32 really only supports absolute positioning).</span></span> <span data-ttu-id="6af0a-196">WPF は、開発者やデザイナーは柔軟で拡張性のあるレイアウト モデルを必要としており、それは命令型ロジックではなくプロパティ値によって駆動される、という前提から始まりました。</span><span class="sxs-lookup"><span data-stu-id="6af0a-196">WPF started with the assumption that developers and designers wanted a flexible, extensible layout model, which could be driven by property values rather than imperative logic.</span></span> <span data-ttu-id="6af0a-197"><xref:System.Windows.UIElement> レベルで、レイアウトのための基本的なコントラクトが導入されています。それは、<xref:System.Windows.UIElement.Measure%2A> パスと <xref:System.Windows.UIElement.Arrange%2A> パスによる 2 フェーズ モデルです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-197">At the <xref:System.Windows.UIElement> level, the basic contract for layout is introduced – a two phase model with <xref:System.Windows.UIElement.Measure%2A> and <xref:System.Windows.UIElement.Arrange%2A> passes.</span></span>  
  
 <span data-ttu-id="6af0a-198"><xref:System.Windows.UIElement.Measure%2A> を使うと、必要なサイズをコンポーネントで決定できます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-198"><xref:System.Windows.UIElement.Measure%2A> allows a component to determine how much size it would like to take.</span></span> <span data-ttu-id="6af0a-199">親要素が子に対して最適な位置とサイズを決定するための測定を何回も要求することがよくあるので、これは <xref:System.Windows.UIElement.Arrange%2A> とは別のフェーズになっています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-199">This is a separate phase from <xref:System.Windows.UIElement.Arrange%2A> because there are many situations where a parent element will ask a child to measure several times to determine its optimal position and size.</span></span> <span data-ttu-id="6af0a-200">親要素が子要素に測定を要求するという事実は、WPF のもう 1 つの重要な理念である "コンテンツのサイズに合わせる" ことを示しています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-200">The fact that parent elements ask child elements to measure demonstrates another key philosophy of WPF – size to content.</span></span> <span data-ttu-id="6af0a-201">WPF のすべてのコントロールは、そのコンテンツの自然なサイズに合わせてサイズを決定することができます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-201">All controls in WPF support the ability to size to the natural size of their content.</span></span> <span data-ttu-id="6af0a-202">これにより、ローカライズがはるかに簡単になり、要素のサイズ変更に合わせて動的なレイアウトを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-202">This makes localization much easier, and allows for dynamic layout of elements as things resize.</span></span> <span data-ttu-id="6af0a-203"><xref:System.Windows.UIElement.Arrange%2A> フェーズでは、親は各子を配置し、その最終的なサイズを決定できます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-203">The <xref:System.Windows.UIElement.Arrange%2A> phase allows a parent to position and determine the final size of each child.</span></span>  
  
 <span data-ttu-id="6af0a-204">WPF の出力側である <xref:System.Windows.Media.Visual> と関連オブジェクトについては、多くの時間をかけて説明されることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-204">A lot of time is often spent talking about the output side of WPF – <xref:System.Windows.Media.Visual> and related objects.</span></span> <span data-ttu-id="6af0a-205">しかし、入力側にも非常に多くのイノベーションがあります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-205">However there is a tremendous amount of innovation on the input side as well.</span></span> <span data-ttu-id="6af0a-206">おそらく、WPF の入力モデルにおける最も基本的な変更点は、入力イベントがシステム内をルーティングされる一貫したモデルです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-206">Probably the most fundamental change in the input model for WPF is the consistent model by which input events are routed through the system.</span></span>  
  
 <span data-ttu-id="6af0a-207">入力は、カーネル モード デバイス ドライバーの信号として生成され、Windows カーネルと User32 が関係する複雑なプロセスを通して、正しいプロセスとスレッドにルーティングされます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-207">Input originates as a signal on a kernel mode device driver and gets routed to the correct process and thread through an intricate process involving the Windows kernel and User32.</span></span> <span data-ttu-id="6af0a-208">入力に対応する User32 メッセージは、WPF にルーティングされると、WPF の生の入力メッセージに変換されて、ディスパッチャーに送信されます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-208">Once the User32 message corresponding to the input is routed to WPF, it is converted into a WPF raw input message and sent to the dispatcher.</span></span> <span data-ttu-id="6af0a-209">WPF では、生の入力イベントを複数の実際のイベントに変換することができ、これにより、"MouseEnter" のような機能を、配信が保証された低レベルのシステムで実装できます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-209">WPF allows for raw input events to be converted to multiple actual events, enabling features like "MouseEnter" to be implemented at a low level of the system with guaranteed delivery.</span></span>  
  
 <span data-ttu-id="6af0a-210">各入力イベントは、少なくとも 2 つのイベント ("プレビュー" イベントと実際のイベント) に変換されます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-210">Each input event is converted to at least two events – a "preview" event and the actual event.</span></span> <span data-ttu-id="6af0a-211">WPF のすべてのイベントには、要素ツリーを通じたルーティングの概念があります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-211">All events in WPF have a notion of routing through the element tree.</span></span> <span data-ttu-id="6af0a-212">イベントがターゲットからツリーを上方にルートまで移動する場合は "バブル" と呼ばれ、ルートから開始してターゲットまで下方に移動する場合は "トンネル" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-212">Events are said to "bubble" if they traverse from a target up the tree to the root, and are said to "tunnel" if they start at the root and traverse down to a target.</span></span> <span data-ttu-id="6af0a-213">入力プレビュー イベントがトンネルされると、ツリー内の任意の要素でイベントをフィルター処理したり、イベントに対するアクションを実行したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-213">Input preview events tunnel, enabling any element in the tree an opportunity to filter or take action on the event.</span></span> <span data-ttu-id="6af0a-214">その場合、通常の (プレビューではない) イベントが、ターゲットからルートまでバブルされます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-214">The regular (non-preview) events then bubble from the target up to the root.</span></span>  
  
 <span data-ttu-id="6af0a-215">トンネル フェーズとバブル フェーズのこのような分割により、キーボード アクセラレータなどの機能の実装が、複合環境で一貫した方法で動作します。</span><span class="sxs-lookup"><span data-stu-id="6af0a-215">This split between the tunnel and bubble phase makes implementation of features like keyboard accelerators work in a consistent fashion in a composite world.</span></span> <span data-ttu-id="6af0a-216">User32 では、サポートするすべてのアクセラレータ (Ctrl + N から "新規作成" へのマッピングなど) が含まれる単一のグローバル テーブルを作成することにより、キーボード アクセラレータを実装します。</span><span class="sxs-lookup"><span data-stu-id="6af0a-216">In User32 you would implement keyboard accelerators by having a single global table containing all the accelerators you wanted to support (Ctrl+N mapping to "New").</span></span> <span data-ttu-id="6af0a-217">アプリケーションのディスパッチャーでは **TranslateAccelerator** を呼び出します。これにより、User32 の入力メッセージが傍受され、登録されているアクセラレータに一致するものがあるかどうかが判定されます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-217">In the dispatcher for your application you would call **TranslateAccelerator** which would sniff the input messages in User32 and determine if any matched a registered accelerator.</span></span> <span data-ttu-id="6af0a-218">WPF では、システムが完全に "構成可能" であるため、この機能は動作しません。すべての要素で任意のキーボード アクセラレータを処理および使用できます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-218">In WPF this wouldn’t work because the system is fully "composable" – any element can handle and use any keyboard accelerator.</span></span> <span data-ttu-id="6af0a-219">入力に対するこの 2 フェーズ モデルにより、コンポーネントで独自の "TranslateAccelerator" を実装できます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-219">Having this two phase model for input allows components to implement their own "TranslateAccelerator".</span></span>  
  
 <span data-ttu-id="6af0a-220">これをさらに 1 歩進めるため、<xref:System.Windows.UIElement> では CommandBindings の概念も導入されています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-220">To take this one step further, <xref:System.Windows.UIElement> also introduces the notion of CommandBindings.</span></span> <span data-ttu-id="6af0a-221">WPF のコマンド システムを使うと、開発者は、コマンド エンド ポイント (<xref:System.Windows.Input.ICommand> を実装するもの) の観点から機能を定義できます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-221">The WPF command system allows developers to define functionality in terms of a command end point – something that implements <xref:System.Windows.Input.ICommand>.</span></span> <span data-ttu-id="6af0a-222">コマンド バインドにより、要素で入力ジェスチャ (Ctrl + N) とコマンド (新規作成) の間のマッピングを定義できます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-222">Command bindings enable an element to define a mapping between an input gesture (Ctrl+N) and a command (New).</span></span> <span data-ttu-id="6af0a-223">入力ジェスチャとコマンド定義はどちらも拡張可能であり、使用時に結び付けることができます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-223">Both the input gestures and command definitions are extensible, and can be wired together at usage time.</span></span> <span data-ttu-id="6af0a-224">これにより、たとえば、エンド ユーザーがアプリケーション内で使用するキー バインドをカスタマイズできるようにすることが簡単になります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-224">This makes it trivial, for example, to allow an end user to customize the key bindings that they want to use within an application.</span></span>  
  
 <span data-ttu-id="6af0a-225">ここまでは、WPF の "コア" 機能 (PresentationCore アセンブリで実装されている機能) に注目してきました。</span><span class="sxs-lookup"><span data-stu-id="6af0a-225">To this point in the topic, "core" features of WPF – features implemented in the PresentationCore assembly, have been the focus.</span></span> <span data-ttu-id="6af0a-226">WPF の構築において、基本要素 (**Measure** と **Arrange** によるレイアウトのコントラクトなど) とフレームワーク要素 (<xref:System.Windows.Controls.Grid> のような特定のレイアウトの実装など) の明確な分離は、望ましい結果でした。</span><span class="sxs-lookup"><span data-stu-id="6af0a-226">When building WPF, a clean separation between foundational pieces (like the contract for layout with **Measure** and **Arrange**) and framework pieces (like the implementation of a specific layout like <xref:System.Windows.Controls.Grid>) was the desired outcome.</span></span> <span data-ttu-id="6af0a-227">目標は、外部の開発者が必要に応じて独自のフレームワークを作成できるようにする拡張ポイントを、スタックの低い部分で提供することでした。</span><span class="sxs-lookup"><span data-stu-id="6af0a-227">The goal was to provide an extensibility point low in the stack that would allow external developers to create their own frameworks if needed.</span></span>  
  
<a name="System_Windows_FrameworkElement"></a>
## <a name="systemwindowsframeworkelement"></a><span data-ttu-id="6af0a-228">System.Windows.FrameworkElement</span><span class="sxs-lookup"><span data-stu-id="6af0a-228">System.Windows.FrameworkElement</span></span>  
 <span data-ttu-id="6af0a-229"><xref:System.Windows.FrameworkElement> には、異なる 2 つの見方があります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-229"><xref:System.Windows.FrameworkElement> can be looked at in two different ways.</span></span> <span data-ttu-id="6af0a-230">まず、WPF の下位レベルで導入されたサブシステムに対する一連のポリシーとカスタマイズが導入されています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-230">It introduces a set of policies and customizations on the subsystems introduced in lower layers of WPF.</span></span> <span data-ttu-id="6af0a-231">また、一連の新しいサブシステムも導入されています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-231">It also introduces a set of new subsystems.</span></span>  
  
 <span data-ttu-id="6af0a-232"><xref:System.Windows.FrameworkElement> によって導入される主なポリシーは、アプリケーションのレイアウトに関するものです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-232">The primary policy introduced by <xref:System.Windows.FrameworkElement> is around application layout.</span></span> <span data-ttu-id="6af0a-233"><xref:System.Windows.FrameworkElement> は <xref:System.Windows.UIElement> によって導入された基本的なレイアウト コントラクトが基になっており、レイアウトの作成者がプロパティ駆動のレイアウト セマンティクスの一貫したセットを簡単に使用できるレイアウト "スロット" の概念が追加されています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-233"><xref:System.Windows.FrameworkElement> builds on the basic layout contract introduced by <xref:System.Windows.UIElement> and adds the notion of a layout "slot" that makes it easier for layout authors to have a consistent set of property driven layout semantics.</span></span> <span data-ttu-id="6af0a-234"><xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>、<xref:System.Windows.FrameworkElement.VerticalAlignment%2A>、<xref:System.Windows.FrameworkElement.MinWidth%2A>、<xref:System.Windows.FrameworkElement.Margin%2A> のようなプロパティ (一例です) により、<xref:System.Windows.FrameworkElement> から派生するすべてのコンポーネントに、レイアウト コンテナー内での一貫した動作が提供されます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-234">Properties like <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, and <xref:System.Windows.FrameworkElement.Margin%2A> (to name a few) give all components derived from <xref:System.Windows.FrameworkElement> consistent behavior inside of layout containers.</span></span>  
  
 <span data-ttu-id="6af0a-235"><xref:System.Windows.FrameworkElement> では、また、WPF のコア レイヤーにある多くの機能に対する API の公開も容易になります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-235"><xref:System.Windows.FrameworkElement> also provides easier API exposure to many features found in the core layers of WPF.</span></span> <span data-ttu-id="6af0a-236">たとえば、<xref:System.Windows.FrameworkElement> を使うと、<xref:System.Windows.FrameworkElement.BeginStoryboard%2A> メソッドを通してアニメーションに直接アクセスできます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-236">For example, <xref:System.Windows.FrameworkElement> provides direct access to animation through the <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> method.</span></span> <span data-ttu-id="6af0a-237"><xref:System.Windows.Media.Animation.Storyboard> により、一連のプロパティに対する複数のアニメーションをスクリプト化する方法が提供されます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-237">A <xref:System.Windows.Media.Animation.Storyboard> provides a way to script multiple animations against a set of properties.</span></span>  
  
 <span data-ttu-id="6af0a-238"><xref:System.Windows.FrameworkElement> によって導入された最も重要な 2 つのことは、データ バインディングとスタイルです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-238">The two most critical things that <xref:System.Windows.FrameworkElement> introduces are data binding and styles.</span></span>  
  
 <span data-ttu-id="6af0a-239">WPF のデータ バインディング サブシステムは、Windows フォームまたは ASP.NET を使用してアプリケーションの[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] を作成してきた開発者にとっては、比較的なじみがあるはずです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-239">The data binding subsystem in WPF should be relatively familiar to anyone that has used Windows Forms or ASP.NET for creating an application [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="6af0a-240">これらの各システムには、特定の要素の 1 つ以上のプロパティをデータにバインドする必要があることを表すための簡単な方法があります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-240">In each of these systems, there is a simple way to express that you want one or more properties from a given element to be bound to a piece of data.</span></span> <span data-ttu-id="6af0a-241">WPF では、プロパティ バインディング、変換、およびリスト バインディングが完全にサポートされています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-241">WPF has full support for property binding, transformation, and list binding.</span></span>  
  
 <span data-ttu-id="6af0a-242">WPF でのデータ バインディングの最も興味深い機能の 1 つは、データ テンプレートの導入です。</span><span class="sxs-lookup"><span data-stu-id="6af0a-242">One of the most interesting features of data binding in WPF is the introduction of data templates.</span></span> <span data-ttu-id="6af0a-243">データ テンプレートを使うと、データの一部を視覚化する方法を宣言によって指定できます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-243">Data templates allow you to declaratively specify how a piece of data should be visualized.</span></span> <span data-ttu-id="6af0a-244">データにバインドできるカスタム ユーザー インターフェイスを作成する代わりに、問題を転換して、作成される表示をデータで決定できるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-244">Instead of creating a custom user interface that can be bound to data, you can instead turn the problem around and let the data determine the display that will be created.</span></span>  
  
 <span data-ttu-id="6af0a-245">スタイルは、実際には軽量な形式のデータ バインディングです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-245">Styling is really a lightweight form of data binding.</span></span> <span data-ttu-id="6af0a-246">スタイルを使用すると、共有定義のプロパティのセットを、要素の 1 つ以上のインスタンスにバインドできます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-246">Using styling you can bind a set of properties from a shared definition to one or more instances of an element.</span></span> <span data-ttu-id="6af0a-247">スタイルは、明示的な参照によって (<xref:System.Windows.FrameworkElement.Style%2A> プロパティを設定することにより)、またはスタイルを要素の CLR 型に関連付けることによって暗黙的に、要素に適用されます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-247">Styles get applied to an element either by explicit reference (by setting the <xref:System.Windows.FrameworkElement.Style%2A> property) or implicitly by associating a style with the CLR type of the element.</span></span>  
  
<a name="System_Windows_Controls_Control"></a>
## <a name="systemwindowscontrolscontrol"></a><span data-ttu-id="6af0a-248">System.Windows.Controls.Control</span><span class="sxs-lookup"><span data-stu-id="6af0a-248">System.Windows.Controls.Control</span></span>  
 <span data-ttu-id="6af0a-249">Control の最も重要な機能はテンプレートです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-249">Control’s most significant feature is templating.</span></span> <span data-ttu-id="6af0a-250">WPF の合成システムを保持モードのレンダリング システムと考えた場合、テンプレートを使用すると、パラメーター化された宣言型の方法によりコントロールでレンダリングを記述できます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-250">If you think about WPF’s composition system as a retained mode rendering system, templating allows a control to describe its rendering in a parameterized, declarative manner.</span></span> <span data-ttu-id="6af0a-251"><xref:System.Windows.Controls.ControlTemplate> は、コントロールによって提供されるプロパティにバインドされる子要素のセットを作成するためのスクリプトにすぎません。</span><span class="sxs-lookup"><span data-stu-id="6af0a-251">A <xref:System.Windows.Controls.ControlTemplate> is really nothing more than a script to create a set of child elements, with bindings to properties offered by the control.</span></span>  
  
 <span data-ttu-id="6af0a-252"><xref:System.Windows.Controls.Control> では、<xref:System.Windows.Controls.Control.Foreground%2A>、<xref:System.Windows.Controls.Control.Background%2A>、<xref:System.Windows.Controls.Control.Padding%2A> などのストック プロパティのセットが提供されています。テンプレート作成者はそれを使用して、コントロールの表示をカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-252"><xref:System.Windows.Controls.Control> provides a set of stock properties, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A>, to name a few, which template authors can then use to customize the display of a control.</span></span> <span data-ttu-id="6af0a-253">コントロールの実装では、データ モデルと相互作用モデルが提供されています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-253">The implementation of a control provides a data model and interaction model.</span></span> <span data-ttu-id="6af0a-254">相互作用モデルでは、一連のコマンド (ウィンドウの [閉じる] など) と、入力ジェスチャ (ウィンドウの上の隅にある赤い X のクリックなど) に対するバインドが定義されています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-254">The interaction model defines a set of commands (like Close for a window) and bindings to input gestures (like clicking the red X in the upper corner of the window).</span></span> <span data-ttu-id="6af0a-255">データ モデルには、相互作用モデルまたは表示をカスタマイズするためのプロパティのセットが用意されています (テンプレートによって決定されます)。</span><span class="sxs-lookup"><span data-stu-id="6af0a-255">The data model provides a set of properties to either customize the interaction model or customize the display (determined by the template).</span></span>  
  
 <span data-ttu-id="6af0a-256">データ モデル (プロパティ)、相互作用モデル (コマンドとイベント)、表示モデル (テンプレート) のこのような分離により、コントロールの外観と動作を完全にカスタマイズできるようになります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-256">This split between the data model (properties), interaction model (commands and events), and display model (templates) enables complete customization of a control’s look and behavior.</span></span>  
  
 <span data-ttu-id="6af0a-257">コントロールのデータ モデルの一般的な側面はコンテンツ モデルです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-257">A common aspect of the data model of controls is the content model.</span></span> <span data-ttu-id="6af0a-258"><xref:System.Windows.Controls.Button> のようなコントロールを見ると、"Content" という名前の <xref:System.Object> 型のプロパティがあることがわかります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-258">If you look at a control like <xref:System.Windows.Controls.Button>, you will see that it has a property named "Content" of type <xref:System.Object>.</span></span> <span data-ttu-id="6af0a-259">Windows フォームと ASP.NET では、通常、このプロパティは文字列ですが、それによりボタンに配置できる内容の型が制限されます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-259">In Windows Forms and ASP.NET, this property would typically be a string – however that limits the type of content you can put in a button.</span></span> <span data-ttu-id="6af0a-260">ボタンの内容には、単純な文字列、複雑なデータ オブジェクト、または要素ツリー全体のいずれかを使用できます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-260">Content for a button can either be a simple string, a complex data object, or an entire element tree.</span></span> <span data-ttu-id="6af0a-261">データ オブジェクトの場合は、データ テンプレートを使用して表示を作成します。</span><span class="sxs-lookup"><span data-stu-id="6af0a-261">In the case of a data object, the data template is used to construct a display.</span></span>  
  
<a name="Summary"></a>
## <a name="summary"></a><span data-ttu-id="6af0a-262">まとめ</span><span class="sxs-lookup"><span data-stu-id="6af0a-262">Summary</span></span>  
 <span data-ttu-id="6af0a-263">WPF は、動的でデータ駆動型のプレゼンテーション システムを作成できるように設計されています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-263">WPF is designed to allow you to create dynamic, data driven presentation systems.</span></span> <span data-ttu-id="6af0a-264">システムのすべての部分は、動作を駆動するプロパティ セットを通じてオブジェクトを作成するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-264">Every part of the system is designed to create objects through property sets that drive behavior.</span></span> <span data-ttu-id="6af0a-265">データ バインディングはシステムの基本的な部分であり、すべてのレイヤーで統合されています。</span><span class="sxs-lookup"><span data-stu-id="6af0a-265">Data binding is a fundamental part of the system, and is integrated at every layer.</span></span>  
  
 <span data-ttu-id="6af0a-266">従来のアプリケーションでは、表示を作成してから、何らかのデータにバインドします。</span><span class="sxs-lookup"><span data-stu-id="6af0a-266">Traditional applications create a display and then bind to some data.</span></span> <span data-ttu-id="6af0a-267">WPF では、コントロールに関するすべてのことと表示のすべての側面は、何らかの種類のデータ バインディングによって生成されます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-267">In WPF, everything about the control, every aspect of the display, is generated by some type of data binding.</span></span> <span data-ttu-id="6af0a-268">ボタン内に表示されるテキストは、ボタン内に合成コントロールを作成し、その表示をボタンのコンテンツ プロパティにバインドすることによって表示されます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-268">The text found inside a button is displayed by creating a composed control inside of the button and binding its display to the button’s content property.</span></span>  
  
 <span data-ttu-id="6af0a-269">WPF ベースのアプリケーションの開発を始めれば、非常に馴染みのあるものに感じるはずです。</span><span class="sxs-lookup"><span data-stu-id="6af0a-269">When you begin developing WPF based applications, it should feel very familiar.</span></span> <span data-ttu-id="6af0a-270">プロパティの設定、オブジェクトの使用、データのバインドは、Windows フォームまたは ASP.NET を使用するのとよく似た方法で行うことができます。</span><span class="sxs-lookup"><span data-stu-id="6af0a-270">You can set properties, use objects, and data bind in much the same way that you can using Windows Forms or ASP.NET.</span></span> <span data-ttu-id="6af0a-271">WPF のアーキテクチャについてさらに詳しく調べれば、アプリケーションのコア ドライバーとしてデータを基本的に扱う、よりリッチなアプリケーションを作成できる可能性があることがわかります。</span><span class="sxs-lookup"><span data-stu-id="6af0a-271">With a deeper investigation into the architecture of WPF, you'll find that the possibility exists for creating much richer applications that fundamentally treat data as the core driver of the application.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6af0a-272">関連項目</span><span class="sxs-lookup"><span data-stu-id="6af0a-272">See also</span></span>

- <xref:System.Windows.Media.Visual>
- <xref:System.Windows.UIElement>
- <xref:System.Windows.Input.ICommand>
- <xref:System.Windows.FrameworkElement>
- <xref:System.Windows.Threading.DispatcherObject>
- <xref:System.Windows.Input.CommandBinding>
- <xref:System.Windows.Controls.Control>
- [<span data-ttu-id="6af0a-273">データ バインディングの概要</span><span class="sxs-lookup"><span data-stu-id="6af0a-273">Data Binding Overview</span></span>](../../../desktop-wpf/data/data-binding-overview.md)
- [<span data-ttu-id="6af0a-274">レイアウト</span><span class="sxs-lookup"><span data-stu-id="6af0a-274">Layout</span></span>](layout.md)
- [<span data-ttu-id="6af0a-275">アニメーションの概要</span><span class="sxs-lookup"><span data-stu-id="6af0a-275">Animation Overview</span></span>](../graphics-multimedia/animation-overview.md)
