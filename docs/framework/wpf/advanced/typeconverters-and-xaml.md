---
title: TypeConverters および XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: 94cfce44d5702e0550310723ec56184096165436
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187291"
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="09735-102">TypeConverters および XAML</span><span class="sxs-lookup"><span data-stu-id="09735-102">TypeConverters and XAML</span></span>
<span data-ttu-id="09735-103">このトピックでは、XAML の一般的な言語機能としての文字列からの型変換の目的について説明します。</span><span class="sxs-lookup"><span data-stu-id="09735-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="09735-104">.NET Framework では、<xref:System.ComponentModel.TypeConverter> クラスは、XAML 属性を使用するときにプロパティ値として使用できるマネージド カスタム クラスの実装の一部として、特定の目的を果たします。</span><span class="sxs-lookup"><span data-stu-id="09735-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="09735-105">カスタム クラスを作成するときに、クラスのインスタンスを XAML で設定可能な属性値として使用できるようにする場合は、クラスに <xref:System.ComponentModel.TypeConverterAttribute> を適用するか、カスタム <xref:System.ComponentModel.TypeConverter> クラスを記述するか、またはその両方を行うことが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="09735-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  

## <a name="type-conversion-concepts"></a><span data-ttu-id="09735-106">型変換の概念</span><span class="sxs-lookup"><span data-stu-id="09735-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="09735-107">XAML と文字列値</span><span class="sxs-lookup"><span data-stu-id="09735-107">XAML and String Values</span></span>  
 <span data-ttu-id="09735-108">XAML ファイルで属性値を設定する場合、その値の最初の型は純粋なテキストの文字列です。</span><span class="sxs-lookup"><span data-stu-id="09735-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="09735-109"><xref:System.Double> など、その他のプリミティブも、XAML プロセッサに対して最初はテキスト文字列です。</span><span class="sxs-lookup"><span data-stu-id="09735-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="09735-110">XAML プロセッサでは、属性値を処理するために 2 つの情報が必要です。</span><span class="sxs-lookup"><span data-stu-id="09735-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="09735-111">第 1 の情報は、設定しようとしているプロパティの値の型です。</span><span class="sxs-lookup"><span data-stu-id="09735-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="09735-112">属性値を定義するすべての文字列は、XAML で処理され、最終的にはその型の値に変換 (解決) される必要があります。</span><span class="sxs-lookup"><span data-stu-id="09735-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="09735-113">値が、XAML パーサーで認識できるプリミティブ (数値など) である場合は、文字列の直接的な変換が試みられます。</span><span class="sxs-lookup"><span data-stu-id="09735-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="09735-114">値が列挙型である場合、文字列は、その列挙型の名前付き定数と名前が一致するかどうかを確認するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="09735-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="09735-115">値がパーサーで認識されるプリミティブでも列挙型でもない場合、問題の型は、変換される文字列に基づく型または値のインスタンスを提供できるものである必要があります。</span><span class="sxs-lookup"><span data-stu-id="09735-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="09735-116">これを行うには、型コンバーター クラスを指定します。</span><span class="sxs-lookup"><span data-stu-id="09735-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="09735-117">型コンバーターは、実際には、XAML のシナリオと、場合によっては .NET コードでのコード呼び出しのシナリオの両方で、別のクラスの値を提供するためのヘルパー クラスです。</span><span class="sxs-lookup"><span data-stu-id="09735-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="09735-118">XAML での既存の型変換動作の使用</span><span class="sxs-lookup"><span data-stu-id="09735-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="09735-119">基になる XAML の概念に関する知識によっては、基本的なアプリケーションの XAML で型変換動作を既に意識せず使用している場合があります。</span><span class="sxs-lookup"><span data-stu-id="09735-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="09735-120">たとえば、WPF では、<xref:System.Windows.Point> 型の値を受け取る文字どおり数百のプロパティが定義されています。</span><span class="sxs-lookup"><span data-stu-id="09735-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="09735-121"><xref:System.Windows.Point> は、2 次元座標空間内の座標を表す値であり、実際に重要なプロパティは <xref:System.Windows.Point.X%2A> と <xref:System.Windows.Point.Y%2A> の 2 つだけです。</span><span class="sxs-lookup"><span data-stu-id="09735-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="09735-122">XAML でポイントを指定するときは、<xref:System.Windows.Point.X%2A> と <xref:System.Windows.Point.Y%2A> の値とそれらの間の区切り記号 (通常はコンマ) という文字列として指定します。</span><span class="sxs-lookup"><span data-stu-id="09735-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="09735-123">たとえば、`<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>` のように指定します。</span><span class="sxs-lookup"><span data-stu-id="09735-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span></span>  
  
 <span data-ttu-id="09735-124">このような単純型の <xref:System.Windows.Point> と XAML でのその簡単な使用でも、型コンバーターが必要です。</span><span class="sxs-lookup"><span data-stu-id="09735-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="09735-125">この場合のそれは <xref:System.Windows.PointConverter> クラスです。</span><span class="sxs-lookup"><span data-stu-id="09735-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="09735-126">クラス レベルで定義されている <xref:System.Windows.Point> の型コンバーターにより、<xref:System.Windows.Point> を受け取るすべてのプロパティをマークアップで簡単に使用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="09735-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="09735-127">この場合に型コンバーターがないと、前に示したのと同じ例に対し、次のようなはるかに冗長なマークアップが必要になります。</span><span class="sxs-lookup"><span data-stu-id="09735-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  

```xaml
<LinearGradientBrush>
  <LinearGradientBrush.StartPoint>
    <Point X="0" Y="0"/>
  </LinearGradientBrush.StartPoint>
  <LinearGradientBrush.EndPoint>
    <Point X="1" Y="1"/>
  </LinearGradientBrush.EndPoint>
</LinearGradientBrush>
 ```
  
 <span data-ttu-id="09735-128">型変換文字列を使用するか、より冗長な同等の構文を使用するかは、通常、コーディング スタイルとして選択することです。</span><span class="sxs-lookup"><span data-stu-id="09735-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="09735-129">XAML ツールのワークフローも、値の設定方法に影響を与える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="09735-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="09735-130">一部の XAML ツールでは、デザイナー ビューへのラウンドトリップや、独自のシリアル化メカニズムが簡単になるため、最も冗長な形式のマークアップが生成される傾向があります。</span><span class="sxs-lookup"><span data-stu-id="09735-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="09735-131">WPF および .NET Framework の型に対する既存の型コンバーターは、通常、<xref:System.ComponentModel.TypeConverterAttribute> が適用されているクラス (またはプロパティ) が存在するかどうかを調べることによって検出できます。</span><span class="sxs-lookup"><span data-stu-id="09735-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="09735-132">この属性では、XAML や他の目的で、その型の値をサポートする型コンバーターであるクラスに名前が付けられます。</span><span class="sxs-lookup"><span data-stu-id="09735-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="09735-133">型コンバーターとマークアップ拡張機能</span><span class="sxs-lookup"><span data-stu-id="09735-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="09735-134">マークアップ拡張機能と型コンバーターは、XAML プロセッサの動作と、それらが適用されるシナリオに関して、果たす役割が異なります。</span><span class="sxs-lookup"><span data-stu-id="09735-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="09735-135">マークアップ拡張機能の使用時にはコンテキストを利用できますが、マークアップ拡張機能が値を提供するプロパティの型変換動作は一般にマークアップ拡張機能の実装ではチェックされません。</span><span class="sxs-lookup"><span data-stu-id="09735-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="09735-136">つまり、マークアップ拡張機能で `ProvideValue` の出力としてテキスト文字列が返される場合でも、特定のプロパティまたはプロパティ値型に適用される、その文字列に対する型変換動作は呼び出されません。一般に、マークアップ拡張機能の目的は、型コンバーターを呼び出さずに文字列を処理してオブジェクトを返すことです。</span><span class="sxs-lookup"><span data-stu-id="09735-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="09735-137">型コンバーターではなくマークアップ拡張機能が必要になる一般的な状況の 1 つは、既に存在するオブジェクトを参照する場合です。</span><span class="sxs-lookup"><span data-stu-id="09735-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="09735-138">ステートレスな型コンバーターではせいぜい新しいインスタンスを生成することしかできないため、望ましくありません。</span><span class="sxs-lookup"><span data-stu-id="09735-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="09735-139">マークアップ拡張機能の詳細については、「[マークアップ拡張機能と WPF XAML](markup-extensions-and-wpf-xaml.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="09735-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="09735-140">ネイティブな型コンバーター</span><span class="sxs-lookup"><span data-stu-id="09735-140">Native Type Converters</span></span>  
 <span data-ttu-id="09735-141">XAML パーサーの WPF および .NET Framework による実装では、ネイティブな型変換処理が行われる特定の型がありますが、慣例としてプリミティブと考えられる可能性のある型はありません。</span><span class="sxs-lookup"><span data-stu-id="09735-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="09735-142">このような型の例として、 <xref:System.DateTime>が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="09735-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="09735-143">これの理由は、.NET Framework のアーキテクチャがどのように機能するかに基づきます。<xref:System.DateTime> 型は、.NET の最も基本的なライブラリである mscorlib で定義されています。</span><span class="sxs-lookup"><span data-stu-id="09735-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="09735-144"><xref:System.DateTime> の属性を設定する時は、別のアセンブリから来る属性を使用して従属関係を持ち込むことができません (<xref:System.ComponentModel.TypeConverterAttribute> は System から)。したがって、属性による通常の型コンバーターの検出機構はサポートできません。</span><span class="sxs-lookup"><span data-stu-id="09735-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="09735-145">代わりに、XAML パーサーでは、ネイティブな処理が必要な型の一覧が保持され、それらの型は通常のプリミティブの処理と類似した方法で処理されます。</span><span class="sxs-lookup"><span data-stu-id="09735-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="09735-146">(<xref:System.DateTime> の場合、これには <xref:System.DateTime.Parse%2A> の呼び出しが含まれます)。</span><span class="sxs-lookup"><span data-stu-id="09735-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>
## <a name="implementing-a-type-converter"></a><span data-ttu-id="09735-147">型コンバーターの実装</span><span class="sxs-lookup"><span data-stu-id="09735-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="09735-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="09735-148">TypeConverter</span></span>  
 <span data-ttu-id="09735-149">前に示した <xref:System.Windows.Point> の例では、<xref:System.Windows.PointConverter> クラスについて説明しました。</span><span class="sxs-lookup"><span data-stu-id="09735-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="09735-150">XAML の .NET による実装では、XAML の目的で使用されるすべての型コンバーターは、基底クラス <xref:System.ComponentModel.TypeConverter> から派生したクラスです。</span><span class="sxs-lookup"><span data-stu-id="09735-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="09735-151"><xref:System.ComponentModel.TypeConverter> クラスは、XAML が登場するより前のバージョンの .NET Framework に存在しました。その本来の用途の 1 つは、ビジュアル デザイナーのプロパティ ダイアログに文字列の変換を提供することでした。</span><span class="sxs-lookup"><span data-stu-id="09735-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="09735-152">XAML では、<xref:System.ComponentModel.TypeConverter> の役割が拡張され、文字列属性値の解析を有効にし、場合によっては特定のオブジェクト プロパティの実行時の値を属性としてシリアル化するために文字列に戻す処理を可能にする、文字列への変換および文字列からの変換のための基底クラスとして含まれるようになっています。</span><span class="sxs-lookup"><span data-stu-id="09735-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="09735-153"><xref:System.ComponentModel.TypeConverter> には、XAML を処理する目的で、文字列への変換と文字列からの変換に関連する次の 4 つのメンバーが定義されています。</span><span class="sxs-lookup"><span data-stu-id="09735-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="09735-154">それらの中で、最も重要なメソッドは <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> です。</span><span class="sxs-lookup"><span data-stu-id="09735-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="09735-155">このメソッドでは、入力文字列が必要なオブジェクト型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="09735-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="09735-156">厳密には、<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> メソッドを実装して、コンバーターで意図されている変換後の型に、より広範な型を変換することができます。これにより、実行時の変換のサポートなど、XAML の範囲を超えた目的まで拡張できます。XAML の目的は、対象の <xref:System.String> 入力を処理できるコード パスだけです。</span><span class="sxs-lookup"><span data-stu-id="09735-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="09735-157">次に重要なメソッドは <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> です。</span><span class="sxs-lookup"><span data-stu-id="09735-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="09735-158">アプリケーションがマークアップ表現に変換される場合 (たとえば、ファイルとして XAML に保存される場合)、<xref:System.ComponentModel.TypeConverter.ConvertTo%2A> でマークアップ表現を生成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="09735-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="09735-159">この場合、XAML にとって重要なコード パスは、<xref:System.String> の `destinationType` を渡すときです。</span><span class="sxs-lookup"><span data-stu-id="09735-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="09735-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> と <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> は、サービスが <xref:System.ComponentModel.TypeConverter> の実装の機能を照会する時に使用されるサポート メソッドです。</span><span class="sxs-lookup"><span data-stu-id="09735-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="09735-161">これらのメソッドは、その型について、相当する変換メソッドをコンバーターがサポートしている場合に `true` を返すように実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="09735-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="09735-162">XAML の目的では、通常、 <xref:System.String> 型であることを意味します。</span><span class="sxs-lookup"><span data-stu-id="09735-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="09735-163">カルチャ情報と XAML の型コンバーター</span><span class="sxs-lookup"><span data-stu-id="09735-163">Culture Information and Type Converters for XAML</span></span>  

 <span data-ttu-id="09735-164"><xref:System.ComponentModel.TypeConverter> の各実装では、変換に対して有効な文字列の構成内容を独自に解釈でき、パラメーターとして渡される型の説明を使用することも無視することもできます。</span><span class="sxs-lookup"><span data-stu-id="09735-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="09735-165">カルチャと XAML の型変換に関しては、重要な考慮事項があります。</span><span class="sxs-lookup"><span data-stu-id="09735-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="09735-166">属性値としてローカライズ可能な文字列を使用することは、XAML で完全にサポートされています。</span><span class="sxs-lookup"><span data-stu-id="09735-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="09735-167">ただし、そのローカライズ可能な文字列を特定のカルチャの要件で型コンバーターの入力として使用することはサポートされていません。これは、XAML 属性値の型コンバーターには、`en-US` カルチャを使用する固定言語の解析動作が含まれるためです。</span><span class="sxs-lookup"><span data-stu-id="09735-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="09735-168">この制限に関する設計上の理由の詳細については、XAML 言語の仕様 ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf)) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="09735-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span></span>  
  
 <span data-ttu-id="09735-169">カルチャが問題になる場合がある例として、一部のカルチャでは数値の小数点記号としてコンマが使用されます。</span><span class="sxs-lookup"><span data-stu-id="09735-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="09735-170">これは、多くの WPF XAML 型コンバーターでのコンマを区切り記号として使用する動作と競合します (一般的な X,Y 形式やコンマ区切りリストなどの歴史的前例に基づきます)。</span><span class="sxs-lookup"><span data-stu-id="09735-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="09735-171">周囲の XAML でカルチャを渡しても (小数点にコンマを使用するカルチャの例である `sl-SI` を `Language` または `xml:lang` に設定)、問題は解決されません。</span><span class="sxs-lookup"><span data-stu-id="09735-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="09735-172">ConvertFrom の実装</span><span class="sxs-lookup"><span data-stu-id="09735-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="09735-173">XAML をサポートする <xref:System.ComponentModel.TypeConverter> の実装としてコンバーターを使用できるようにするためには、そのコンバーターの <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> メソッドが `value` パラメーターとして文字列を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="09735-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="09735-174">文字列が有効な形式であり、<xref:System.ComponentModel.TypeConverter> の実装で変換できる場合、実装から返されるオブジェクトで、プロパティで想定される型へのキャストがサポートされている必要があります。</span><span class="sxs-lookup"><span data-stu-id="09735-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="09735-175">それ以外の場合、 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 実装は `null`を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="09735-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="09735-176"><xref:System.ComponentModel.TypeConverter> の各実装では、変換に対して有効な文字列の構成内容を独自に解釈でき、パラメーターとして渡される型の説明またはカルチャのコンテキストを使用することも無視することもできます。</span><span class="sxs-lookup"><span data-stu-id="09735-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="09735-177">ただし、WPF による XAML の処理では、型の説明のコンテキストに値が渡されない場合があり、`xml:lang` に基づくカルチャが渡されない場合もあります。</span><span class="sxs-lookup"><span data-stu-id="09735-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="09735-178">文字列形式の可能な要素として、中かっこ文字 { を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="09735-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="09735-179">これらの文字は、マークアップ拡張シーケンスの開始および終了を示す文字として予約されています。</span><span class="sxs-lookup"><span data-stu-id="09735-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="09735-180">ConvertTo の実装</span><span class="sxs-lookup"><span data-stu-id="09735-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="09735-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> は、シリアル化のサポートで使用される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="09735-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="09735-182">カスタム型およびその型コンバーターに対して <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> によるシリアル化をサポートすることは、絶対要件ではありません。</span><span class="sxs-lookup"><span data-stu-id="09735-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="09735-183">ただし、コントロールを実装する場合、またはクラスの機能または設計の一部としてシリアル化を使用する場合は、 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="09735-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="09735-184">XAML をサポートする <xref:System.ComponentModel.TypeConverter> の実装として使用できるようにするには、そのコンバーターの <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> メソッドで、サポートされる型 (または値) のインスタンスを `value` パラメーターとして受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="09735-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="09735-185">`destinationType` パラメーターが <xref:System.String> 型の場合、返されるオブジェクトは <xref:System.String> にキャストできる必要があります。</span><span class="sxs-lookup"><span data-stu-id="09735-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="09735-186">返される文字列は、 `value`のシリアル化された値を表している必要があります。</span><span class="sxs-lookup"><span data-stu-id="09735-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="09735-187">理想としては、採用するシリアル化の形式は、その文字列を同じコンバーターの <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> の実装に渡した場合と比べて情報の大きな損失が発生することなく、同じ値を生成できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="09735-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="09735-188">値をシリアル化できない場合、またはコンバーターでシリアル化がサポートされていない場合、<xref:System.ComponentModel.TypeConverter.ConvertTo%2A> の実装では、`null` を返す必要があり、その場合は例外をスローすることが許可されます。</span><span class="sxs-lookup"><span data-stu-id="09735-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="09735-189">ただし、例外をスローする場合は、最初に <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> を確認することによって例外を回避するというベスト プラクティスがサポートされるよう、<xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> の実装の一部として、その変換を使用できないことを通知する必要があります。</span><span class="sxs-lookup"><span data-stu-id="09735-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="09735-190">`destinationType` パラメーターが <xref:System.String> 型でない場合は、独自のコンバーター処理を選択できます。</span><span class="sxs-lookup"><span data-stu-id="09735-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="09735-191">通常は、基底の実装の処理に戻り、基底の <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> で特定の例外を発生させます。</span><span class="sxs-lookup"><span data-stu-id="09735-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="09735-192">CanConvertTo の実装</span><span class="sxs-lookup"><span data-stu-id="09735-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="09735-193"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> の実装は、 `true` が `destinationType` 型の場合は <xref:System.String>を返し、それ以外の場合は基底の実装に任せる必要があります。</span><span class="sxs-lookup"><span data-stu-id="09735-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="09735-194">CanConvertFrom の実装</span><span class="sxs-lookup"><span data-stu-id="09735-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="09735-195"><xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> の実装は、 `true` が `sourceType` 型の場合は <xref:System.String>を返し、それ以外の場合は基底の実装に任せる必要があります。</span><span class="sxs-lookup"><span data-stu-id="09735-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="09735-196">TypeConverterAttribute の適用</span><span class="sxs-lookup"><span data-stu-id="09735-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="09735-197">XAML プロセッサでカスタム型コンバーターがカスタム クラス用の型コンバーターとして実際に使用されるようにするには、<xref:System.ComponentModel.TypeConverterAttribute> をクラスの定義に適用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="09735-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="09735-198">属性を通して指定する <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> は、カスタム型コンバーターの型名である必要があります。</span><span class="sxs-lookup"><span data-stu-id="09735-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="09735-199">この属性を適用すると、プロパティの型としてカスタム クラスの型が使用されている値を XAML プロセッサが処理するときに、入力文字列を処理して、オブジェクトのインスタンスを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="09735-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="09735-200">また、プロパティごとに型コンバーターを提供することもできます。</span><span class="sxs-lookup"><span data-stu-id="09735-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="09735-201">クラスの定義に <xref:System.ComponentModel.TypeConverterAttribute> を適用する代わりに、プロパティの定義 (メイン定義内の `get`/`set` の実装ではなくメイン定義自体) に適用します。</span><span class="sxs-lookup"><span data-stu-id="09735-201">Instead of applying a <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="09735-202">プロパティの型は、カスタム型コンバーターによって処理される型と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="09735-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="09735-203">この属性を適用すると、プロパティの値を XAML プロセッサが処理する際に、入力文字列を処理して、オブジェクトのインスタンスを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="09735-203">With this attribute applied, when a XAML processor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="09735-204">プロパティごとに型コンバーターを提供する手法は、Microsoft .NET Framework や他のライブラリなど、クラス定義を制御することができず、<xref:System.ComponentModel.TypeConverterAttribute> を適用できないライブラリからプロパティの型を使用する場合に特に便利です。</span><span class="sxs-lookup"><span data-stu-id="09735-204">The per-property type converter technique is particularly useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="09735-205">関連項目</span><span class="sxs-lookup"><span data-stu-id="09735-205">See also</span></span>

- <xref:System.ComponentModel.TypeConverter>
- [<span data-ttu-id="09735-206">XAML の概要 (WPF)</span><span class="sxs-lookup"><span data-stu-id="09735-206">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="09735-207">マークアップ拡張機能と WPF XAML</span><span class="sxs-lookup"><span data-stu-id="09735-207">Markup Extensions and WPF XAML</span></span>](markup-extensions-and-wpf-xaml.md)
- [<span data-ttu-id="09735-208">XAML 構文の詳細</span><span class="sxs-lookup"><span data-stu-id="09735-208">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)
