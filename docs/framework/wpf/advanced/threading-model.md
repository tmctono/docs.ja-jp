---
title: スレッド モデル
description: Windows Presentation Foundation アプリケーションで複数のスレッドが必要になる可能性がある状況について学習します。 シングル スレッド ソリューションをお勧めします。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
ms.openlocfilehash: 9b67b6ea2896e9e6fec57dee8d1013d54fab03fc
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/24/2020
ms.locfileid: "87166385"
---
# <a name="threading-model"></a><span data-ttu-id="62e97-104">スレッド モデル</span><span class="sxs-lookup"><span data-stu-id="62e97-104">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <span data-ttu-id="62e97-105">は、スレッド処理の難しさから開発者を救うように設計されています。</span><span class="sxs-lookup"><span data-stu-id="62e97-105">is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="62e97-106">その結果、大部分の [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 開発者は、複数のスレッドを使用するインターフェイスを作成する必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="62e97-106">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="62e97-107">マルチスレッド プログラムは複雑でデバッグが困難なため、シングルスレッド ソリューションが存在する場合は回避することが推奨されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-107">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>

 <span data-ttu-id="62e97-108">ただし、どれほど適切に設計したとしても、あらゆる種類の問題に対してシングルスレッドのソリューションを [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] フレームワークで提供することはできません。</span><span class="sxs-lookup"><span data-stu-id="62e97-108">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="62e97-109">はもう一歩のところですが、複数のスレッドで [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] の応答性またはアプリケーションのパフォーマンスが向上する状況がまだあります。</span><span class="sxs-lookup"><span data-stu-id="62e97-109">comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="62e97-110">この記事では、いくつかの背景資料について説明した後、このような状況の一部について探り、最後にいくつかの下位レベルの詳細について説明します。</span><span class="sxs-lookup"><span data-stu-id="62e97-110">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>

> [!NOTE]
> <span data-ttu-id="62e97-111">このトピックでは、非同期呼び出しに <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> メソッドを使用したスレッド処理について説明します。</span><span class="sxs-lookup"><span data-stu-id="62e97-111">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="62e97-112">また、<xref:System.Action> または <xref:System.Func%601> をパラメーターとして受け取る <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> メソッドを呼び出して、非同期呼び出しを行うこともできます。</span><span class="sxs-lookup"><span data-stu-id="62e97-112">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="62e97-113"><xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> メソッドからは、<xref:System.Windows.Threading.DispatcherOperation.Task%2A> プロパティを持つ <xref:System.Windows.Threading.DispatcherOperation> または <xref:System.Windows.Threading.DispatcherOperation%601> が返されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-113">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="62e97-114">`await` キーワードは、<xref:System.Windows.Threading.DispatcherOperation> または関連する <xref:System.Threading.Tasks.Task> のいずれかと共に使用できます。</span><span class="sxs-lookup"><span data-stu-id="62e97-114">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="62e97-115"><xref:System.Threading.Tasks.Task> または <xref:System.Windows.Threading.DispatcherOperation> によって返される <xref:System.Windows.Threading.DispatcherOperation%601> を同期的に待機する必要がある場合、<xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> 拡張メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="62e97-115">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="62e97-116"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> を呼び出すと、デッドロックが発生します。</span><span class="sxs-lookup"><span data-stu-id="62e97-116">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="62e97-117"><xref:System.Threading.Tasks.Task> を使用して非同期操作を実行する方法の詳細については、「タスクの並列化」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="62e97-117">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="62e97-118"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> メソッドには、<xref:System.Action> または <xref:System.Func%601> をパラメーターとして受け取るオーバーロードもあります。</span><span class="sxs-lookup"><span data-stu-id="62e97-118">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="62e97-119"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> メソッドを使用すると、デリゲートで <xref:System.Action> または <xref:System.Func%601> を渡すことにより、同期呼び出しを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="62e97-119">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>

<a name="threading_overview"></a>
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="62e97-120">概要とディスパッチャー</span><span class="sxs-lookup"><span data-stu-id="62e97-120">Overview and the Dispatcher</span></span>
 <span data-ttu-id="62e97-121">通常、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] アプリケーションは 2 つのスレッドから始まります。1 つはレンダリングを処理するもの、もう 1 つは [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] を管理するものです。</span><span class="sxs-lookup"><span data-stu-id="62e97-121">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="62e97-122">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドで入力を受け取り、イベントを処理し、画面を描画し、アプリケーション コードを実行する間、レンダリング スレッドは表示されずにバックグラウンドで効果的に実行されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-122">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="62e97-123">ほとんどのアプリケーションでは 1 つの [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドが使用されますが、複数のスレッドを使用することが最適な状況もあります。</span><span class="sxs-lookup"><span data-stu-id="62e97-123">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="62e97-124">これについては後で例を使って説明します。</span><span class="sxs-lookup"><span data-stu-id="62e97-124">We’ll discuss this with an example later.</span></span>

 <span data-ttu-id="62e97-125">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドにより、<xref:System.Windows.Threading.Dispatcher> というオブジェクト内の作業項目がキューに格納されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-125">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="62e97-126"><xref:System.Windows.Threading.Dispatcher> は作業項目を優先順位に従って選択し、それぞれを最後まで実行します。</span><span class="sxs-lookup"><span data-stu-id="62e97-126">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="62e97-127">すべての [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドには少なくとも 1 つの <xref:System.Windows.Threading.Dispatcher> が必要であり、各 <xref:System.Windows.Threading.Dispatcher> では 1 つのスレッドで作業項目を実行できます。</span><span class="sxs-lookup"><span data-stu-id="62e97-127">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>

 <span data-ttu-id="62e97-128">応答性の高いユーザー フレンドリなアプリケーションを構築する秘訣は、作業項目を小さく保って <xref:System.Windows.Threading.Dispatcher> のスループットを最大化することです。</span><span class="sxs-lookup"><span data-stu-id="62e97-128">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="62e97-129">このようにすると、処理の待機中に <xref:System.Windows.Threading.Dispatcher> キューに格納されている項目が古くなることはなくなります。</span><span class="sxs-lookup"><span data-stu-id="62e97-129">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="62e97-130">入力と応答の間に知覚可能な遅延があると、ユーザーに不満が生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="62e97-130">Any perceivable delay between input and response can frustrate a user.</span></span>

 <span data-ttu-id="62e97-131">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] アプリケーションでは、どのような方法で大規模な操作を処理することが想定されているでしょうか。</span><span class="sxs-lookup"><span data-stu-id="62e97-131">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="62e97-132">コードに大規模な計算が含まれる場合や、リモート サーバー上のデータベースに対してクエリを実行する必要がある場合は、どうすればよいでしょうか。</span><span class="sxs-lookup"><span data-stu-id="62e97-132">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="62e97-133">通常、その答えは、大規模な操作は別のスレッドで処理し、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドで <xref:System.Windows.Threading.Dispatcher> キュー内の項目を処理できる余地を残すことです。</span><span class="sxs-lookup"><span data-stu-id="62e97-133">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="62e97-134">大規模な操作が完了すると、結果が [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドに報告され、表示できるようになります。</span><span class="sxs-lookup"><span data-stu-id="62e97-134">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>

 <span data-ttu-id="62e97-135">従来、Windows では、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 要素へのアクセスは、それらを作成したスレッドにのみ許可されています。</span><span class="sxs-lookup"><span data-stu-id="62e97-135">Historically, Windows allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="62e97-136">つまり、実行時間が長いタスクを担当するバックグラウンド スレッドでは、終了時にテキスト ボックスを更新できないことがあります。</span><span class="sxs-lookup"><span data-stu-id="62e97-136">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> <span data-ttu-id="62e97-137">Windows では、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] コンポーネントの整合性を確保するためにこれを行っています。</span><span class="sxs-lookup"><span data-stu-id="62e97-137">Windows does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="62e97-138">コンテンツが描画中にバックグラウンド スレッドによって更新された場合、リスト ボックスが適切に表示されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="62e97-138">A list box could look strange if its contents were updated by a background thread during painting.</span></span>

 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="62e97-139">には、この調整を強制する組み込みの相互排他メカニズムがあります。</span><span class="sxs-lookup"><span data-stu-id="62e97-139">has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="62e97-140">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] のほとんどのクラスは <xref:System.Windows.Threading.DispatcherObject> から派生しています。</span><span class="sxs-lookup"><span data-stu-id="62e97-140">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="62e97-141">構築時に、現在実行中のスレッドにリンクされた <xref:System.Windows.Threading.Dispatcher> への参照が <xref:System.Windows.Threading.DispatcherObject> に格納されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-141">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="62e97-142">実際には、<xref:System.Windows.Threading.DispatcherObject> は、それを作成したスレッドに関連付けられます。</span><span class="sxs-lookup"><span data-stu-id="62e97-142">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="62e97-143">プログラムの実行中に、<xref:System.Windows.Threading.DispatcherObject> を使用してそのパブリック <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="62e97-143">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="62e97-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> では、現在のスレッドに関連付けられている <xref:System.Windows.Threading.Dispatcher> が確認され、構築中に格納された <xref:System.Windows.Threading.Dispatcher> 参照と比較されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="62e97-145">一致しない場合、<xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> からは例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="62e97-145">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="62e97-146"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> は、<xref:System.Windows.Threading.DispatcherObject> に属するすべてのメソッドの最初に呼び出されることが想定されています。</span><span class="sxs-lookup"><span data-stu-id="62e97-146"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>

 <span data-ttu-id="62e97-147">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] を変更できるのが 1 つのスレッドのみである場合、バックグラウンド スレッドはユーザーとどのように対話するでしょうか。</span><span class="sxs-lookup"><span data-stu-id="62e97-147">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="62e97-148">バックグラウンド スレッドからは、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドに対して、代理で操作を実行するように要求することができます。</span><span class="sxs-lookup"><span data-stu-id="62e97-148">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="62e97-149">これを行うには、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドの <xref:System.Windows.Threading.Dispatcher> に作業項目を登録します。</span><span class="sxs-lookup"><span data-stu-id="62e97-149">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="62e97-150"><xref:System.Windows.Threading.Dispatcher> クラスには、作業項目を登録するための 2 つのメソッド <xref:System.Windows.Threading.Dispatcher.Invoke%2A> と <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> が用意されています。</span><span class="sxs-lookup"><span data-stu-id="62e97-150">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="62e97-151">どちらのメソッドでも、デリゲートの実行がスケジュールされます。</span><span class="sxs-lookup"><span data-stu-id="62e97-151">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="62e97-152"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> は同期呼び出しです。つまり、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドでデリゲートの実行が実際に完了するまで戻りません。</span><span class="sxs-lookup"><span data-stu-id="62e97-152"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="62e97-153"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> は非同期であり、すぐに戻ります。</span><span class="sxs-lookup"><span data-stu-id="62e97-153"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>

 <span data-ttu-id="62e97-154"><xref:System.Windows.Threading.Dispatcher> によって、キュー内の要素が優先度順に並べ替えられます。</span><span class="sxs-lookup"><span data-stu-id="62e97-154">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="62e97-155">要素を <xref:System.Windows.Threading.Dispatcher> キューに追加するときに指定できるレベルは 10 個あります。</span><span class="sxs-lookup"><span data-stu-id="62e97-155">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="62e97-156">これらの優先度は、<xref:System.Windows.Threading.DispatcherPriority> 列挙体に維持されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-156">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="62e97-157"><xref:System.Windows.Threading.DispatcherPriority> レベルの詳細については、Windows SDK のドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="62e97-157">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the Windows SDK documentation.</span></span>

<a name="samples"></a>
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="62e97-158">動作中のスレッド:サンプル</span><span class="sxs-lookup"><span data-stu-id="62e97-158">Threads in Action: The Samples</span></span>

<a name="prime_number"></a>
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="62e97-159">実行時間の長い計算を使用するシングルスレッド アプリケーション</span><span class="sxs-lookup"><span data-stu-id="62e97-159">A Single-Threaded Application with a Long-Running Calculation</span></span>
 <span data-ttu-id="62e97-160">ほとんどのグラフィカル ユーザー インターフェイス (GUI) では、ユーザーの操作に応じて生成されるイベントを待機する間、アイドルの状態で大部分の時間が費やされます。</span><span class="sxs-lookup"><span data-stu-id="62e97-160">Most graphical user interfaces (GUIs) spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="62e97-161">慎重にプログラミングすると、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] の応答性に影響を与えることなく、このアイドル時間を建設的に使用できます。</span><span class="sxs-lookup"><span data-stu-id="62e97-161">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="62e97-162">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] スレッド モデルでは、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドで発生する操作を中断する入力は許可されていません。</span><span class="sxs-lookup"><span data-stu-id="62e97-162">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="62e97-163">つまり、保留中の入力イベントが古くなる前に処理できるように、定期的に <xref:System.Windows.Threading.Dispatcher> に戻る必要があります。</span><span class="sxs-lookup"><span data-stu-id="62e97-163">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>

 <span data-ttu-id="62e97-164">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="62e97-164">Consider the following example:</span></span>

 ![素数のスレッド処理を示すスクリーンショット。](./media/threading-model/threading-prime-numbers.png)

 <span data-ttu-id="62e97-166">このシンプルなアプリケーションでは、素数を検索して、3 から数え上げます。</span><span class="sxs-lookup"><span data-stu-id="62e97-166">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="62e97-167">ユーザーが **[Start]\(開始\)** ボタンをクリックすると、検索が開始されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-167">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="62e97-168">プログラムによって素数が検出されると、その検出によってユーザー インターフェイスが更新されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-168">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="62e97-169">ユーザーはいつでも検索を停止できます。</span><span class="sxs-lookup"><span data-stu-id="62e97-169">At any point, the user can stop the search.</span></span>

 <span data-ttu-id="62e97-170">とてもシンプルですが、素数検索は永遠に続く可能性があり、いくつかの困難を伴います。</span><span class="sxs-lookup"><span data-stu-id="62e97-170">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="62e97-171">ボタンのクリック イベント ハンドラー内で検索全体を処理した場合、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドに他のイベントを処理する機会を与えないことになります。</span><span class="sxs-lookup"><span data-stu-id="62e97-171">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="62e97-172">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] では、入力に応答することや、メッセージを処理することができません。</span><span class="sxs-lookup"><span data-stu-id="62e97-172">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="62e97-173">再描画もボタンのクリックに対する応答も行われません。</span><span class="sxs-lookup"><span data-stu-id="62e97-173">It would never repaint and never respond to button clicks.</span></span>

 <span data-ttu-id="62e97-174">別のスレッドで素数検索を行うこともできますが、その場合は同期の問題に対処する必要があります。</span><span class="sxs-lookup"><span data-stu-id="62e97-174">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="62e97-175">シングルスレッド方式では、ラベルを直接更新し、見つかった最大の素数を列挙することができます。</span><span class="sxs-lookup"><span data-stu-id="62e97-175">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>

 <span data-ttu-id="62e97-176">計算のタスクを扱いやすいチャンクに分割すると、定期的に <xref:System.Windows.Threading.Dispatcher> に戻ってイベントを処理できます。</span><span class="sxs-lookup"><span data-stu-id="62e97-176">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="62e97-177">入力を再描画して処理する機会を [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] に与えることができます。</span><span class="sxs-lookup"><span data-stu-id="62e97-177">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>

 <span data-ttu-id="62e97-178">計算とイベント処理の間で処理時間を分割する最善の方法は、<xref:System.Windows.Threading.Dispatcher> から計算を管理することです。</span><span class="sxs-lookup"><span data-stu-id="62e97-178">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="62e97-179"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> メソッドを使用することで、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] イベントが取得される同じキューで素数チェックをスケジュールできます。</span><span class="sxs-lookup"><span data-stu-id="62e97-179">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="62e97-180">この例では、一度に 1 つの素数チェックのみをスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="62e97-180">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="62e97-181">素数チェックが完了したら、次のチェックをすぐにスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="62e97-181">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="62e97-182">このチェックは、保留中の [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] イベントが処理された後にのみ実行されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-182">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>

 ![ディスパッチャー キューを示すスクリーンショット。](./media/threading-model/threading-dispatcher-queue.png)

 <span data-ttu-id="62e97-184">Microsoft Word では、このメカニズムを使用してスペル チェックが実行されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-184">Microsoft Word accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="62e97-185">スペル チェックは、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドのアイドル時間を使用してバックグラウンドで行われます。</span><span class="sxs-lookup"><span data-stu-id="62e97-185">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="62e97-186">コードを見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="62e97-186">Let's take a look at the code.</span></span>

 <span data-ttu-id="62e97-187">次の例は、ユーザー インターフェイスを作成する XAML を示しています。</span><span class="sxs-lookup"><span data-stu-id="62e97-187">The following example shows the XAML that creates the user interface.</span></span>

 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]

 <span data-ttu-id="62e97-188">コードビハインドの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="62e97-188">The following example shows the code-behind.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]

 <span data-ttu-id="62e97-189"><xref:System.Windows.Controls.Button> のイベント ハンドラーの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="62e97-189">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]

 <span data-ttu-id="62e97-190">このハンドラーは、<xref:System.Windows.Controls.Button> のテキストの更新だけでなく、<xref:System.Windows.Threading.Dispatcher> キューにデリゲートを追加して最初の素数チェックのスケジュールを設定することを担当しています。</span><span class="sxs-lookup"><span data-stu-id="62e97-190">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="62e97-191">このイベント ハンドラーの処理が完了すると、<xref:System.Windows.Threading.Dispatcher> によってこのデリゲートが選択され、実行されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-191">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>

 <span data-ttu-id="62e97-192">前述のとおり、<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> はデリゲートの実行をスケジュールするために使用される <xref:System.Windows.Threading.Dispatcher> メンバーです。</span><span class="sxs-lookup"><span data-stu-id="62e97-192">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="62e97-193">この場合、<xref:System.Windows.Threading.DispatcherPriority.SystemIdle> の優先度を選択します。</span><span class="sxs-lookup"><span data-stu-id="62e97-193">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="62e97-194"><xref:System.Windows.Threading.Dispatcher> では、処理する重要なイベントがない場合にのみ、このデリゲートが実行されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-194">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] <span data-ttu-id="62e97-195">の応答性は、数値チェックよりも重要です。</span><span class="sxs-lookup"><span data-stu-id="62e97-195">responsiveness is more important than number checking.</span></span> <span data-ttu-id="62e97-196">また、数値チェック ルーチンを表す新しいデリゲートも渡します。</span><span class="sxs-lookup"><span data-stu-id="62e97-196">We also pass a new delegate representing the number-checking routine.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]

 <span data-ttu-id="62e97-197">このメソッドでは、次の奇数が素数かどうかがチェックされます。</span><span class="sxs-lookup"><span data-stu-id="62e97-197">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="62e97-198">素数の場合、メソッドによって `bigPrime`<xref:System.Windows.Controls.TextBlock> が直接更新され、その検出が反映されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-198">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="62e97-199">これを実行できるのは、コンポーネントの作成に使用されたものと同じスレッドで計算が行われているためです。</span><span class="sxs-lookup"><span data-stu-id="62e97-199">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="62e97-200">計算に別のスレッドを使用することを選択した場合、より複雑な同期メカニズムを使用して、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドで更新を実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="62e97-200">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="62e97-201">この状況を次に示します。</span><span class="sxs-lookup"><span data-stu-id="62e97-201">We’ll demonstrate this situation next.</span></span>

 <span data-ttu-id="62e97-202">このサンプルの完全なソース コードについては、[実行時間が長い計算があるシングルスレッド アプリケーションのサンプル](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="62e97-202">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)</span></span>

<a name="weather_sim"></a>
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="62e97-203">バックグラウンド スレッドを使用したブロック操作の処理</span><span class="sxs-lookup"><span data-stu-id="62e97-203">Handling a Blocking Operation with a Background Thread</span></span>
 <span data-ttu-id="62e97-204">グラフィカル アプリケーションでのブロック操作の処理は困難な場合があります。</span><span class="sxs-lookup"><span data-stu-id="62e97-204">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="62e97-205">イベント ハンドラーからはブロック メソッドを呼び出したくありません。これは、アプリケーションがフリーズしたように見えるためです。</span><span class="sxs-lookup"><span data-stu-id="62e97-205">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="62e97-206">別のスレッドを使用してこれらの操作を処理できますが、ワーカー スレッドからは GUI を直接変更できないため、完了したら、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドと同期する必要があります。</span><span class="sxs-lookup"><span data-stu-id="62e97-206">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the GUI from our worker thread.</span></span> <span data-ttu-id="62e97-207"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> または <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> を使用して、デリゲートを [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドの <xref:System.Windows.Threading.Dispatcher> に挿入できます。</span><span class="sxs-lookup"><span data-stu-id="62e97-207">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="62e97-208">最終的に、これらのデリゲートは、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 要素を変更するアクセス許可を使用して実行されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-208">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>

 <span data-ttu-id="62e97-209">この例では、天気予報を取得するリモート プロシージャ コールを模倣しています。</span><span class="sxs-lookup"><span data-stu-id="62e97-209">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="62e97-210">別のワーカー スレッドを使用してこの呼び出しを実行し、完了したら [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドの <xref:System.Windows.Threading.Dispatcher> で更新メソッドをスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="62e97-210">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>

 ![天気予報 UI を示すスクリーンショット。](./media/threading-model/threading-weather-ui.png)

 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]

 <span data-ttu-id="62e97-212">注意する必要がある詳細の一部を次に示します。</span><span class="sxs-lookup"><span data-stu-id="62e97-212">The following are some of the details to be noted.</span></span>

- <span data-ttu-id="62e97-213">ボタン ハンドラーの作成</span><span class="sxs-lookup"><span data-stu-id="62e97-213">Creating the Button Handler</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]

 <span data-ttu-id="62e97-214">ボタンをクリックすると、時計の描画が表示され、アニメーションが開始されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-214">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="62e97-215">このボタンを無効にします。</span><span class="sxs-lookup"><span data-stu-id="62e97-215">We disable the button.</span></span> <span data-ttu-id="62e97-216">新しいスレッドで `FetchWeatherFromServer` メソッドを呼び出してから、戻って、天気予報の収集を待機している間に <xref:System.Windows.Threading.Dispatcher> でイベントを処理できるようにします。</span><span class="sxs-lookup"><span data-stu-id="62e97-216">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>

- <span data-ttu-id="62e97-217">天気のフェッチ</span><span class="sxs-lookup"><span data-stu-id="62e97-217">Fetching the Weather</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]

 <span data-ttu-id="62e97-218">簡単にするために、この例にはネットワーク コードを含めていません。</span><span class="sxs-lookup"><span data-stu-id="62e97-218">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="62e97-219">代わりに、ネットワーク アクセスの待機時間をシミュレートするために、新しいスレッドを 4 秒間スリープさせます。</span><span class="sxs-lookup"><span data-stu-id="62e97-219">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="62e97-220">このとき、元の [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドはまだ実行中であり、イベントに応答しています。</span><span class="sxs-lookup"><span data-stu-id="62e97-220">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="62e97-221">これを示すために、アニメーションを実行したままにしました。最小化と最大化のボタンも引き続き機能します。</span><span class="sxs-lookup"><span data-stu-id="62e97-221">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>

 <span data-ttu-id="62e97-222">待機時間が完了し、天気予報をランダムに選択したら、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドに報告します。</span><span class="sxs-lookup"><span data-stu-id="62e97-222">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="62e97-223">これを行うには、そのスレッドの <xref:System.Windows.Threading.Dispatcher> を使用して、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドで `UpdateUserInterface` の呼び出しをスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="62e97-223">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="62e97-224">天気を説明する文字列を、このスケジュールされたメソッド呼び出しに渡します。</span><span class="sxs-lookup"><span data-stu-id="62e97-224">We pass a string describing the weather to this scheduled method call.</span></span>

- <span data-ttu-id="62e97-225">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] の更新</span><span class="sxs-lookup"><span data-stu-id="62e97-225">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]

 <span data-ttu-id="62e97-226">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッド内の <xref:System.Windows.Threading.Dispatcher> に時間がある場合、スケジュールされた `UpdateUserInterface` の呼び出しが実行されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-226">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="62e97-227">このメソッドによって、時計のアニメーションが停止され、天気を説明する画像が選択されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-227">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="62e97-228">この画像が表示され、"天気予報のフェッチ" ボタンが復元されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-228">It displays this image and restores the "fetch forecast" button.</span></span>

<a name="multi_browser"></a>
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="62e97-229">複数のウィンドウ、複数のスレッド</span><span class="sxs-lookup"><span data-stu-id="62e97-229">Multiple Windows, Multiple Threads</span></span>
 <span data-ttu-id="62e97-230">一部の [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] アプリケーションには、複数の最上位ウィンドウが必要です。</span><span class="sxs-lookup"><span data-stu-id="62e97-230">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="62e97-231">1 つのスレッドと <xref:System.Windows.Threading.Dispatcher> の組み合わせで複数のウィンドウを管理することは完全に許容されていますが、複数のスレッドの方が適切にジョブを実行できる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="62e97-231">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="62e97-232">これは、ウィンドウの 1 つがスレッドを独占する可能性がある場合に特に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="62e97-232">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>

 <span data-ttu-id="62e97-233">Windows エクスプローラーはこの方法で動作します。</span><span class="sxs-lookup"><span data-stu-id="62e97-233">Windows Explorer works in this fashion.</span></span> <span data-ttu-id="62e97-234">新しいエクスプローラー ウィンドウはそれぞれ元のプロセスに属しますが、独立したスレッドの制御下で作成されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-234">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>

 <span data-ttu-id="62e97-235">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> コントロールを使用して、Web ページを表示できます。</span><span class="sxs-lookup"><span data-stu-id="62e97-235">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="62e97-236">Internet Explorer のシンプルな代替品を簡単に作成できます。</span><span class="sxs-lookup"><span data-stu-id="62e97-236">We can easily create a simple Internet Explorer substitute.</span></span> <span data-ttu-id="62e97-237">まず重要な機能から始めます。新しいエクスプローラー ウィンドウを開く機能です。</span><span class="sxs-lookup"><span data-stu-id="62e97-237">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="62e97-238">ユーザーが [新しいウィンドウ] ボタンをクリックすると、ウィンドウのコピーが別のスレッドで起動されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-238">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="62e97-239">このように、いずれかのウィンドウで長時間実行またはブロックする操作によって、他のすべてのウィンドウがロックされることはありません。</span><span class="sxs-lookup"><span data-stu-id="62e97-239">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>

 <span data-ttu-id="62e97-240">実際、Web ブラウザー モデルには独自の複雑なスレッド モデルがあります。</span><span class="sxs-lookup"><span data-stu-id="62e97-240">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="62e97-241">これを選択した理由は、ほとんどの読者にとってなじみ深いものだからです。</span><span class="sxs-lookup"><span data-stu-id="62e97-241">We’ve chosen it because it should be familiar to most readers.</span></span>

 <span data-ttu-id="62e97-242">次の例でそのコードを示します。</span><span class="sxs-lookup"><span data-stu-id="62e97-242">The following example shows the code.</span></span>

 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]

 <span data-ttu-id="62e97-243">このコードの次のスレッド セグメントは、このコンテキストで最も興味深いものです。</span><span class="sxs-lookup"><span data-stu-id="62e97-243">The following threading segments of this code are the most interesting to us in this context:</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]

 <span data-ttu-id="62e97-244">このメソッドは、[新しいウィンドウ] ボタンがクリックされたときに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-244">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="62e97-245">新しいスレッドが作成され、非同期に開始されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-245">It creates a new thread and starts it asynchronously.</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]

 <span data-ttu-id="62e97-246">このメソッドは、新しいスレッドの始点です。</span><span class="sxs-lookup"><span data-stu-id="62e97-246">This method is the starting point for the new thread.</span></span> <span data-ttu-id="62e97-247">このスレッドの制御下で新しいウィンドウを作成します。</span><span class="sxs-lookup"><span data-stu-id="62e97-247">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="62e97-248">によって自動的に新しい <xref:System.Windows.Threading.Dispatcher> が作成され、新しいスレッドが管理されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-248">automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="62e97-249">ウィンドウを機能させるために必要なことは、<xref:System.Windows.Threading.Dispatcher> の開始のみです。</span><span class="sxs-lookup"><span data-stu-id="62e97-249">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>

<a name="stumbling_points"></a>
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="62e97-250">技術的な詳細とつまずくポイント</span><span class="sxs-lookup"><span data-stu-id="62e97-250">Technical Details and Stumbling Points</span></span>

### <a name="writing-components-using-threading"></a><span data-ttu-id="62e97-251">スレッド処理を使用したコンポーネントの作成</span><span class="sxs-lookup"><span data-stu-id="62e97-251">Writing Components Using Threading</span></span>
 <span data-ttu-id="62e97-252">Microsoft .NET Framework 開発者ガイドでは、コンポーネントでクライアントに非同期動作を公開する方法のパターンが説明されています (「[イベントベースの非同期パターンの概要](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="62e97-252">The Microsoft .NET Framework Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="62e97-253">たとえば、`FetchWeatherFromServer` メソッドを再利用可能な非グラフィカル コンポーネントにパッケージ化するとします。</span><span class="sxs-lookup"><span data-stu-id="62e97-253">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="62e97-254">標準の Microsoft .NET Framework パターンに従うと、これは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="62e97-254">Following the standard Microsoft .NET Framework pattern, this would look something like the following.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]

 <span data-ttu-id="62e97-255">`GetWeatherAsync` では、バックグラウンド スレッドの作成など、前述の手法のいずれかを使用して、呼び出しスレッドをブロックせずに非同期で作業を行います。</span><span class="sxs-lookup"><span data-stu-id="62e97-255">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>

 <span data-ttu-id="62e97-256">このパターンの最も重要な部分の 1 つは、最初に *MethodName*`Async` メソッドを呼び出したものと同じスレッドで *MethodName*`Completed` メソッドを呼び出すことです。</span><span class="sxs-lookup"><span data-stu-id="62e97-256">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="62e97-257">これは、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] を使用して <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> を格納することで、とても簡単に実行できます。ただし、この非グラフィカル コンポーネントは、Windows フォームや ASP.NET プログラムではなく、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] アプリケーションでのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="62e97-257">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in Windows Forms or ASP.NET programs.</span></span>

 <span data-ttu-id="62e97-258"><xref:System.Windows.Threading.DispatcherSynchronizationContext> クラスを使用すると、このニーズに対応できます。これを他の [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] フレームワークでも機能する <xref:System.Windows.Threading.Dispatcher> の簡略化されたバージョンとして考えてください。</span><span class="sxs-lookup"><span data-stu-id="62e97-258">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]

### <a name="nested-pumping"></a><span data-ttu-id="62e97-259">入れ子になったポンプ</span><span class="sxs-lookup"><span data-stu-id="62e97-259">Nested Pumping</span></span>
 <span data-ttu-id="62e97-260">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドを完全にロックすることができない場合があります。</span><span class="sxs-lookup"><span data-stu-id="62e97-260">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="62e97-261"><xref:System.Windows.MessageBox> クラスの <xref:System.Windows.MessageBox.Show%2A> メソッドについて考えてみましょう。</span><span class="sxs-lookup"><span data-stu-id="62e97-261">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="62e97-262">ユーザーが [OK] ボタンをクリックするまで <xref:System.Windows.MessageBox.Show%2A> は戻りません。</span><span class="sxs-lookup"><span data-stu-id="62e97-262"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="62e97-263">ただし、対話型にするためにメッセージ ループが必要なウィンドウが作成されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-263">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="62e97-264">ユーザーが [OK] をクリックするまで待機している間に、元のアプリケーション ウインドウではユーザー入力に応答しません。</span><span class="sxs-lookup"><span data-stu-id="62e97-264">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="62e97-265">ただし、描画メッセージの処理は続行されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-265">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="62e97-266">元のウィンドウは、隠れたときと、見えるようになったときに再描画されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-266">The original window redraws itself when covered and revealed.</span></span>

 ![[OK] ボタンのある MessageBox を示すスクリーンショット](./media/threading-model/threading-message-loop.png)

 <span data-ttu-id="62e97-268">何らかのスレッドがメッセージ ボックス ウィンドウを担当する必要があります。</span><span class="sxs-lookup"><span data-stu-id="62e97-268">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="62e97-269">を使用して、メッセージ ボックス ウィンドウ専用の新しいスレッドを作成できますが、このスレッドでは元のウィンドウで無効な要素を描画できません (相互排他に関する前述の説明を思い出してください)。</span><span class="sxs-lookup"><span data-stu-id="62e97-269">could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="62e97-270">代わりに、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] で入れ子になったメッセージ処理システムを使用します。</span><span class="sxs-lookup"><span data-stu-id="62e97-270">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="62e97-271"><xref:System.Windows.Threading.Dispatcher> クラスには、<xref:System.Windows.Threading.Dispatcher.PushFrame%2A> という特殊なメソッドが含まれています。これを使用すると、アプリケーションの現在の実行ポイントを格納してから、新しいメッセージ ループを開始できます。</span><span class="sxs-lookup"><span data-stu-id="62e97-271">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="62e97-272">入れ子になったメッセージ ループが完了すると、元の <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> 呼び出しの後に実行が再開されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-272">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>

 <span data-ttu-id="62e97-273">この場合、<xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType> の呼び出し時にプログラム コンテキストが <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> に保持され、新しいメッセージ ループが開始され、背景ウィンドウが再描画され、メッセージ ボックス ウィンドウへの入力が処理されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-273">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="62e97-274">ユーザーが [OK] をクリックしてポップアップ ウィンドウをクリアすると、入れ子になったループが終了し、<xref:System.Windows.MessageBox.Show%2A> の呼び出し後に制御が再開されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-274">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>

### <a name="stale-routed-events"></a><span data-ttu-id="62e97-275">古いルーティング イベント</span><span class="sxs-lookup"><span data-stu-id="62e97-275">Stale Routed Events</span></span>
 <span data-ttu-id="62e97-276">イベントが発生すると、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] のルーティング イベント システムによってツリー全体に通知されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-276">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>

 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]

 <span data-ttu-id="62e97-277">マウスの左ボタンで楕円を押すと、`handler2` が実行されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-277">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="62e97-278">`handler2` が完了すると、イベントは <xref:System.Windows.Controls.Canvas> オブジェクトに渡され、そこで処理に `handler1` が使用されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-278">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="62e97-279">これは、`handler2` によってイベント オブジェクトが処理済みと明示的にマークされない場合にのみ発生します。</span><span class="sxs-lookup"><span data-stu-id="62e97-279">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>

 <span data-ttu-id="62e97-280">`handler2` でこのイベントを処理するためにかなりの時間がかかる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="62e97-280">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="62e97-281">`handler2` では、<xref:System.Windows.Threading.Dispatcher.PushFrame%2A> を使用して入れ子になったメッセージ ループが開始され、何時間も戻らなくなることがあります。</span><span class="sxs-lookup"><span data-stu-id="62e97-281">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="62e97-282">このメッセージ ループの完了時に `handler2` によってイベントが処理済みとマークされない場合、イベントは、非常に古くても、ツリーの上位に渡されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-282">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>

### <a name="reentrancy-and-locking"></a><span data-ttu-id="62e97-283">再入とロック</span><span class="sxs-lookup"><span data-stu-id="62e97-283">Reentrancy and Locking</span></span>
 <span data-ttu-id="62e97-284">共通言語ランタイム (CLR) のロック メカニズムは、想像どおりに動作しません。ロックを要求した場合、スレッドによる操作が完全に停止することを予想するのではないでしょうか。</span><span class="sxs-lookup"><span data-stu-id="62e97-284">The locking mechanism of the common language runtime (CLR) doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="62e97-285">実際には、スレッドでは引き続き優先度の高いメッセージが受信され、処理されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-285">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="62e97-286">これにより、デッドロックを防止し、インターフェイスの応答性を最小限に抑えることができますが、軽度のバグが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="62e97-286">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="62e97-287">ほとんどの場合、この点について理解する必要はありません。ただし、まれな状況ではありますが (通常は Win32 ウィンドウ メッセージまたは COM STA コンポーネントが関係しています)、この点を理解しておくことが重要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="62e97-287">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving Win32 window messages or COM STA components) this can be worth knowing.</span></span>

 <span data-ttu-id="62e97-288">ほとんどのインターフェイスは、スレッド セーフを考慮して構築されていません。開発者は、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] が複数のスレッドからアクセスされることはないと想定して作業しているためです。</span><span class="sxs-lookup"><span data-stu-id="62e97-288">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="62e97-289">この場合、その 1 つのスレッドで予期しないタイミングで環境が変化し、本来は <xref:System.Windows.Threading.DispatcherObject> 相互排他メカニズムで解決されるはずの悪影響を生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="62e97-289">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="62e97-290">次の擬似コードを考えてみましょう。</span><span class="sxs-lookup"><span data-stu-id="62e97-290">Consider the following pseudocode:</span></span>

 <span data-ttu-id="62e97-291">![スレッド処理の再入を示す図。](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="62e97-291">![Diagram that shows threading reentrancy.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span></span>

 <span data-ttu-id="62e97-292">ほとんどの場合は適切ですが、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] には、このような予期しない再入によって問題を発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="62e97-292">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="62e97-293">そのため、特定のキー時刻で、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] によって <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> が呼び出されます。これにより、通常の CLR ロックではなく、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 再入可能なロックを使用するように、そのスレッドのロック命令が変更されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-293">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual CLR lock.</span></span>

 <span data-ttu-id="62e97-294">では、CLR チームがこの動作を選択したのはなぜでしょうか。</span><span class="sxs-lookup"><span data-stu-id="62e97-294">So why did the CLR team choose this behavior?</span></span> <span data-ttu-id="62e97-295">COM STA オブジェクトと終了処理スレッドに対応する必要がありました。</span><span class="sxs-lookup"><span data-stu-id="62e97-295">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="62e97-296">オブジェクトのガベージ コレクションが実行されると、その `Finalize` メソッドは、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドではなく、専用のファイナライザー スレッドで実行されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-296">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="62e97-297">ここに問題があります。これは、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドで作成された COM STA オブジェクトは、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドでのみ破棄できるためです。</span><span class="sxs-lookup"><span data-stu-id="62e97-297">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="62e97-298">CLR では、(この場合は Win32 の `SendMessage` を使用して) <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> に相当する処理が実行されます。</span><span class="sxs-lookup"><span data-stu-id="62e97-298">The CLR does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="62e97-299">ただし、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] スレッドがビジーの場合、ファイナライザー スレッドは停止し、COM STA オブジェクトを破棄できないため、重大なメモリ リークが発生します。</span><span class="sxs-lookup"><span data-stu-id="62e97-299">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="62e97-300">そのため、CLR チームは、ロックを適切に機能させるために難しい判断を下しました。</span><span class="sxs-lookup"><span data-stu-id="62e97-300">So the CLR team made the tough call to make locks work the way they do.</span></span>

 <span data-ttu-id="62e97-301">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] のタスクは、メモリ リークを再発生させることなく、予期しない再入を回避することです。そのため、ここでは、あらゆる場所で再入をブロックしていません。</span><span class="sxs-lookup"><span data-stu-id="62e97-301">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>

## <a name="see-also"></a><span data-ttu-id="62e97-302">関連項目</span><span class="sxs-lookup"><span data-stu-id="62e97-302">See also</span></span>

- [<span data-ttu-id="62e97-303">実行時間の長い計算を使用するシングルスレッド アプリケーションのサンプル</span><span class="sxs-lookup"><span data-stu-id="62e97-303">Single-Threaded Application with Long-Running Calculation Sample</span></span>](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)
