---
title: AssemblyLoadContext について - .NET Core
description: .NET Core での AssemblyLoadContext の用途と動作を理解するための主要な概念。
ms.date: 08/09/2019
author: sdmaclea
ms.author: stmaclea
ms.openlocfilehash: 43fb0d792ddeb20b8a141af452a86dd50f37ba43
ms.sourcegitcommit: 79b0dd8bfc63f33a02137121dd23475887ecefda
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/01/2020
ms.locfileid: "80523609"
---
# <a name="understanding-systemruntimeloaderassemblyloadcontext"></a><span data-ttu-id="aa38f-103">System.Runtime.Loader.AssemblyLoadContext について</span><span class="sxs-lookup"><span data-stu-id="aa38f-103">Understanding System.Runtime.Loader.AssemblyLoadContext</span></span>

<span data-ttu-id="aa38f-104"><xref:System.Runtime.Loader.AssemblyLoadContext> クラスは .NET Core に固有です。</span><span class="sxs-lookup"><span data-stu-id="aa38f-104">The <xref:System.Runtime.Loader.AssemblyLoadContext> class is unique to .NET Core.</span></span> <span data-ttu-id="aa38f-105">この記事では、<xref:System.Runtime.Loader.AssemblyLoadContext> API ドキュメントを概念情報により補完します。</span><span class="sxs-lookup"><span data-stu-id="aa38f-105">This article attempts to supplement the <xref:System.Runtime.Loader.AssemblyLoadContext> API documentation with conceptual information.</span></span>

<span data-ttu-id="aa38f-106">この記事は、動的読み込みを実装する開発者 (特に動的読み込みフレームワークの開発者) に関連しています。</span><span class="sxs-lookup"><span data-stu-id="aa38f-106">This article is relevant to developers implementing dynamic loading, especially dynamic loading framework developers.</span></span>

## <a name="what-is-the-assemblyloadcontext"></a><span data-ttu-id="aa38f-107">AssemblyLoadContext とは</span><span class="sxs-lookup"><span data-stu-id="aa38f-107">What is the AssemblyLoadContext?</span></span>

<span data-ttu-id="aa38f-108">すべての .NET Core アプリケーションは、暗黙的に <xref:System.Runtime.Loader.AssemblyLoadContext> を使用します。</span><span class="sxs-lookup"><span data-stu-id="aa38f-108">Every .NET Core application implicitly uses the <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span>
<span data-ttu-id="aa38f-109">これは、依存関係を検索して読み込むためのランタイムのプロバイダーです。</span><span class="sxs-lookup"><span data-stu-id="aa38f-109">It's the runtime's provider for locating and loading dependencies.</span></span> <span data-ttu-id="aa38f-110">依存関係が読み込まれるたびに、<xref:System.Runtime.Loader.AssemblyLoadContext> インスタンスが呼び出されてそれを見つけます。</span><span class="sxs-lookup"><span data-stu-id="aa38f-110">Whenever a dependency is loaded, an <xref:System.Runtime.Loader.AssemblyLoadContext> instance is invoked to locate it.</span></span>

- <span data-ttu-id="aa38f-111">マネージド アセンブリやその他の依存関係を検索し、読み込み、キャッシュするサービスを提供します。</span><span class="sxs-lookup"><span data-stu-id="aa38f-111">It provides a service of locating, loading, and caching managed assemblies and other dependencies.</span></span>

- <span data-ttu-id="aa38f-112">動的なコードの読み込みとアンロードをサポートするために、独自の <xref:System.Runtime.Loader.AssemblyLoadContext> インスタンスにコードとその依存関係を読み込むための分離コンテキストを作成します。</span><span class="sxs-lookup"><span data-stu-id="aa38f-112">To support dynamic code loading and unloading, it creates an isolated context for loading code and its dependencies in their own <xref:System.Runtime.Loader.AssemblyLoadContext> instance.</span></span>

## <a name="when-do-you-need-multiple-assemblyloadcontext-instances"></a><span data-ttu-id="aa38f-113">複数の AssemblyLoadContext インスタンスが必要な場合</span><span class="sxs-lookup"><span data-stu-id="aa38f-113">When do you need multiple AssemblyLoadContext instances?</span></span>

<span data-ttu-id="aa38f-114">1 つの <xref:System.Runtime.Loader.AssemblyLoadContext> インスタンスは、単純なアセンブリ名 <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> につき 1 つのバージョンの <xref:System.Reflection.Assembly> のみを読み込むように制限されています。</span><span class="sxs-lookup"><span data-stu-id="aa38f-114">A single <xref:System.Runtime.Loader.AssemblyLoadContext> instance is limited to loading exactly one version of an <xref:System.Reflection.Assembly> per simple assembly name, <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="aa38f-115">この制限は、コード モジュールを動的に読み込むときに問題になることがあります。</span><span class="sxs-lookup"><span data-stu-id="aa38f-115">This restriction can become a problem when loading code modules dynamically.</span></span> <span data-ttu-id="aa38f-116">各モジュールは個別にコンパイルされ、<xref:System.Reflection.Assembly> の異なるバージョンに依存する場合があります。</span><span class="sxs-lookup"><span data-stu-id="aa38f-116">Each module is independently compiled and may depend on different versions of an <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="aa38f-117">この問題は、一般的に使用されるライブラリの異なるバージョンに異なるモジュールが依存している場合によく発生します。</span><span class="sxs-lookup"><span data-stu-id="aa38f-117">This problem commonly occurs when different modules depend on different versions of a commonly used library.</span></span>

<span data-ttu-id="aa38f-118">動的なコード読み込みをサポートするために、<xref:System.Runtime.Loader.AssemblyLoadContext> API を使用して、<xref:System.Reflection.Assembly> の競合するバージョンを同じアプリケーション内に読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="aa38f-118">To support dynamically loading code, the <xref:System.Runtime.Loader.AssemblyLoadContext> API provides for loading conflicting versions of an <xref:System.Reflection.Assembly> in the same application.</span></span> <span data-ttu-id="aa38f-119">各 <xref:System.Runtime.Loader.AssemblyLoadContext> インスタンスは、各 <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> を特定の <xref:System.Reflection.Assembly> インスタンスにマップする一意のディクショナリを提供します。</span><span class="sxs-lookup"><span data-stu-id="aa38f-119">Each <xref:System.Runtime.Loader.AssemblyLoadContext> instance provides a unique dictionary mapping each <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> to a specific <xref:System.Reflection.Assembly> instance.</span></span>

<span data-ttu-id="aa38f-120">また、後でアンロードするために、あるコード モジュールに関連する依存関係をグループ化するための便利なメカニズムも提供します。</span><span class="sxs-lookup"><span data-stu-id="aa38f-120">It also provides a convenient mechanism for grouping dependencies related to a code module for later unload.</span></span>

## <a name="what-is-special-about-the-assemblyloadcontextdefault-instance"></a><span data-ttu-id="aa38f-121">AssemblyLoadContext.Default インスタンスの特別な点</span><span class="sxs-lookup"><span data-stu-id="aa38f-121">What is special about the AssemblyLoadContext.Default instance?</span></span>

<span data-ttu-id="aa38f-122"><xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> インスタンスは、起動時にランタイムによって自動的に設定されます。</span><span class="sxs-lookup"><span data-stu-id="aa38f-122">The <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> instance is automatically populated by the runtime at startup.</span></span>  <span data-ttu-id="aa38f-123">[既定のプローブ](default-probing.md)を使用して、すべての静的な依存関係を特定し、検索します。</span><span class="sxs-lookup"><span data-stu-id="aa38f-123">It uses [default probing](default-probing.md) to locate and find all static dependencies.</span></span>

<span data-ttu-id="aa38f-124">最も一般的な依存関係読み込みのシナリオを解決します。</span><span class="sxs-lookup"><span data-stu-id="aa38f-124">It solves the most common dependency loading scenarios.</span></span>

## <a name="how-does-assemblyloadcontext-support-dynamic-dependencies"></a><span data-ttu-id="aa38f-125">AssemblyLoadContext は動的な依存関係をどのようにサポートするか</span><span class="sxs-lookup"><span data-stu-id="aa38f-125">How does AssemblyLoadContext support dynamic dependencies?</span></span>

<span data-ttu-id="aa38f-126"><xref:System.Runtime.Loader.AssemblyLoadContext> には、オーバーライドできるさまざまなイベントと仮想関数があります。</span><span class="sxs-lookup"><span data-stu-id="aa38f-126"><xref:System.Runtime.Loader.AssemblyLoadContext> has various events and virtual functions that can be overridden.</span></span>

<span data-ttu-id="aa38f-127"><xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> インスタンスでは、イベントのオーバーライドのみがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="aa38f-127">The <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> instance only supports overriding the events.</span></span>

<span data-ttu-id="aa38f-128">「[マネージド アセンブリの読み込みアルゴリズム](loading-managed.md)」、「[サテライト アセンブリの読み込みアルゴリズム](loading-resources.md)」、「[アンマネージド (ネイティブ) ライブラリの読み込みアルゴリズム](loading-unmanaged.md)」の各記事では、使用可能なすべてのイベントと仮想関数を参照しています。</span><span class="sxs-lookup"><span data-stu-id="aa38f-128">The articles [Managed assembly loading algorithm](loading-managed.md), [Satellite assembly loading algorithm](loading-resources.md), and [Unmanaged (native) library loading algorithm](loading-unmanaged.md) refer to all the available events and virtual functions.</span></span>  <span data-ttu-id="aa38f-129">これらの記事では、読み込みアルゴリズムでの各イベントと関数の相対位置を示しています。</span><span class="sxs-lookup"><span data-stu-id="aa38f-129">The articles show each event and function's relative position in the loading algorithms.</span></span> <span data-ttu-id="aa38f-130">この記事では、その情報は繰り返しません。</span><span class="sxs-lookup"><span data-stu-id="aa38f-130">This article doesn't reproduce that information.</span></span>

<span data-ttu-id="aa38f-131">ここでは、関連するイベントおよび関数の一般原則について説明します。</span><span class="sxs-lookup"><span data-stu-id="aa38f-131">This section covers the general principles for the relevant events and functions.</span></span>

- <span data-ttu-id="aa38f-132">**反復可能にする**。</span><span class="sxs-lookup"><span data-stu-id="aa38f-132">**Be repeatable**.</span></span> <span data-ttu-id="aa38f-133">特定の依存関係に対するクエリは、常に同じ応答になる必要があります。</span><span class="sxs-lookup"><span data-stu-id="aa38f-133">A query for a specific dependency must always result in the same response.</span></span> <span data-ttu-id="aa38f-134">同じ読み込み済みの依存関係インスタンスを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="aa38f-134">The same loaded dependency instance must be returned.</span></span> <span data-ttu-id="aa38f-135">この要件は、キャッシュの整合性の基本となります。</span><span class="sxs-lookup"><span data-stu-id="aa38f-135">This requirement is fundamental  for cache consistency.</span></span> <span data-ttu-id="aa38f-136">特にマネージド アセンブリについては、<xref:System.Reflection.Assembly> キャッシュが作成されます。</span><span class="sxs-lookup"><span data-stu-id="aa38f-136">For managed assemblies in particular, we're creating a <xref:System.Reflection.Assembly> cache.</span></span> <span data-ttu-id="aa38f-137">キャッシュ キーは、単純なアセンブリ名 <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> です。</span><span class="sxs-lookup"><span data-stu-id="aa38f-137">The cache key is a simple assembly name, <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="aa38f-138">**通常はスローしない**。</span><span class="sxs-lookup"><span data-stu-id="aa38f-138">**Typically don't throw**.</span></span>  <span data-ttu-id="aa38f-139">これらの関数は、要求された依存関係を見つけることができない場合、スローするのではなく `null` を返すことが想定されています。</span><span class="sxs-lookup"><span data-stu-id="aa38f-139">It's expected that these functions return `null` rather than throw when unable to find the requested dependency.</span></span> <span data-ttu-id="aa38f-140">スローすると、検索が途中で終了し、例外が呼び出し元に伝達されます。</span><span class="sxs-lookup"><span data-stu-id="aa38f-140">Throwing will prematurely end the search and be propagate an exception to the caller.</span></span> <span data-ttu-id="aa38f-141">スローは、破損したアセンブリやメモリ不足の状態など、予期しないエラーに限定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aa38f-141">Throwing should be restricted to unexpected errors like a corrupted assembly or an out of memory condition.</span></span>
- <span data-ttu-id="aa38f-142">**再帰を回避する**。</span><span class="sxs-lookup"><span data-stu-id="aa38f-142">**Avoid recursion**.</span></span> <span data-ttu-id="aa38f-143">これらの関数とハンドラーは、依存関係を検索するための読み込みルールを実装することに注意してください。</span><span class="sxs-lookup"><span data-stu-id="aa38f-143">Be aware that these functions and handlers implement the loading rules for locating dependencies.</span></span> <span data-ttu-id="aa38f-144">実装では、再帰をトリガーする API を呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="aa38f-144">Your implementation shouldn't call APIs that trigger recursion.</span></span> <span data-ttu-id="aa38f-145">コードでは、通常、特定のパスまたはメモリ参照の引数を必要とする **AssemblyLoadContext**  読み込み関数を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="aa38f-145">Your code should typically call **AssemblyLoadContext** load functions that require a specific path or memory reference argument.</span></span>
- <span data-ttu-id="aa38f-146">**正しい AssemblyLoadContext に読み込む**。</span><span class="sxs-lookup"><span data-stu-id="aa38f-146">**Load into the correct AssemblyLoadContext**.</span></span> <span data-ttu-id="aa38f-147">依存関係を読み込む場所の選択は、アプリケーション固有です。</span><span class="sxs-lookup"><span data-stu-id="aa38f-147">The choice of where to load dependencies is application-specific.</span></span>  <span data-ttu-id="aa38f-148">この選択は、これらのイベントと関数によって実装されます。</span><span class="sxs-lookup"><span data-stu-id="aa38f-148">The choice is implemented by these events and functions.</span></span> <span data-ttu-id="aa38f-149">コードによって **AssemblyLoadContext** のパスによる読み込み関数を呼び出すときは、コードを読み込むインスタンス上でそれらを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="aa38f-149">When your code calls **AssemblyLoadContext** load-by-path functions call them on the instance where you want the code loaded.</span></span> <span data-ttu-id="aa38f-150">`null` を返し、<xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> により読み込みを処理させるのが最も単純なオプションの場合があります。</span><span class="sxs-lookup"><span data-stu-id="aa38f-150">Sometime returning `null` and letting the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> handle the load may be the simplest option.</span></span>
- <span data-ttu-id="aa38f-151">**スレッドの競合に注意する**。</span><span class="sxs-lookup"><span data-stu-id="aa38f-151">**Be aware of thread races**.</span></span> <span data-ttu-id="aa38f-152">読み込みは複数のスレッドによってトリガーできます。</span><span class="sxs-lookup"><span data-stu-id="aa38f-152">Loading can be triggered by multiple threads.</span></span> <span data-ttu-id="aa38f-153">AssemblyLoadContext は、キャッシュにアセンブリをアトミックに追加することで、スレッドの競合を処理します。</span><span class="sxs-lookup"><span data-stu-id="aa38f-153">The AssemblyLoadContext handles thread races by atomically adding assemblies to its cache.</span></span> <span data-ttu-id="aa38f-154">競合の敗者のインスタンスは破棄されます。</span><span class="sxs-lookup"><span data-stu-id="aa38f-154">The race loser's instance is discarded.</span></span> <span data-ttu-id="aa38f-155">実装ロジックでは、複数のスレッドを適切に処理しない余分なロジックを追加しないでください。</span><span class="sxs-lookup"><span data-stu-id="aa38f-155">In your implementation logic, don't add extra logic that doesn't handle multiple threads properly.</span></span>

## <a name="how-are-dynamic-dependencies-isolated"></a><span data-ttu-id="aa38f-156">動的な依存関係はどのように分離されるか</span><span class="sxs-lookup"><span data-stu-id="aa38f-156">How are dynamic dependencies isolated?</span></span>

<span data-ttu-id="aa38f-157">各 <xref:System.Runtime.Loader.AssemblyLoadContext> インスタンスは、<xref:System.Reflection.Assembly> インスタンスと <xref:System.Type> 定義の一意のスコープを表します。</span><span class="sxs-lookup"><span data-stu-id="aa38f-157">Each <xref:System.Runtime.Loader.AssemblyLoadContext> instance represents a unique scope for <xref:System.Reflection.Assembly> instances and <xref:System.Type> definitions.</span></span>

<span data-ttu-id="aa38f-158">これらの依存関係の間にバイナリの分離はありません。</span><span class="sxs-lookup"><span data-stu-id="aa38f-158">There's no binary isolation between these dependencies.</span></span> <span data-ttu-id="aa38f-159">名前によって互いを検索しないことによってのみ分離されています。</span><span class="sxs-lookup"><span data-stu-id="aa38f-159">They're only isolated by not finding each other by name.</span></span>

<span data-ttu-id="aa38f-160">各 <xref:System.Runtime.Loader.AssemblyLoadContext> は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="aa38f-160">In each <xref:System.Runtime.Loader.AssemblyLoadContext>:</span></span>

- <span data-ttu-id="aa38f-161"><xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> が別の <xref:System.Reflection.Assembly> インスタンスを参照している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="aa38f-161"><xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> may refer to a different <xref:System.Reflection.Assembly> instance.</span></span>
- <span data-ttu-id="aa38f-162"><xref:System.Type.GetType%2A?displayProperty=nameWithType> が、同じ型の `name` に対して異なる型のインスタンスを返す場合があります。</span><span class="sxs-lookup"><span data-stu-id="aa38f-162"><xref:System.Type.GetType%2A?displayProperty=nameWithType> may return a different type instance for the same type `name`.</span></span>

## <a name="how-are-dependencies-shared"></a><span data-ttu-id="aa38f-163">依存関係はどのように共有されるか</span><span class="sxs-lookup"><span data-stu-id="aa38f-163">How are dependencies shared?</span></span>

<span data-ttu-id="aa38f-164">依存関係は、<xref:System.Runtime.Loader.AssemblyLoadContext> インスタンス間で簡単に共有できます。</span><span class="sxs-lookup"><span data-stu-id="aa38f-164">Dependencies can easily be shared between <xref:System.Runtime.Loader.AssemblyLoadContext> instances.</span></span> <span data-ttu-id="aa38f-165">一般的なモデルは、1 つの <xref:System.Runtime.Loader.AssemblyLoadContext> が依存関係を読み込むことです。</span><span class="sxs-lookup"><span data-stu-id="aa38f-165">The general model is for one <xref:System.Runtime.Loader.AssemblyLoadContext> to load a dependency.</span></span>  <span data-ttu-id="aa38f-166">もう 1 つは、読み込まれたアセンブリへの参照を使用して依存関係を共有します。</span><span class="sxs-lookup"><span data-stu-id="aa38f-166">The other shares the dependency by using a reference to the loaded assembly.</span></span>

<span data-ttu-id="aa38f-167">この共有は、ランタイム アセンブリに必要です。</span><span class="sxs-lookup"><span data-stu-id="aa38f-167">This sharing is required of the runtime assemblies.</span></span> <span data-ttu-id="aa38f-168">これらのアセンブリは、<xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> にのみ読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="aa38f-168">These assemblies can only be loaded into the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aa38f-169">`ASP.NET`、`WPF`、`WinForms` などのフレームワークでも同じことが必要です。</span><span class="sxs-lookup"><span data-stu-id="aa38f-169">The same is required for frameworks like `ASP.NET`, `WPF`, or `WinForms`.</span></span>

<span data-ttu-id="aa38f-170">共有の依存関係は <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> に読み込むことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="aa38f-170">It's recommended that shared dependencies should be loaded into <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aa38f-171">この共有は、一般的な設計パターンです。</span><span class="sxs-lookup"><span data-stu-id="aa38f-171">This sharing is the common design pattern.</span></span>

<span data-ttu-id="aa38f-172">共有は、カスタム <xref:System.Runtime.Loader.AssemblyLoadContext> インスタンスのコーディングで実装されます。</span><span class="sxs-lookup"><span data-stu-id="aa38f-172">Sharing is implemented in the coding of the custom <xref:System.Runtime.Loader.AssemblyLoadContext> instance.</span></span> <span data-ttu-id="aa38f-173"><xref:System.Runtime.Loader.AssemblyLoadContext> には、オーバーライドできるさまざまなイベントと仮想関数があります。</span><span class="sxs-lookup"><span data-stu-id="aa38f-173"><xref:System.Runtime.Loader.AssemblyLoadContext> has various events and virtual functions that can be overridden.</span></span> <span data-ttu-id="aa38f-174">これらの関数のいずれかが、別の <xref:System.Runtime.Loader.AssemblyLoadContext> インスタンスに読み込まれた <xref:System.Reflection.Assembly> インスタンスへの参照を返すと、<xref:System.Reflection.Assembly> インスタンスが共有されます。</span><span class="sxs-lookup"><span data-stu-id="aa38f-174">When any of these functions return a reference to an <xref:System.Reflection.Assembly> instance that was loaded in another <xref:System.Runtime.Loader.AssemblyLoadContext> instance, the <xref:System.Reflection.Assembly> instance is shared.</span></span> <span data-ttu-id="aa38f-175">標準読み込みアルゴリズムは、一般的な共有パターンを簡略化するために、読み込みを <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> に任せます。</span><span class="sxs-lookup"><span data-stu-id="aa38f-175">The standard load algorithm defers to <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> for loading to simplify the common sharing pattern.</span></span>  <span data-ttu-id="aa38f-176">「[マネージド アセンブリの読み込みアルゴリズム](loading-managed.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="aa38f-176">See [Managed assembly loading algorithm](loading-managed.md).</span></span>

## <a name="complications"></a><span data-ttu-id="aa38f-177">問題点</span><span class="sxs-lookup"><span data-stu-id="aa38f-177">Complications</span></span>

### <a name="type-conversion-issues"></a><span data-ttu-id="aa38f-178">型変換の問題</span><span class="sxs-lookup"><span data-stu-id="aa38f-178">Type conversion issues</span></span>

<span data-ttu-id="aa38f-179">2 つの <xref:System.Runtime.Loader.AssemblyLoadContext> インスタンスに同じ `name` の型定義が含まれている場合、それらは同じ型ではありません。</span><span class="sxs-lookup"><span data-stu-id="aa38f-179">When two <xref:System.Runtime.Loader.AssemblyLoadContext> instances contain type definitions with the same `name`, they're not the same type.</span></span> <span data-ttu-id="aa38f-180">それらが同じ型になるのは、それらが同じ <xref:System.Reflection.Assembly> インスタンスからのものである場合に限ります。</span><span class="sxs-lookup"><span data-stu-id="aa38f-180">They're the same type if and only if they come from the same <xref:System.Reflection.Assembly> instance.</span></span>

<span data-ttu-id="aa38f-181">さらに問題が複雑なのは、これらの一致しない型に関する例外メッセージが分かりにくい場合があることです。</span><span class="sxs-lookup"><span data-stu-id="aa38f-181">To complicate matters, exception messages about these mismatched types can be confusing.</span></span> <span data-ttu-id="aa38f-182">型は、例外メッセージの中で単純型の名前によって参照されます。</span><span class="sxs-lookup"><span data-stu-id="aa38f-182">The types are referred to in the exception messages by their simple type names.</span></span> <span data-ttu-id="aa38f-183">この場合の一般的な例外メッセージは、次の形式になります。</span><span class="sxs-lookup"><span data-stu-id="aa38f-183">The common exception message in this case would be of the form:</span></span>

> <span data-ttu-id="aa38f-184">型 'IsolatedType' のオブジェクトを型 'IsolatedType' に変換できません。</span><span class="sxs-lookup"><span data-stu-id="aa38f-184">Object of type 'IsolatedType' cannot be converted to type 'IsolatedType'.</span></span>

### <a name="debugging-type-conversion-issues"></a><span data-ttu-id="aa38f-185">型変換の問題のデバッグ</span><span class="sxs-lookup"><span data-stu-id="aa38f-185">Debugging type conversion issues</span></span>

<span data-ttu-id="aa38f-186">一致しない型のペアが存在する場合、次の点にも注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aa38f-186">Given a pair of mismatched types it's important to also know:</span></span>

- <span data-ttu-id="aa38f-187">各型の <xref:System.Type.Assembly?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="aa38f-187">Each type's <xref:System.Type.Assembly?displayProperty=nameWithType></span></span>
- <span data-ttu-id="aa38f-188">各型の <xref:System.Runtime.Loader.AssemblyLoadContext>。これは <xref:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)?displayProperty=nameWithType> 関数を使用して取得できます。</span><span class="sxs-lookup"><span data-stu-id="aa38f-188">Each type's <xref:System.Runtime.Loader.AssemblyLoadContext>, which can be obtained via the <xref:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)?displayProperty=nameWithType> function.</span></span>

<span data-ttu-id="aa38f-189">`a` と `b` の 2 つのオブジェクトがある場合、デバッガーで次のものを評価すると便利です。</span><span class="sxs-lookup"><span data-stu-id="aa38f-189">Given two objects `a` and `b`, evaluating the following in the debugger will be helpful:</span></span>

```csharp
// In debugger look at each assembly's instance, Location, and FullName
a.GetType().Assembly
b.GetType().Assembly
// In debugger look at each AssemblyLoadContext's instance and name
System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(a.GetType().Assembly)
System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(b.GetType().Assembly)
```

### <a name="resolving-type-conversion-issues"></a><span data-ttu-id="aa38f-190">型変換の問題の解決</span><span class="sxs-lookup"><span data-stu-id="aa38f-190">Resolving type conversion issues</span></span>

<span data-ttu-id="aa38f-191">このような型変換の問題を解決するには、2 つの設計パターンがあります。</span><span class="sxs-lookup"><span data-stu-id="aa38f-191">There are two design patterns for solving these type conversion issues.</span></span>

1. <span data-ttu-id="aa38f-192">一般的な共有型を使用します。</span><span class="sxs-lookup"><span data-stu-id="aa38f-192">Use common shared types.</span></span> <span data-ttu-id="aa38f-193">この共有型は、プリミティブなランタイム型にすることも、共有アセンブリに新しい共有型を作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="aa38f-193">This shared type can either be a primitive runtime type, or it can involve creating a new shared type in a shared assembly.</span></span>  <span data-ttu-id="aa38f-194">多くの場合、共有型はアプリケーション アセンブリで定義された [interface ](../../csharp/language-reference/keywords/interface.md) です。</span><span class="sxs-lookup"><span data-stu-id="aa38f-194">Often the shared type is an [interface](../../csharp/language-reference/keywords/interface.md) defined in an application assembly.</span></span> <span data-ttu-id="aa38f-195">参照:[依存関係はどのように共有されるか](#how-are-dependencies-shared)。</span><span class="sxs-lookup"><span data-stu-id="aa38f-195">See also: [How are dependencies shared?](#how-are-dependencies-shared).</span></span>

2. <span data-ttu-id="aa38f-196">マーシャリング技法を使用して、ある型から別の型に変換します。</span><span class="sxs-lookup"><span data-stu-id="aa38f-196">Use marshaling techniques to convert from one type to another.</span></span>
