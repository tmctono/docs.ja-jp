---
title: C# のツアー - 主要な言語分野
description: C# を始めてお使いの方のために、 この言語の基本を説明します。
ms.date: 08/06/2020
ms.openlocfilehash: f0e9bff144cc3c853a82f2ee6b400049df60683d
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/11/2020
ms.locfileid: "88068472"
---
# <a name="major-language-areas"></a><span data-ttu-id="a6354-104">主な言語の領域</span><span class="sxs-lookup"><span data-stu-id="a6354-104">Major language areas</span></span>

## <a name="arrays-collections-and-linq"></a><span data-ttu-id="a6354-105">配列、コレクション、および LINQ</span><span class="sxs-lookup"><span data-stu-id="a6354-105">Arrays, collections, and LINQ</span></span>

<span data-ttu-id="a6354-106">C# と .NET には、さまざまなコレクション型が用意されています。</span><span class="sxs-lookup"><span data-stu-id="a6354-106">C# and .NET provide many different collection types.</span></span> <span data-ttu-id="a6354-107">配列には、言語によって定義された構文があります。</span><span class="sxs-lookup"><span data-stu-id="a6354-107">Arrays have syntax defined by the language.</span></span> <span data-ttu-id="a6354-108">ジェネリック コレクション型は、<xref:System.Collections.Generic?displayProperty=fullName> 名前空間に一覧表示されます。</span><span class="sxs-lookup"><span data-stu-id="a6354-108">Generic collection types are listed in the <xref:System.Collections.Generic?displayProperty=fullName> namespace.</span></span> <span data-ttu-id="a6354-109">特化されたコレクションには、スタック フレーム上の連続メモリにアクセスするための <xref:System.Span%601?displayProperty=nameWithType>、およびマネージド ヒープ上の連続メモリにアクセスするための <xref:System.Memory%601?displayProperty=nameWithType> が含まれます。</span><span class="sxs-lookup"><span data-stu-id="a6354-109">Specialized collections include <xref:System.Span%601?displayProperty=nameWithType> for accessing continuous memory on the stack frame, and <xref:System.Memory%601?displayProperty=nameWithType> for accessing continuous memory on the managed heap.</span></span> <span data-ttu-id="a6354-110">配列、<xref:System.Span%601>、<xref:System.Memory%601> を含むコレクションはすべて、反復の統一原則を共有します。</span><span class="sxs-lookup"><span data-stu-id="a6354-110">All collections, including arrays, <xref:System.Span%601>, and <xref:System.Memory%601> share a unifying principle for iteration.</span></span> <span data-ttu-id="a6354-111"><xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> インターフェイスを使用します。</span><span class="sxs-lookup"><span data-stu-id="a6354-111">You use the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="a6354-112">この統合原則は、LINQ クエリまたはその他のアルゴリズムで任意のコレクション型を使用できることを意味します。</span><span class="sxs-lookup"><span data-stu-id="a6354-112">This unifying principle means that any of the collection types can be used with LINQ queries or other algorithms.</span></span> <span data-ttu-id="a6354-113"><xref:System.Collections.Generic.IEnumerable%601> を使用してメソッドを記述します。それらのアルゴリズムは任意のコレクションで動作します。</span><span class="sxs-lookup"><span data-stu-id="a6354-113">You write methods using <xref:System.Collections.Generic.IEnumerable%601> and those algorithms work with any collection.</span></span>

### <a name="arrays"></a><span data-ttu-id="a6354-114">配列</span><span class="sxs-lookup"><span data-stu-id="a6354-114">Arrays</span></span>

<span data-ttu-id="a6354-115">[***配列***](../programming-guide/arrays/index.md)とは、算出されたインデックスを介してアクセスされる多くの変数を含むデータ構造です。</span><span class="sxs-lookup"><span data-stu-id="a6354-115">An [***array***](../programming-guide/arrays/index.md) is a data structure that contains a number of variables that are accessed through computed indices.</span></span> <span data-ttu-id="a6354-116">配列に含まれる変数は配列の***要素***とも呼ばれ、すべて同じ型です。</span><span class="sxs-lookup"><span data-stu-id="a6354-116">The variables contained in an array, also called the ***elements*** of the array, are all of the same type.</span></span> <span data-ttu-id="a6354-117">この型は配列の***要素型***と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="a6354-117">This type is called the ***element type*** of the array.</span></span>

<span data-ttu-id="a6354-118">配列型は参照型で、配列変数の宣言は、配列インスタンスへの参照の領域を確保します。</span><span class="sxs-lookup"><span data-stu-id="a6354-118">Array types are reference types, and the declaration of an array variable simply sets aside space for a reference to an array instance.</span></span> <span data-ttu-id="a6354-119">実際の配列インスタンスは、`new` 演算子を使用して実行時に動的に作成されます。</span><span class="sxs-lookup"><span data-stu-id="a6354-119">Actual array instances are created dynamically at runtime using the `new` operator.</span></span> <span data-ttu-id="a6354-120">`new` 操作によって、新しい配列インスタンスの***長さ***が指定され、それはインスタンスの有効期間中は固定です。</span><span class="sxs-lookup"><span data-stu-id="a6354-120">The `new` operation specifies the ***length*** of the new array instance, which is then fixed for the lifetime of the instance.</span></span> <span data-ttu-id="a6354-121">配列の要素のインデックスは、`0` から `Length - 1` までです。</span><span class="sxs-lookup"><span data-stu-id="a6354-121">The indices of the elements of an array range from `0` to `Length - 1`.</span></span> <span data-ttu-id="a6354-122">`new` 演算子は配列の要素を自動的に既定値に初期化します。たとえば、すべての数値型はゼロ、すべての参照型は `null` です。</span><span class="sxs-lookup"><span data-stu-id="a6354-122">The `new` operator automatically initializes the elements of an array to their default value, which, for example, is zero for all numeric types and `null` for all reference types.</span></span>

<span data-ttu-id="a6354-123">次の例では、`int` 要素の配列を作成し、その配列を初期化し、配列の内容を出力します。</span><span class="sxs-lookup"><span data-stu-id="a6354-123">The following example creates an array of `int` elements, initializes the array, and prints out the contents of the array.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="ArraysSample":::

<span data-ttu-id="a6354-124">この例は ***1 次元配列***を作成し、操作対象とします。</span><span class="sxs-lookup"><span data-stu-id="a6354-124">This example creates and operates on a ***single-dimensional array***.</span></span> <span data-ttu-id="a6354-125">C# はさらに***多次元配列***をサポートします。</span><span class="sxs-lookup"><span data-stu-id="a6354-125">C# also supports ***multi-dimensional arrays***.</span></span> <span data-ttu-id="a6354-126">配列型の次元数は、配列型の***ランク***とも呼ばれ、配列型の角かっこ内に記述されたコンマの数に 1 を追加したものです。</span><span class="sxs-lookup"><span data-stu-id="a6354-126">The number of dimensions of an array type, also known as the ***rank*** of the array type, is one plus the number of commas written between the square brackets of the array type.</span></span> <span data-ttu-id="a6354-127">次の例では、1 次元、2 次元、および 3 次元の配列をそれぞれ割り当てます。</span><span class="sxs-lookup"><span data-stu-id="a6354-127">The following example allocates a single-dimensional, a two-dimensional, and a three-dimensional array, respectively.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="DeclareArrays":::

<span data-ttu-id="a6354-128">`a1` 配列は 10 の要素、`a2` 配列は 50 (10 × 5) の要素、`a3` 配列は 100 (10 × 5 × 2) の要素を含みます。</span><span class="sxs-lookup"><span data-stu-id="a6354-128">The `a1` array contains 10 elements, the `a2` array contains 50 (10 × 5) elements, and the `a3` array contains 100 (10 × 5 × 2) elements.</span></span>
<span data-ttu-id="a6354-129">配列の要素型には、配列型を含む任意の型を指定できます。</span><span class="sxs-lookup"><span data-stu-id="a6354-129">The element type of an array can be any type, including an array type.</span></span> <span data-ttu-id="a6354-130">配列型の要素を持つ配列は、***ジャグ配列***と呼ばれることがあります。要素の配列の長さがすべて同じである必要がないからです。</span><span class="sxs-lookup"><span data-stu-id="a6354-130">An array with elements of an array type is sometimes called a ***jagged array*** because the lengths of the element arrays don't all have to be the same.</span></span> <span data-ttu-id="a6354-131">次の例では、`int` の配列の配列を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="a6354-131">The following example allocates an array of arrays of `int`:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="ArrayOfArrays":::

<span data-ttu-id="a6354-132">最初の行で 3 つの要素を持つ配列を作成しますが、各々は `int[]` 型で `null` 初期値を持ちます。</span><span class="sxs-lookup"><span data-stu-id="a6354-132">The first line creates an array with three elements, each of type `int[]` and each with an initial value of `null`.</span></span> <span data-ttu-id="a6354-133">次の行では、3 つの要素を、それぞれ異なる長さの配列インスタンスへの参照で初期化します。</span><span class="sxs-lookup"><span data-stu-id="a6354-133">The next lines then initialize the three elements with references to individual array instances of varying lengths.</span></span>

<span data-ttu-id="a6354-134">`new` 演算子では、配列要素の初期値を、区切り記号 `{` および `}` のあいだに記述された式の一覧である***配列初期化子***を使用して指定することができます。</span><span class="sxs-lookup"><span data-stu-id="a6354-134">The `new` operator permits the initial values of the array elements to be specified using an ***array initializer***, which is a list of expressions written between the delimiters `{` and `}`.</span></span> <span data-ttu-id="a6354-135">次の例は、`int[]` を割り当て 3 つの要素で初期化します。</span><span class="sxs-lookup"><span data-stu-id="a6354-135">The following example allocates and initializes an `int[]` with three elements.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="InitializeArray":::

<span data-ttu-id="a6354-136">配列の長さは、`{` と `}` の間にある式の数から推論されます。</span><span class="sxs-lookup"><span data-stu-id="a6354-136">The length of the array is inferred from the number of expressions between `{` and `}`.</span></span> <span data-ttu-id="a6354-137">ローカル変数およびフィールド宣言をさらに短縮して、配列型の記述を省略することができます。</span><span class="sxs-lookup"><span data-stu-id="a6354-137">Local variable and field declarations can be shortened further such that the array type doesn't have to be restated.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="InitializeShortened":::

<span data-ttu-id="a6354-138">前述の例はどちらも、次のコードと同等です。</span><span class="sxs-lookup"><span data-stu-id="a6354-138">Both of the previous examples are equivalent to the following code:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="InitializeGenerated":::

<span data-ttu-id="a6354-139">`foreach` ステートメントを使用すると、任意のコレクションの要素を列挙できます。</span><span class="sxs-lookup"><span data-stu-id="a6354-139">The `foreach` statement can be used to enumerate the elements of any collection.</span></span> <span data-ttu-id="a6354-140">次のコードは、前の例の配列を列挙するものです。</span><span class="sxs-lookup"><span data-stu-id="a6354-140">The following code enumerates the array from the preceding example:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="EnumerateArray":::

<span data-ttu-id="a6354-141">`foreach` ステートメントは <xref:System.Collections.Generic.IEnumerable%601> インターフェイスを使用しているので、任意のコレクションに対して機能します。</span><span class="sxs-lookup"><span data-stu-id="a6354-141">The `foreach` statement uses the <xref:System.Collections.Generic.IEnumerable%601> interface, so can work with any collection.</span></span>

## <a name="string-interpolation"></a><span data-ttu-id="a6354-142">文字列補間</span><span class="sxs-lookup"><span data-stu-id="a6354-142">String interpolation</span></span>

<span data-ttu-id="a6354-143">C# [***文字列補間***](../language-reference/tokens/interpolated.md) を使用すると、書式文字列内に結果が配置される式を定義することで、文字列の書式を設定できます。</span><span class="sxs-lookup"><span data-stu-id="a6354-143">C# [***string interpolation***](../language-reference/tokens/interpolated.md) enables you to format strings by defining expressions whose results are placed in a format string.</span></span> <span data-ttu-id="a6354-144">たとえば、次の例では、特定の日の気温を気象データのセットから出力しています。</span><span class="sxs-lookup"><span data-stu-id="a6354-144">For example, the following example prints the temperature on a given day from a set of weather data:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="StringInterpolation":::

<span data-ttu-id="a6354-145">補間文字列は `$` トークンを使用して宣言されます。</span><span class="sxs-lookup"><span data-stu-id="a6354-145">An interpolated string is declared using the `$` token.</span></span> <span data-ttu-id="a6354-146">文字列補間では、`{` と `}` の間の式が評価され、結果が `string` に変換され、角かっこ内のテキストが式の文字列の結果に置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="a6354-146">String interpolation evaluates the expressions between `{` and `}`, then converts the result to a `string`, and replaces the text between the brackets with the string result of the expression.</span></span> <span data-ttu-id="a6354-147">最初の式 `{weatherData.Data:MM-DD-YYYY}` 内にある `:` は、"*書式文字列*" を指定するものです。</span><span class="sxs-lookup"><span data-stu-id="a6354-147">The `:` in the first expression, `{weatherData.Data:MM-DD-YYYY}` specifies the *format string*.</span></span> <span data-ttu-id="a6354-148">前の例では、それによって、日付を "MM-DD-YYYY" 形式で出力するように指定されています。</span><span class="sxs-lookup"><span data-stu-id="a6354-148">In the preceding example, it specifies that the date should be printed in "MM-DD-YYYY" format.</span></span>

## <a name="pattern-matching"></a><span data-ttu-id="a6354-149">パターン マッチング</span><span class="sxs-lookup"><span data-stu-id="a6354-149">Pattern matching</span></span>

<span data-ttu-id="a6354-150">C# 言語には、オブジェクトの状態を照会し、その状態に基づいてコードを実行するための[***パターン マッチング***](../pattern-matching.md)式が用意されています。</span><span class="sxs-lookup"><span data-stu-id="a6354-150">The C# language provides [***pattern matching***](../pattern-matching.md) expressions to query the state of an object and execute code based on that state.</span></span> <span data-ttu-id="a6354-151">型と、プロパティおよびフィールドの値を調べれば、実行されるアクションを特定することができます。</span><span class="sxs-lookup"><span data-stu-id="a6354-151">You can inspect types and the values of properties and fields to determine which action to take.</span></span> <span data-ttu-id="a6354-152">`switch` 式は、パターン マッチングの主な式です。</span><span class="sxs-lookup"><span data-stu-id="a6354-152">The `switch` expression is the primary expression for pattern matching.</span></span>

## <a name="delegates-and-lambda-expressions"></a><span data-ttu-id="a6354-153">デリゲートおよびラムダ式</span><span class="sxs-lookup"><span data-stu-id="a6354-153">Delegates and lambda expressions</span></span>

<span data-ttu-id="a6354-154">[***デリゲート型***](../delegates-overview.md)は、特定のパラメーター リストおよび戻り値の型を持つメソッドへの参照を表します。</span><span class="sxs-lookup"><span data-stu-id="a6354-154">A [***delegate type***](../delegates-overview.md) represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="a6354-155">デリゲートを使用すると、変数に割り当ててパラメーターとして渡すことのできるエンティティとして、メソッドを処理できます。</span><span class="sxs-lookup"><span data-stu-id="a6354-155">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="a6354-156">デリゲートは、他の言語で検出された関数ポインターの概念に似ています。</span><span class="sxs-lookup"><span data-stu-id="a6354-156">Delegates are similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="a6354-157">ただし、関数ポインターとは異なり、デリゲートはオブジェクト指向で、タイプ セーフです。</span><span class="sxs-lookup"><span data-stu-id="a6354-157">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="a6354-158">次の例では、`Function` という名前のデリゲート型を宣言して使用します。</span><span class="sxs-lookup"><span data-stu-id="a6354-158">The following example declares and uses a delegate type named `Function`.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="DelegateExample":::

<span data-ttu-id="a6354-159">`Function` デリゲート型のインスタンスは、`double` 引数を取得して `double` 値を返す任意のメソッドを参照できます。</span><span class="sxs-lookup"><span data-stu-id="a6354-159">An instance of the `Function` delegate type can reference any method that takes a `double` argument and returns a `double` value.</span></span> <span data-ttu-id="a6354-160">`Apply` メソッドは、指定された `Function` を `double[]` の要素に適用し、`double[]` を結果とともに返します。</span><span class="sxs-lookup"><span data-stu-id="a6354-160">The `Apply` method applies a given `Function` to the elements of a `double[]`, returning a `double[]` with the results.</span></span> <span data-ttu-id="a6354-161">`Main` メソッドでは、`Apply` は `double[]` に 3 つの異なる関数を適用するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="a6354-161">In the `Main` method, `Apply` is used to apply three different functions to a `double[]`.</span></span>

<span data-ttu-id="a6354-162">デリゲートは、静的メソッド (前述の例の `Square` や `Math.Sin` など) またはインスタンス メソッド (前述の例の `m.Multiply` など) のいずれかを参照できます。</span><span class="sxs-lookup"><span data-stu-id="a6354-162">A delegate can reference either a static method (such as `Square` or `Math.Sin` in the previous example) or an instance method (such as `m.Multiply` in the previous example).</span></span> <span data-ttu-id="a6354-163">インスタンス メソッドを参照するデリゲートはまた、特定のオブジェクトを参照し、インスタンス メソッドがデリゲートから呼び出されると、そのオブジェクトは呼び出しで `this` になります。</span><span class="sxs-lookup"><span data-stu-id="a6354-163">A delegate that references an instance method also references a particular object, and when the instance method is invoked through the delegate, that object becomes `this` in the invocation.</span></span>

<span data-ttu-id="a6354-164">宣言時に作成される "インライン メソッド" である匿名関数を使用してデリゲートを作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="a6354-164">Delegates can also be created using anonymous functions, which are "inline methods" that are created when declared.</span></span> <span data-ttu-id="a6354-165">匿名関数では、周囲のメソッドのローカル変数を確認できます。</span><span class="sxs-lookup"><span data-stu-id="a6354-165">Anonymous functions can see the local variables of the surrounding methods.</span></span> <span data-ttu-id="a6354-166">次の例では、クラスは作成されません。</span><span class="sxs-lookup"><span data-stu-id="a6354-166">The following example doesn't create a class:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="UseDelegate":::

<span data-ttu-id="a6354-167">デリゲートでは、自身が参照するメソッドのクラスについては認識も考慮もしません。</span><span class="sxs-lookup"><span data-stu-id="a6354-167">A delegate doesn't know or care about the class of the method it references.</span></span> <span data-ttu-id="a6354-168">重要なのは、参照されるメソッドがデリゲートと同じパラメーターと戻り値の型を持つことです。</span><span class="sxs-lookup"><span data-stu-id="a6354-168">All that matters is that the referenced method has the same parameters and return type as the delegate.</span></span>

## <a name="async--await"></a><span data-ttu-id="a6354-169">async / await</span><span class="sxs-lookup"><span data-stu-id="a6354-169">async / await</span></span>

<span data-ttu-id="a6354-170">C# では、`async` と `await` の 2 つのキーワードを使用した非同期プログラムがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="a6354-170">C# supports asynchronous programs with two keywords: `async` and `await`.</span></span> <span data-ttu-id="a6354-171">メソッドが非同期であることを宣言するには、メソッド宣言に `async` 修飾子を追加します。</span><span class="sxs-lookup"><span data-stu-id="a6354-171">You add the `async` modifier to a method declaration to declare the method is asynchronous.</span></span> <span data-ttu-id="a6354-172">`await` 演算子からは、結果が完了するまで非同期に待機するようにコンパイラに対して指示が出されます。</span><span class="sxs-lookup"><span data-stu-id="a6354-172">The `await` operator tells the compiler to asynchronously await for a result to finish.</span></span> <span data-ttu-id="a6354-173">制御が呼び出し元に返されます。そして、メソッドから、非同期処理の状態を管理する構造体が返されます。</span><span class="sxs-lookup"><span data-stu-id="a6354-173">Control is returned to the caller, and the method returns a structure that manages the state of the asynchronous work.</span></span> <span data-ttu-id="a6354-174">構造体は通常は <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> ですが、awaiter パターンをサポートする任意の型とすることができます。</span><span class="sxs-lookup"><span data-stu-id="a6354-174">The structure is typically a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, but can be any type that supports the awaiter pattern.</span></span> <span data-ttu-id="a6354-175">これらの機能を使用すると、その同期相手として読み取られるが非同期で実行されるコードを記述できます。</span><span class="sxs-lookup"><span data-stu-id="a6354-175">These features enable you to write code that reads as its synchronous counterpart, but executes asynchronously.</span></span> <span data-ttu-id="a6354-176">たとえば、次のコードでは [Microsoft Docs](https://docs.microsoft.com) のホームページがダウンロードされます。</span><span class="sxs-lookup"><span data-stu-id="a6354-176">For example, the following code downloads the home page for [Microsoft docs](https://docs.microsoft.com):</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="AsyncExample":::

<span data-ttu-id="a6354-177">この小さなサンプルは、非同期プログラミングの主な機能を示しています。</span><span class="sxs-lookup"><span data-stu-id="a6354-177">This small sample shows the major features for asynchronous programming:</span></span>

- <span data-ttu-id="a6354-178">メソッドの宣言には、`async` 修飾子が含まれています。</span><span class="sxs-lookup"><span data-stu-id="a6354-178">The method declaration includes the `async` modifier.</span></span>
- <span data-ttu-id="a6354-179">メソッドの本体では、`GetByteArrayAsync` メソッドの戻り値に対して `await` が適用されます。</span><span class="sxs-lookup"><span data-stu-id="a6354-179">The body of the method `await`s the return of the `GetByteArrayAsync` method.</span></span>
- <span data-ttu-id="a6354-180">`return` ステートメント内で指定された型は、メソッドの `Task<T>` 宣言の型引数と一致しています</span><span class="sxs-lookup"><span data-stu-id="a6354-180">The type specified in the `return` statement matches the type argument in the `Task<T>` declaration for the method.</span></span> <span data-ttu-id="a6354-181">(`Task` を返すメソッドの場合は、引数なしで `return` ステートメントが使用されます)。</span><span class="sxs-lookup"><span data-stu-id="a6354-181">(A method that returns a `Task` would use `return` statements without any argument).</span></span>

## <a name="attributes"></a><span data-ttu-id="a6354-182">属性</span><span class="sxs-lookup"><span data-stu-id="a6354-182">Attributes</span></span>

<span data-ttu-id="a6354-183">C# プログラムにおける型、メンバー、およびその他のエンティティは、動作の特定の側面を制御する修飾子をサポートします。</span><span class="sxs-lookup"><span data-stu-id="a6354-183">Types, members, and other entities in a C# program support modifiers that control certain aspects of their behavior.</span></span> <span data-ttu-id="a6354-184">たとえばメソッドのアクセシビリティは、`public`、`protected`、`internal`、および `private` 修飾子を使用して制御されます。</span><span class="sxs-lookup"><span data-stu-id="a6354-184">For example, the accessibility of a method is controlled using the `public`, `protected`, `internal`, and `private` modifiers.</span></span> <span data-ttu-id="a6354-185">C# はこの機能を一般化し、宣言情報のユーザー定義型をプログラム エンティティに追加して実行時に取得できるようにします。</span><span class="sxs-lookup"><span data-stu-id="a6354-185">C# generalizes this capability such that user-defined types of declarative information can be attached to program entities and retrieved at run-time.</span></span> <span data-ttu-id="a6354-186">プログラムでは、[***属性***](../programming-guide/concepts/attributes/index.md)を定義して使用することにより、この追加の宣言情報を指定します。</span><span class="sxs-lookup"><span data-stu-id="a6354-186">Programs specify this additional declarative information by defining and using [***attributes***](../programming-guide/concepts/attributes/index.md).</span></span>

<span data-ttu-id="a6354-187">次の例では、プログラムのエンティティに配置して関連するドキュメントへのリンクを提供することができる `HelpAttribute` 属性を宣言しています。</span><span class="sxs-lookup"><span data-stu-id="a6354-187">The following example declares a `HelpAttribute` attribute that can be placed on program entities to provide links to their associated documentation.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="DefineAttribute":::

<span data-ttu-id="a6354-188">すべての属性クラスは、.NET ライブラリによって提供される <xref:System.Attribute> 基底クラスから派生します。</span><span class="sxs-lookup"><span data-stu-id="a6354-188">All attribute classes derive from the <xref:System.Attribute> base class provided by the .NET library.</span></span> <span data-ttu-id="a6354-189">属性は、関連付けられた宣言の直前に、名前を任意の変数とともに角かっこで囲んで与えることにより、適用できます。</span><span class="sxs-lookup"><span data-stu-id="a6354-189">Attributes can be applied by giving their name, along with any arguments, inside square brackets just before the associated declaration.</span></span> <span data-ttu-id="a6354-190">属性の名前が `Attribute` 内で終わる場合、属性の参照時に、名前のその部分は省略可能です。</span><span class="sxs-lookup"><span data-stu-id="a6354-190">If an attribute’s name ends in `Attribute`, that part of the name can be omitted when the attribute is referenced.</span></span> <span data-ttu-id="a6354-191">たとえば、`HelpAttribute` は次のように使用できます。</span><span class="sxs-lookup"><span data-stu-id="a6354-191">For example, the `HelpAttribute` can be used as follows.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="UseAttributes":::

<span data-ttu-id="a6354-192">この例では `HelpAttribute` を `Widget` クラスにアタッチしています。</span><span class="sxs-lookup"><span data-stu-id="a6354-192">This example attaches a `HelpAttribute` to the `Widget` class.</span></span> <span data-ttu-id="a6354-193">別の `HelpAttribute` をクラス内の `Display` メソッドに追加しています。</span><span class="sxs-lookup"><span data-stu-id="a6354-193">It adds another `HelpAttribute` to the `Display` method in the class.</span></span> <span data-ttu-id="a6354-194">属性クラスのパブリック コンストラクターは、属性がプログラム エンティティにアタッチされたときに提供する必要がある情報を制御します。</span><span class="sxs-lookup"><span data-stu-id="a6354-194">The public constructors of an attribute class control the information that must be provided when the attribute is attached to a program entity.</span></span> <span data-ttu-id="a6354-195">その属性クラスのパブリックの読み取り/書き込みプロパティを参照することにより (`Topic` プロパティへの参照のような)、追加情報を提供することができます。</span><span class="sxs-lookup"><span data-stu-id="a6354-195">Additional information can be provided by referencing public read-write properties of the attribute class (such as the reference to the `Topic` property previously).</span></span>

<span data-ttu-id="a6354-196">属性によって定義されるメタデータは、実行時にリフレクションを使用して読み取り、操作することができます。</span><span class="sxs-lookup"><span data-stu-id="a6354-196">The metadata defined by attributes can be read and manipulated at runtime using reflection.</span></span> <span data-ttu-id="a6354-197">この手法で特定の属性が要求されると、プログラム ソースで提供される情報で属性クラスのコンストラクターが呼び出され、作成された属性インスタンスが返されます。</span><span class="sxs-lookup"><span data-stu-id="a6354-197">When a particular attribute is requested using this technique, the constructor for the attribute class is invoked with the information provided in the program source, and the resulting attribute instance is returned.</span></span> <span data-ttu-id="a6354-198">追加情報がプロパティを通じて提供された場合、属性インスタンスが返される前に、これらのプロパティは指定された値に設定されます。</span><span class="sxs-lookup"><span data-stu-id="a6354-198">If additional information was provided through properties, those properties are set to the given values before the attribute instance is returned.</span></span>

<span data-ttu-id="a6354-199">`Widget` クラスとその `Display` メソッドに関連付けられた `HelpAttribute` インスタンスを取得する方法を、次のコード サンプルに示します。</span><span class="sxs-lookup"><span data-stu-id="a6354-199">The following code sample demonstrates how to get the `HelpAttribute` instances associated to the `Widget` class and its `Display` method.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="ReadAttributes":::

## <a name="learn-more"></a><span data-ttu-id="a6354-200">詳細情報</span><span class="sxs-lookup"><span data-stu-id="a6354-200">Learn more</span></span>

<span data-ttu-id="a6354-201">C# の詳細については、[チュートリアル](../tutorials/index.md)のいずれかをお試しください。</span><span class="sxs-lookup"><span data-stu-id="a6354-201">You can explore more about C# by trying one of our [tutorials](../tutorials/index.md).</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="a6354-202">[[戻る]](program-building-blocks.md)</span><span class="sxs-lookup"><span data-stu-id="a6354-202">[Previous](program-building-blocks.md)</span></span>
