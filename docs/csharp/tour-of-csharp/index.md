---
title: C# のツアー - C# ガイド
description: C# を始めてお使いの方のために、 この言語の基本を説明します。
ms.date: 08/06/2020
ms.openlocfilehash: 9fa292e8e85832d831f36cf0f21512aa0cf32580
ms.sourcegitcommit: c4a15c6c4ecbb8a46ad4e67d9b3ab9b8b031d849
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/20/2020
ms.locfileid: "88656229"
---
# <a name="a-tour-of-the-c-language"></a>C# 言語のツアー

C# ("シー シャープ" と読みます) は、最新のタイプ セーフなオブジェクト指向のプログラミング言語です。 C# は C 言語ファミリーをルーツとしているため、C、C++、Java、JavaScript のプログラマーであればすぐに使いこなすことができます。 このツアーでは、C# 8 以前の言語の主要なコンポーネントの概要について説明します。 対話型の例を通して言語を調べたい場合は、[C# の概要](../tutorials/intro-to-csharp/index.md)に関するチュートリアルを参照してください。

C# は、オブジェクト指向、"***コンポーネント指向***" のプログラミング言語です。 C# はこれらの概念を直接サポートする言語コンストラクトを提供しているので、自然にソフトウェア コンポーネントを作成して使用することができます。 当初から、C# では、新しいワークロードと新しいソフトウェア設計プラクティスをサポートする機能が追加されています。

C# には、堅牢で永続的なアプリケーションの構築を支援するさまざまな機能が用意されています。 "[***ガベージ コレクション***](../../standard/garbage-collection/index.md)" は、到達できず、使用されていないオブジェクトによって占有されたメモリを自動的に解放します。 "[***例外処理***](../programming-guide/exceptions/index.md)" は、エラーの検出と復旧を行うための構造化された拡張可能なアプローチを提供します。 "[***ラムダ式***](../language-reference/operators/lambda-expressions.md)" は、関数型プログラミング手法をサポートします。 "[***クエリ構文***](../linq/index.md)" では、任意のソースからのデータを操作するための一般的なパターンが作成されます。 "[***非同期操作***](../programming-guide/concepts/async/index.md)" の言語サポートでは、分散システムを構築するための構文が提供されます。 "[***パターン マッチング***](..//pattern-matching.md)" には、最新の分散システムのアルゴリズムからのデータを簡単に分割するための構文が用意されています。 C# は "[***統合型システム***](../programming-guide/types/index.md)" を採用しています。 `int` や `double` などのプリミティブ型を含めた C# のすべての型は、ルートとなる 1 つの `object` 型から派生しています。 すべての型は、一般的な操作のセットを共有します。 すべての型の値を一貫した方法で格納、転送、操作することができます。 さらに、C# では、ユーザー定義の参照型と値型の両方がサポートされています。 C# では、オブジェクトを動的に割り当てたり、軽量の構造体をインラインで格納したりすることもできます。

C# では、プログラムとライブラリが互換性を保ちながら時間とともに進化できるように、"***バージョン管理***" に重点が置かれています。 C# の設計でバージョン管理の考慮の影響を直接受けている側面として、別個の `virtual` 修飾子と `override` 修飾子、メソッドのオーバーロードの解決規則、明示的なインターフェイス メンバー宣言のサポートなどがあります。

## <a name="hello-world"></a>Hello world

"Hello, World" は、プログラミング言語を紹介するために伝統的に使用されているプログラムです。 これを C# で記述すると次のようになります。

:::code language="csharp" interactive="try-dotnet" source="./snippets/shared/HelloWorld.cs":::

"Hello, World" プログラムは `System` 名前空間を参照する `using` ディレクティブで始まります。 名前空間は、C# のプログラムとライブラリを階層的に整理するための手段です。 名前空間には、型と他の名前空間が含まれます。たとえば、`System` 名前空間には多数の型 (プログラムで参照される `Console` クラスなど) と、他の多数の名前空間 (`IO` や `Collections` など) が含まれます。 特定の名前空間を参照する `using` ディレクティブを使用すると、その名前空間のメンバーである型を修飾せずに使用できます。 `using` ディレクティブにより、プログラムで `Console.WriteLine` を `System.Console.WriteLine` の省略形として使用できます。

"Hello, World" プログラムで宣言された `Hello` クラスにはメンバーが 1 つあります。`Main` という名前のメソッドです。 `Main` メソッドは `static` 修飾子を使用して宣言されています。 インスタンス メソッドが `this` で囲んだ特定のオブジェクト インスタンスを参照できるのに対し、静的メソッドは特定のオブジェクトを参照せずに機能します。 規則により、`Main` という名前の静的メソッドは C# プログラムのエントリ ポイントとして使用されます。

プログラムの出力は、`System` 名前空間にある `Console` クラスの `WriteLine` メソッドによって生成されます。 このクラスは、コンパイラによって自動的に参照される、標準のクラス ライブラリで提供されています。

## <a name="types-and-variables"></a>型と変数

C# には、*値型*と*参照型*という 2 種類の型があります。 値型の変数が直接データを格納するのに対して、参照型の変数はデータへの参照を格納し、後者はオブジェクトとして知られています。 参照型を使用すると 2 つの変数が同じオブジェクトを参照でき、1 つの変数に対する演算によって、もう一方の変数によって参照されるオブジェクトに影響を与えることができます。 値型の場合、各変数によって独自のデータ コピーが保持され、1 つの変数に対する演算によって別の変数に影響を与えることはできません (`ref` と `out` のパラメーターの変数を除く)。

"***識別子***" は変数名です。 識別子は、空白を含まない unicode 文字のシーケンスです。 先頭に `@` が指定されている場合、識別子は C# の予約語になります。 これは、他の言語と対話するときに便利です。

C# の値型はさらに、"*単純型*"、"*列挙型*"、"*構造体型*"、および "*null 許容値型*" に分けられます。 C# の参照型はさらに、"*クラス型*"、"*インターフェイス型*"、"*配列型*"、および "*デリゲート型*" に分けられます。

以下は、C# の型システムの概要です。

- [値型](../language-reference/builtin-types/value-types.md)
  - [単純型](../language-reference/builtin-types/value-types.md#built-in-value-types)
    - [符号付きの整数](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`、`short`、`int`、`long`
    - [符号なしの整数](../language-reference/builtin-types/integral-numeric-types.md): `byte`、`ushort`、`uint`、`ulong`
    - [Unicode 文字](../../standard/base-types/character-encoding-introduction.md): `char` (UTF-16 コード単位を表します)
    - [IEEE バイナリ浮動小数点数](../language-reference/builtin-types/floating-point-numeric-types.md): `float`、`double`
    - [高精度 10 進浮動小数点数](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`
    - ブール値: `bool` (ブール値を表します。値は `true` か `false` のどちらかです)
  - [列挙型](../language-reference/builtin-types/enum.md)
    - 形式 `enum E {...}` のユーザー定義型。 `enum` 型は、名前付き定数を持つ固有の型です。 `enum` 型にはそれぞれ基になる型があり、これは 8 つの整数型のいずれかでなければいけません。 `enum` 型の値のセットは、その基になる型の値のセットと同じです。
  - [構造体の型](../language-reference/builtin-types/struct.md)
    - `struct S {...}` 形式のユーザー定義型
  - [null 許容値型](../language-reference/builtin-types/nullable-value-types.md)
    - `null` 値を持つその他すべての値型の拡張子
  - [タプル値型](../language-reference/builtin-types/value-tuples.md)
    - `(T1, T2, ...)` 形式のユーザー定義型
- [参照型](../language-reference/keywords/reference-types.md)
  - [クラス型](../language-reference/keywords/class.md)
    - その他すべての型の最終的な基底クラス: `object`
    - [Unicode 文字列](../../standard/base-types/character-encoding-introduction.md): `string` (一連の UTF-16 コード単位を表します)
    - `class C {...}` 形式のユーザー定義型
  - [インターフェイス型](../language-reference/keywords/interface.md)
    - `interface I {...}` 形式のユーザー定義型
  - [配列型](../programming-guide/arrays/index.md)
    - 1 次元、多次元、およびジャグ (例: `int[]`、`int[,]`、`int[][]`)
  - [デリゲート型](../language-reference/builtin-types/reference-types.md#the-delegate-type)
    - `delegate int D(...)` 形式のユーザー定義型

C# プログラムでは*型宣言*を使用して新しい型を作成します。 型宣言は、新しい型の名前とメンバーを指定します。 C# の型カテゴリのうち 5 つはユーザー定義が可能です。クラス型、構造体型、インターフェイス型、列挙型、そしてデリゲート型です。

- `class` 型は、データ メンバー (フィールド) と関数メンバー (メソッド、プロパティ、その他) を含むデータ構造を定義します。 クラス型では、単一継承とポリモーフィズムをサポートします。このメカニズムによって派生クラスが基底クラスを拡張して特殊化できます。
- `struct` 型は、データ メンバーおよび関数メンバーで構造体を表す点において、クラス型に似ています。 ただしクラスと異なり、構造体は値型で、通常はヒープ割り当てが不要です。 構造体型ではユーザー指定の継承がサポートされず、すべての構造体型によって暗黙的に `object` 型が継承されます。
- `interface` 型では、パブリック メンバーの名前付きセットとしてコントラクトが定義されます。 `interface` を実装する `class` または `struct` は、インターフェイスのメンバーの実装を提供する必要があります。 `interface` は複数の基底インターフェイスから継承することがあり、`class` または `struct` は複数のインターフェイスを実装することがあります。
- `delegate` 型は、特定のパラメーター リストおよび戻り値を使用してメソッドへの参照を表します。 デリゲートを使用すると、変数に割り当ててパラメーターとして渡すことのできるエンティティとして、メソッドを処理できます。 デリゲートは、関数型言語で提供される関数の型に似ています。 また、他のいくつかの言語で見られる関数ポインターの概念に似ています。 ただし、関数ポインターとは異なり、デリゲートはオブジェクト指向で、タイプ セーフです。

`class`、`struct`、`interface` および `delegate` の型はすべてジェネリックをサポートし、他の型と共にパラメーター化できます。

C# は、あらゆる型の 1 次元および多次元の配列をサポートしています。 上記の型とは異なり、配列型は使用前に宣言する必要がありません。 代わりに配列型は、角かっこで囲んだ型名を後に付けることにより構成されます。 たとえば、`int[]` は `int` の 1 次元配列で、`int[,]` は `int` の 2 次元配列、そして `int[][]` は `int` の 1 次元配列または "ジャグ配列" の 1 次元配列です。

null 許容型は個別の定義を必要としません。 null 非許容型 `T` のそれぞれについて、対応する null 許容型 `T?` があり、これは追加値 `null` を保持することができます。 たとえば、`int?` は 32 ビット整数または値 `null` を保持できる型であり、`string?` は `string` または値 `null` を保持できる型です。

C# の型システムは、任意の型の値を `object` として扱えるように統一されています。 C# における型はすべて、直接的または間接的に `object` クラス型から派生し、`object` はすべての型の究極の基底クラスです。 参照型の値は、値を単純に `object` 型としてみなすことによってオブジェクトとして扱われます。 値型の値は、*ボックス化*と*ボックス化解除操作*を実行することによって、オブジェクトとして扱われます。 次の例では、`int` 値は `object` 値に変換され、また `int` に戻されます。

:::code language="csharp" source="./snippets/shared/Program.cs" ID="boxing" :::

値型の値が `object` 参照に割り当てられている場合は、値を保持するために "ボックス" が割り当てられます。 このボックスは参照型のインスタンスであり、そのボックスに値がコピーされます。 逆に、`object` 参照が値型にキャストされると、参照先の `object` が適切な値型のボックスかどうかが確認されます。 確認が成功すると、ボックス内の値が値型にコピーされます。

C# の型システムが統一されたということは、実質的には値型が "オンデマンドで" `object` 参照として扱われるということです。 こうした統一性があるため、`object` 型を使用する汎用的なライブラリは、参照型と値型の両方を含め、`object` から派生するすべての型で使用できます。

C# には、フィールド、配列要素、ローカル変数、パラメーターなどの、いくつかの種類の*変数*があります。 変数は格納場所を表します。 各変数には型があり、次のように、この型によって変数に格納できる値が決まります。

- null 非許容値型
  - 型そのものの値
- null 許容値型
  - `null` 値、またはその型そのものの値
- object
  - `null` 参照、任意の参照型のオブジェクトへの参照、または任意の値型のボックス化された値への参照
- クラス型
  - `null` 参照、そのクラス型のインスタンスへの参照、またはそのクラス型から派生したクラスのインスタンスへの参照
- インターフェイスの型
  - `null` 参照、そのインターフェイスの型を実装するクラス型のインスタンスへの参照、またはそのインターフェイス型を実装する値型のボックス化された値への参照
- 配列型
  - `null` 参照、その配列型のインスタンスへの参照、または互換性のある配列型のインスタンスへの参照
- デリゲート型
  - `null` 参照、またはそのデリゲート型と互換性のあるインスタンスへの参照

## <a name="program-structure"></a>プログラムの構造

C# における主要な組織的概念は、"[***プログラム***](../programming-guide/inside-a-program/index.md)"、"[***名前空間***](../programming-guide/namespaces/index.md)"、"[***型***](../programming-guide/types/index.md)"、"[***メンバー***](../programming-guide/classes-and-structs/members.md)"、および "[***アセンブリ***](../../standard/assembly/index.md)" です。 プログラムは型を宣言します。型にはメンバーが含まれていて、複数の名前空間に編成することができます。 型の例には、クラス、構造体、インターフェイスがあります。 メンバーの例には、フィールド、メソッド、プロパティ、およびイベントがあります。 C# プログラムはコンパイルされると、物理的にアセンブリにパッケージ化されます。 アセンブリには通常、***アプリケーション***または***ライブラリ***のどちらかを実行するかに応じて、それぞれ `.exe` または `.dll` のファイル拡張子があります。

小さな例として、次のコードを含むアセンブリについて考えてみます。

:::code language="csharp" source="./snippets/shared/AcmeStack.cs":::

このクラスの完全修飾名は `Acme.Collections.Stack` です。 このクラスには複数のメンバーが含まれています: `top` という名前のフィールドが 1 つ、`Push` と `Pop` という名前のメソッドが合わせて 2 つ、そして `Entry` という名前の入れ子になったクラスです。 `Entry` クラスにはさらに、3 つのメンバーが含まれています: `next` という名前のフィールド、`data` という名前のフィールド、およびコンストラクターです。 `Stack` は "*ジェネリック*" クラスです。 これには、使用時に具象型に置き換えられる 1 つの型パラメーター `T` があります。

> [!NOTE]
> "*スタック*" は "先入れ後出し" (FILO) コレクションです。 新しい要素がスタックの先頭に追加されます。 要素が削除されると、それはスタックの一番上から削除されます。

アセンブリには実行可能なコードが中間言語 (IL) の形式で含まれていて、シンボル情報がメタデータの形式で含まれています。 実行前に、.NET 共通言語ランタイムの Just-In-Time (JIT) コンパイラによって、アセンブリの IL コードはプロセッサ固有のコードに変換されます。

アセンブリはコードとメタデータの両方を含む自己記述的な機能的単位であるため、`#include` ディレクティブおよびヘッダー ファイルを C# に含める必要はありません。 特定のアセンブリに含まれているパブリックの型とメンバーは、単にプログラムのコンパイル中にそのアセンブリを参照することにより、C# プログラムで利用可能になります。 たとえば、このプログラムでは `acme.dll` アセンブリの `Acme.Collections.Stack` クラスを使用しています。

:::code language="csharp" source="./snippets/shared/StackUsage.cs":::

このプログラムをコンパイルするには、前の例で定義されているスタック クラスを含むアセンブリを "*参照*" する必要があります。

C# プログラムは複数のソース ファイルに格納できます。 C# プログラムがコンパイルされると、すべてのソース ファイルがまとめて処理され、ソース ファイルは自由に相互参照できます。 概念的には、処理される前にすべてのソース ファイルが 1 つの大きなファイルに連結されるかのようになります。 C# では事前宣言をする必要がありません。ごく一部の例外を除いて、宣言の順序は重要でないためです。 C# ではソース ファイルがパブリック型 1 つのみの宣言に制限されません。また、ソース ファイルの名前がソース ファイルで宣言された型に一致する必要もありません。

これらの組織ブロックについては、このツアーの他の記事をご覧ください。

>[!div class="step-by-step"]
>[次へ](types.md)
